module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// require() chunk loading for javascript
/******/
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + ({"1":"components/global/CopyCode","2":"components/global/YouTube","3":"pages/_slug","4":"pages/index"}[chunkId]||chunkId) + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/_nuxt/";
/******/
/******/ 	// uncaught error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using import().catch()
/******/ 		});
/******/ 	};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 60);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("vue");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "capitalize", function() { return /* reexport */ utils_capitalize; });
__webpack_require__.d(__webpack_exports__, "defer", function() { return /* reexport */ defer["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "isDomElement", function() { return /* reexport */ utils_isDomElement; });
__webpack_require__.d(__webpack_exports__, "getContainerNode", function() { return /* reexport */ utils_getContainerNode; });
__webpack_require__.d(__webpack_exports__, "isSpecialClick", function() { return /* reexport */ utils_isSpecialClick; });
__webpack_require__.d(__webpack_exports__, "prepareTemplateProps", function() { return /* reexport */ utils_prepareTemplateProps; });
__webpack_require__.d(__webpack_exports__, "renderTemplate", function() { return /* reexport */ utils_renderTemplate; });
__webpack_require__.d(__webpack_exports__, "getRefinements", function() { return /* reexport */ getRefinements["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "clearRefinements", function() { return /* reexport */ clearRefinements["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "escapeRefinement", function() { return /* reexport */ escapeRefinement["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "unescapeRefinement", function() { return /* reexport */ unescapeRefinement["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "checkRendering", function() { return /* reexport */ checkRendering["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "checkIndexUiState", function() { return /* reexport */ checkIndexUiState; });
__webpack_require__.d(__webpack_exports__, "getPropertyByPath", function() { return /* reexport */ getPropertyByPath["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "getObjectType", function() { return /* reexport */ getObjectType["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "noop", function() { return /* reexport */ noop["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "isFiniteNumber", function() { return /* reexport */ isFiniteNumber["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "isPlainObject", function() { return /* reexport */ isPlainObject["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "uniq", function() { return /* reexport */ uniq["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "range", function() { return /* reexport */ range["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "isEqual", function() { return /* reexport */ isEqual["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "escape", function() { return /* reexport */ utils_escape["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "unescape", function() { return /* reexport */ utils_unescape["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "concatHighlightedParts", function() { return /* reexport */ concatHighlightedParts["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "getHighlightedParts", function() { return /* reexport */ getHighlightedParts["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "getHighlightFromSiblings", function() { return /* reexport */ getHighlightFromSiblings["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "reverseHighlightedParts", function() { return /* reexport */ reverseHighlightedParts["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "find", function() { return /* reexport */ find["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "findIndex", function() { return /* reexport */ findIndex["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "mergeSearchParameters", function() { return /* reexport */ mergeSearchParameters["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "resolveSearchParameters", function() { return /* reexport */ resolveSearchParameters["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "toArray", function() { return /* reexport */ toArray["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "warning", function() { return /* reexport */ _warning; });
__webpack_require__.d(__webpack_exports__, "deprecate", function() { return /* reexport */ deprecate; });
__webpack_require__.d(__webpack_exports__, "createDocumentationLink", function() { return /* reexport */ documentation["a" /* createDocumentationLink */]; });
__webpack_require__.d(__webpack_exports__, "createDocumentationMessageGenerator", function() { return /* reexport */ documentation["b" /* createDocumentationMessageGenerator */]; });
__webpack_require__.d(__webpack_exports__, "aroundLatLngToPosition", function() { return /* reexport */ geo_search["a" /* aroundLatLngToPosition */]; });
__webpack_require__.d(__webpack_exports__, "insideBoundingBoxToBoundingBox", function() { return /* reexport */ geo_search["b" /* insideBoundingBoxToBoundingBox */]; });
__webpack_require__.d(__webpack_exports__, "addAbsolutePosition", function() { return /* reexport */ hits_absolute_position["a" /* addAbsolutePosition */]; });
__webpack_require__.d(__webpack_exports__, "addQueryID", function() { return /* reexport */ hits_query_id["a" /* addQueryID */]; });
__webpack_require__.d(__webpack_exports__, "isFacetRefined", function() { return /* reexport */ isFacetRefined["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "createSendEventForFacet", function() { return /* reexport */ createSendEventForFacet["a" /* createSendEventForFacet */]; });
__webpack_require__.d(__webpack_exports__, "createSendEventForHits", function() { return /* reexport */ createSendEventForHits["b" /* createSendEventForHits */]; });
__webpack_require__.d(__webpack_exports__, "createBindEventForHits", function() { return /* reexport */ createSendEventForHits["a" /* createBindEventForHits */]; });
__webpack_require__.d(__webpack_exports__, "getAppIdAndApiKey", function() { return /* reexport */ getAppIdAndApiKey; });
__webpack_require__.d(__webpack_exports__, "convertNumericRefinementsToFilters", function() { return /* reexport */ convertNumericRefinementsToFilters["a" /* convertNumericRefinementsToFilters */]; });

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/capitalize.js
function capitalize(text) {
  return text.toString().charAt(0).toUpperCase() + text.toString().slice(1);
}

/* harmony default export */ var utils_capitalize = (capitalize);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/defer.js
var defer = __webpack_require__(49);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/isDomElement.js
function isDomElement(object) {
  return object instanceof HTMLElement || Boolean(object) && object.nodeType > 0;
}

/* harmony default export */ var utils_isDomElement = (isDomElement);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/getContainerNode.js

/**
 * Return the container. If it's a string, it is considered a
 * css selector and retrieves the first matching element. Otherwise
 * test if it validates that it's a correct DOMElement.
 *
 * @param {string|HTMLElement} selectorOrHTMLElement CSS Selector or container node.
 * @return {HTMLElement} Container node
 * @throws Error when the type is not correct
 */

function getContainerNode(selectorOrHTMLElement) {
  var isSelectorString = typeof selectorOrHTMLElement === 'string';
  var domElement = isSelectorString ? document.querySelector(selectorOrHTMLElement) : selectorOrHTMLElement;

  if (!utils_isDomElement(domElement)) {
    var errorMessage = 'Container must be `string` or `HTMLElement`.';

    if (isSelectorString) {
      errorMessage += " Unable to find ".concat(selectorOrHTMLElement);
    }

    throw new Error(errorMessage);
  }

  return domElement;
}

/* harmony default export */ var utils_getContainerNode = (getContainerNode);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/isSpecialClick.js
function isSpecialClick(event) {
  var isMiddleClick = event.button === 1;
  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
}

/* harmony default export */ var utils_isSpecialClick = (isSpecialClick);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/uniq.js
var uniq = __webpack_require__(8);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/prepareTemplateProps.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}



function prepareTemplates() {
  var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var allKeys = Object(uniq["a" /* default */])([].concat(_toConsumableArray(Object.keys(defaultTemplates)), _toConsumableArray(Object.keys(templates))));
  return allKeys.reduce(function (config, key) {
    var defaultTemplate = defaultTemplates[key];
    var customTemplate = templates[key];
    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;
    config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;
    config.useCustomCompileOptions[key] = isCustomTemplate;
    return config;
  }, {
    templates: {},
    useCustomCompileOptions: {}
  });
}
/**
 * Prepares an object to be passed to the Template widget
 */


function prepareTemplateProps(_ref) {
  var defaultTemplates = _ref.defaultTemplates,
      templates = _ref.templates,
      templatesConfig = _ref.templatesConfig;
  var preparedTemplates = prepareTemplates(defaultTemplates, templates);
  return _objectSpread({
    templatesConfig: templatesConfig
  }, preparedTemplates);
}

/* harmony default export */ var utils_prepareTemplateProps = (prepareTemplateProps);
// EXTERNAL MODULE: external "hogan.js"
var external_hogan_js_ = __webpack_require__(30);
var external_hogan_js_default = /*#__PURE__*/__webpack_require__.n(external_hogan_js_);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/renderTemplate.js
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function renderTemplate_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function renderTemplate_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      renderTemplate_ownKeys(Object(source), true).forEach(function (key) {
        renderTemplate_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      renderTemplate_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function renderTemplate_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

 // We add all our template helper methods to the template as lambdas. Note
// that lambdas in Mustache are supposed to accept a second argument of
// `render` to get the rendered value, not the literal `{{value}}`. But
// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).

function transformHelpersToHogan() {
  var helpers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var compileOptions = arguments.length > 1 ? arguments[1] : undefined;
  var data = arguments.length > 2 ? arguments[2] : undefined;
  return Object.keys(helpers).reduce(function (acc, helperKey) {
    return renderTemplate_objectSpread({}, acc, renderTemplate_defineProperty({}, helperKey, function () {
      var _this = this;

      return function (text) {
        var render = function render(value) {
          return external_hogan_js_default.a.compile(value, compileOptions).render(_this);
        };

        return helpers[helperKey].call(data, text, render);
      };
    }));
  }, {});
}

function renderTemplate(_ref) {
  var templates = _ref.templates,
      templateKey = _ref.templateKey,
      compileOptions = _ref.compileOptions,
      helpers = _ref.helpers,
      data = _ref.data,
      bindEvent = _ref.bindEvent;
  var template = templates[templateKey];

  var templateType = _typeof(template);

  var isTemplateString = templateType === 'string';
  var isTemplateFunction = templateType === 'function';

  if (!isTemplateString && !isTemplateFunction) {
    throw new Error("Template must be 'string' or 'function', was '".concat(templateType, "' (key: ").concat(templateKey, ")"));
  }

  if (isTemplateFunction) {
    return template(data, bindEvent);
  }

  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);
  return external_hogan_js_default.a.compile(template, compileOptions).render(renderTemplate_objectSpread({}, data, {
    helpers: transformedHelpers
  })).replace(/[ \n\r\t\f\xA0]+/g, function (spaces) {
    return spaces.replace(/(^|\xA0+)[^\xA0]+/g, '$1 ');
  }).trim();
}

/* harmony default export */ var utils_renderTemplate = (renderTemplate);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getRefinements.js
var getRefinements = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/clearRefinements.js
var clearRefinements = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escapeRefinement.js
var escapeRefinement = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescapeRefinement.js
var unescapeRefinement = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkRendering.js
var checkRendering = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkIndexUiState.js
function checkIndexUiState_toConsumableArray(arr) {
  return checkIndexUiState_arrayWithoutHoles(arr) || checkIndexUiState_iterableToArray(arr) || checkIndexUiState_nonIterableSpread();
}

function checkIndexUiState_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function checkIndexUiState_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function checkIndexUiState_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


 // Some connectors are responsible for multiple widgets so we need
// to map them.

function getWidgetNames(connectorName) {
  switch (connectorName) {
    case 'range':
      return [];

    case 'menu':
      return ['menu', 'menuSelect'];

    default:
      return [connectorName];
  }
}

var stateToWidgetsMap = {
  query: {
    connectors: ['connectSearchBox'],
    widgets: ['ais.searchBox', 'ais.autocomplete', 'ais.voiceSearch']
  },
  refinementList: {
    connectors: ['connectRefinementList'],
    widgets: ['ais.refinementList']
  },
  menu: {
    connectors: ['connectMenu'],
    widgets: ['ais.menu']
  },
  hierarchicalMenu: {
    connectors: ['connectHierarchicalMenu'],
    widgets: ['ais.hierarchicalMenu']
  },
  numericMenu: {
    connectors: ['connectNumericMenu'],
    widgets: ['ais.numericMenu']
  },
  ratingMenu: {
    connectors: ['connectRatingMenu'],
    widgets: ['ais.ratingMenu']
  },
  range: {
    connectors: ['connectRange'],
    widgets: ['ais.rangeInput', 'ais.rangeSlider', 'ais.range']
  },
  toggle: {
    connectors: ['connectToggleRefinement'],
    widgets: ['ais.toggleRefinement']
  },
  geoSearch: {
    connectors: ['connectGeoSearch'],
    widgets: ['ais.geoSearch']
  },
  sortBy: {
    connectors: ['connectSortBy'],
    widgets: ['ais.sortBy']
  },
  page: {
    connectors: ['connectPagination'],
    widgets: ['ais.pagination', 'ais.infiniteHits']
  },
  hitsPerPage: {
    connectors: ['connectHitsPerPage'],
    widgets: ['ais.hitsPerPage']
  },
  configure: {
    connectors: ['connectConfigure'],
    widgets: ['ais.configure']
  },
  places: {
    connectors: [],
    widgets: ['ais.places']
  }
};
function checkIndexUiState(_ref) {
  var index = _ref.index,
      indexUiState = _ref.indexUiState;
  var mountedWidgets = index.getWidgets().map(function (widget) {
    return widget.$$type;
  }).filter(Boolean);
  var missingWidgets = Object.keys(indexUiState).reduce(function (acc, parameter) {
    var requiredWidgets = stateToWidgetsMap[parameter] && stateToWidgetsMap[parameter].widgets;

    if (requiredWidgets && !requiredWidgets.some(function (requiredWidget) {
      return mountedWidgets.includes(requiredWidget);
    })) {
      acc.push([parameter, {
        connectors: stateToWidgetsMap[parameter].connectors,
        widgets: stateToWidgetsMap[parameter].widgets.map(function (widgetIdentifier) {
          return widgetIdentifier.split('ais.')[1];
        })
      }]);
    }

    return acc;
  }, []);
   false ? undefined : void 0;
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js
var getPropertyByPath = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getObjectType.js
var getObjectType = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js
var noop = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFiniteNumber.js
var isFiniteNumber = __webpack_require__(44);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js
var isPlainObject = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/range.js
var range = __webpack_require__(45);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js
var isEqual = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escape.js
var utils_escape = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescape.js
var utils_unescape = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js
var concatHighlightedParts = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js
var getHighlightedParts = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getHighlightFromSiblings.js
var getHighlightFromSiblings = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js
var reverseHighlightedParts = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/find.js
var find = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/findIndex.js
var findIndex = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js
var mergeSearchParameters = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/resolveSearchParameters.js
var resolveSearchParameters = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/toArray.js
var toArray = __webpack_require__(46);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/logger.js

/**
 * Logs a warning when this function is called, in development environment only.
 */

var deprecate = function deprecate(fn) {
  return fn;
};
/**
 * Logs a warning
 * This is used to log issues in development environment only.
 */


var warn = noop["a" /* default */];
/**
 * Logs a warning if the condition is not met.
 * This is used to log issues in development environment only.
 */

var _warning = noop["a" /* default */];

if (false) {}


// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js
var documentation = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/geo-search.js
var geo_search = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js
var hits_absolute_position = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js
var hits_query_id = __webpack_require__(41);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFacetRefined.js
var isFacetRefined = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForFacet.js
var createSendEventForFacet = __webpack_require__(38);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js
var createSendEventForHits = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/getAppIdAndApiKey.js
function getAppIdAndApiKey(searchClient) {
  if (searchClient.transporter) {
    // searchClient v4
    var _searchClient$transpo = searchClient.transporter,
        headers = _searchClient$transpo.headers,
        queryParameters = _searchClient$transpo.queryParameters;
    var APP_ID = 'x-algolia-application-id';
    var API_KEY = 'x-algolia-api-key';
    var appId = headers[APP_ID] || queryParameters[APP_ID];
    var apiKey = headers[API_KEY] || queryParameters[API_KEY];
    return [appId, apiKey];
  } else {
    // searchClient v3
    return [searchClient.applicationID, searchClient.apiKey];
  }
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/convertNumericRefinementsToFilters.js
var convertNumericRefinementsToFilters = __webpack_require__(43);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/utils/index.js











































/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TAG_PLACEHOLDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TAG_REPLACEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return escapeHits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return escapeFacets; });
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var TAG_PLACEHOLDER = {
  highlightPreTag: '__ais-highlight__',
  highlightPostTag: '__/ais-highlight__'
};
var TAG_REPLACEMENT = {
  highlightPreTag: '<mark>',
  highlightPostTag: '</mark>'
};

function replaceTagsAndEscape(value) {
  return Object(_lib_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value).replace(new RegExp(TAG_PLACEHOLDER.highlightPreTag, 'g'), TAG_REPLACEMENT.highlightPreTag).replace(new RegExp(TAG_PLACEHOLDER.highlightPostTag, 'g'), TAG_REPLACEMENT.highlightPostTag);
}

function recursiveEscape(input) {
  if (Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(input) && typeof input.value !== 'string') {
    return Object.keys(input).reduce(function (acc, key) {
      return _objectSpread({}, acc, _defineProperty({}, key, recursiveEscape(input[key])));
    }, {});
  }

  if (Array.isArray(input)) {
    return input.map(recursiveEscape);
  }

  return _objectSpread({}, input, {
    value: replaceTagsAndEscape(input.value)
  });
}

function escapeHits(hits) {
  if (hits.__escaped === undefined) {
    // We don't override the value on hit because it will mutate the raw results
    // instead we make a shallow copy and we assign the escaped values on it.
    hits = hits.map(function (_ref) {
      var hit = _extends({}, _ref);

      if (hit._highlightResult) {
        hit._highlightResult = recursiveEscape(hit._highlightResult);
      }

      if (hit._snippetResult) {
        hit._snippetResult = recursiveEscape(hit._snippetResult);
      }

      return hit;
    });
    hits.__escaped = true;
  }

  return hits;
}
function escapeFacets(facetHits) {
  return facetHits.map(function (h) {
    return _objectSpread({}, h, {
      highlighted: replaceTagsAndEscape(h.highlighted)
    });
  });
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("algoliasearch-helper");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@nuxt/ufo");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ addStylesServer; });

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}

// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesServer.js


function addStylesServer (parentId, list, isProduction, context) {
  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
    context = __VUE_SSR_CONTEXT__
  }
  if (context) {
    if (!context.hasOwnProperty('styles')) {
      Object.defineProperty(context, 'styles', {
        enumerable: true,
        get: function() {
          return renderStyles(context._styles)
        }
      })
      // expose renderStyles for vue-server-renderer (vuejs/#6353)
      context._renderStyles = renderStyles
    }

    var styles = context._styles || (context._styles = {})
    list = listToStyles(parentId, list)
    if (isProduction) {
      addStyleProd(styles, list)
    } else {
      addStyleDev(styles, list)
    }
  }
}

// In production, render as few style tags as possible.
// (mostly because IE9 has a limit on number of style tags)
function addStyleProd (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      // group style tags by media types.
      var id = part.media || 'default'
      var style = styles[id]
      if (style) {
        if (style.ids.indexOf(part.id) < 0) {
          style.ids.push(part.id)
          style.css += '\n' + part.css
        }
      } else {
        styles[id] = {
          ids: [part.id],
          css: part.css,
          media: part.media
        }
      }
    }
  }
}

// In dev we use individual style tag for each module for hot-reload
// and source maps.
function addStyleDev (styles, list) {
  for (var i = 0; i < list.length; i++) {
    var parts = list[i].parts
    for (var j = 0; j < parts.length; j++) {
      var part = parts[j]
      styles[part.id] = {
        ids: [part.id],
        css: part.css,
        media: part.media
      }
    }
  }
}

function renderStyles (styles) {
  var css = ''
  for (var key in styles) {
    var style = styles[key]
    css += '<style data-vue-ssr-id="' + style.ids.join(' ') + '"' +
        (style.media ? ( ' media="' + style.media + '"' ) : '') + '>' +
        style.css + '</style>'
  }
  return css
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function uniq(array) {
  return array.filter(function (value, index, self) {
    return self.indexOf(value) === index;
  });
}

/* harmony default export */ __webpack_exports__["a"] = (uniq);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function noop() {}

/* harmony default export */ __webpack_exports__["a"] = (noop);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// We aren't using the native `Array.prototype.find` because the refactor away from Lodash is not
// published as a major version.
// Relying on the `find` polyfill on user-land, which before was only required for niche use-cases,
// was decided as too risky.
// @MAJOR Replace with the native `Array.prototype.find` method
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
function find(items, predicate) {
  var value;

  for (var i = 0; i < items.length; i++) {
    value = items[i]; // inlined for performance: if (Call(predicate, thisArg, [value, i, list])) {

    if (predicate(value, i, items)) {
      return value;
    }
  }

  return undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (find);

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("vue-router");

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createDocumentationLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createDocumentationMessageGenerator; });
var createDocumentationLink = function createDocumentationLink(_ref) {
  var name = _ref.name,
      _ref$connector = _ref.connector,
      connector = _ref$connector === void 0 ? false : _ref$connector;
  return ['https://www.algolia.com/doc/api-reference/widgets/', name, '/js/', connector ? '#connector' : ''].join('');
};
var createDocumentationMessageGenerator = function createDocumentationMessageGenerator() {
  for (var _len = arguments.length, widgets = new Array(_len), _key = 0; _key < _len; _key++) {
    widgets[_key] = arguments[_key];
  }

  var links = widgets.map(function (widget) {
    return createDocumentationLink(widget);
  }).join(', ');
  return function (message) {
    return [message, "See documentation: ".concat(links)].filter(Boolean).join('\n\n');
  };
};

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function getObjectType(object) {
  return Object.prototype.toString.call(object).slice(8, -1);
}

/* harmony default export */ __webpack_exports__["a"] = (getObjectType);

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// We aren't using the native `Array.prototype.findIndex` because the refactor away from Lodash is not
// published as a major version.
// Relying on the `findIndex` polyfill on user-land, which before was only required for niche use-cases,
// was decided as too risky.
// @MAJOR Replace with the native `Array.prototype.findIndex` method
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
function findIndex(array, comparator) {
  if (!Array.isArray(array)) {
    return -1;
  }

  for (var i = 0; i < array.length; i++) {
    if (comparator(array[i])) {
      return i;
    }
  }

  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (findIndex);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function unescapeRefinement(value) {
  return String(value).replace(/^\\-/, '-');
}

/* harmony default export */ __webpack_exports__["a"] = (unescapeRefinement);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isFacetRefined; });
function isFacetRefined(helper, facet, value) {
  if (helper.state.isHierarchicalFacet(facet)) {
    return helper.state.isHierarchicalFacetRefined(facet, value);
  } else if (helper.state.isConjunctiveFacet(facet)) {
    return helper.state.isFacetRefined(facet, value);
  } else {
    return helper.state.isDisjunctiveFacetRefined(facet, value);
  }
}

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return unescape; });
/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/4.17.11-npm/unescape.js
 */
// Used to map HTML entities to characters.
var htmlEscapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
}; // Used to match HTML entities and HTML characters.

var regexEscapedHtml = /&(amp|quot|lt|gt|#39);/g;
var regexHasEscapedHtml = RegExp(regexEscapedHtml.source);
/**
 * Converts the HTML entities "&", "<", ">", '"', and "'" in `string` to their
 * characters.
 */

function unescape(value) {
  return value && regexHasEscapedHtml.test(value) ? value.replace(regexEscapedHtml, function (character) {
    return htmlEscapes[character];
  }) : value;
}

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getHighlightFromSiblings; });
/* harmony import */ var _unescape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);

var hasAlphanumeric = new RegExp(/\w/i);
function getHighlightFromSiblings(parts, i) {
  var _parts, _parts2;

  var current = parts[i];
  var isNextHighlighted = ((_parts = parts[i + 1]) === null || _parts === void 0 ? void 0 : _parts.isHighlighted) || true;
  var isPreviousHighlighted = ((_parts2 = parts[i - 1]) === null || _parts2 === void 0 ? void 0 : _parts2.isHighlighted) || true;

  if (!hasAlphanumeric.test(Object(_unescape__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(current.value)) && isPreviousHighlighted === isNextHighlighted) {
    return isPreviousHighlighted;
  }

  return current.isHighlighted;
}

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIndexWidget", function() { return isIndexWidget; });
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}



var withUsage = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_1__[/* createDocumentationMessageGenerator */ "b"])({
  name: 'index-widget'
});
function isIndexWidget(widget) {
  return widget.$$type === 'ais.index';
}
/**
 * This is the same content as helper._change / setState, but allowing for extra
 * UiState to be synchronized.
 * see: https://github.com/algolia/algoliasearch-helper-js/blob/6b835ffd07742f2d6b314022cce6848f5cfecd4a/src/algoliasearch.helper.js#L1311-L1324
 */

function privateHelperSetState(helper, _ref) {
  var state = _ref.state,
      isPageReset = _ref.isPageReset,
      _uiState = _ref._uiState;

  if (state !== helper.state) {
    helper.state = state;
    helper.emit('change', {
      state: helper.state,
      results: helper.lastResults,
      isPageReset: isPageReset,
      _uiState: _uiState
    });
  }
}

function getLocalWidgetsUiState(widgets, widgetStateOptions) {
  var initialUiState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return widgets.filter(function (widget) {
    return !isIndexWidget(widget);
  }).reduce(function (uiState, widget) {
    if (!widget.getWidgetUiState && !widget.getWidgetState) {
      return uiState;
    }

    if (widget.getWidgetUiState) {
      return widget.getWidgetUiState(uiState, widgetStateOptions);
    }

    return widget.getWidgetState(uiState, widgetStateOptions);
  }, initialUiState);
}

function getLocalWidgetsSearchParameters(widgets, widgetSearchParametersOptions) {
  var initialSearchParameters = widgetSearchParametersOptions.initialSearchParameters,
      rest = _objectWithoutProperties(widgetSearchParametersOptions, ["initialSearchParameters"]);

  return widgets.filter(function (widget) {
    return !isIndexWidget(widget);
  }).reduce(function (state, widget) {
    if (!widget.getWidgetSearchParameters) {
      return state;
    }

    return widget.getWidgetSearchParameters(state, rest);
  }, initialSearchParameters);
}

function resetPageFromWidgets(widgets) {
  var indexWidgets = widgets.filter(isIndexWidget);

  if (indexWidgets.length === 0) {
    return;
  }

  indexWidgets.forEach(function (widget) {
    var widgetHelper = widget.getHelper();
    privateHelperSetState(widgetHelper, {
      state: widgetHelper.state.resetPage(),
      isPageReset: true
    });
    resetPageFromWidgets(widget.getWidgets());
  });
}

function resolveScopedResultsFromWidgets(widgets) {
  var indexWidgets = widgets.filter(isIndexWidget);
  return indexWidgets.reduce(function (scopedResults, current) {
    return scopedResults.concat.apply(scopedResults, [{
      indexId: current.getIndexId(),
      results: current.getResults(),
      helper: current.getHelper()
    }].concat(_toConsumableArray(resolveScopedResultsFromWidgets(current.getWidgets()))));
  }, []);
}

var index = function index(props) {
  if (props === undefined || props.indexName === undefined) {
    throw new Error(withUsage('The `indexName` option is required.'));
  }

  var indexName = props.indexName,
      _props$indexId = props.indexId,
      indexId = _props$indexId === void 0 ? indexName : _props$indexId;
  var localWidgets = [];
  var localUiState = {};
  var localInstantSearchInstance = null;
  var localParent = null;
  var helper = null;
  var derivedHelper = null;
  return {
    $$type: 'ais.index',
    getIndexName: function getIndexName() {
      return indexName;
    },
    getIndexId: function getIndexId() {
      return indexId;
    },
    getHelper: function getHelper() {
      return helper;
    },
    getResults: function getResults() {
      return derivedHelper && derivedHelper.lastResults;
    },
    getScopedResults: function getScopedResults() {
      var widgetParent = this.getParent(); // If the widget is the root, we consider itself as the only sibling.

      var widgetSiblings = widgetParent ? widgetParent.getWidgets() : [this];
      return resolveScopedResultsFromWidgets(widgetSiblings);
    },
    getParent: function getParent() {
      return localParent;
    },
    createURL: function createURL(nextState) {
      return localInstantSearchInstance._createURL(_defineProperty({}, indexId, getLocalWidgetsUiState(localWidgets, {
        searchParameters: nextState,
        helper: helper
      })));
    },
    getWidgets: function getWidgets() {
      return localWidgets;
    },
    addWidgets: function addWidgets(widgets) {
      var _this = this;

      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `addWidgets` method expects an array of widgets.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.init !== 'function' && typeof widget.render !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));
      }

      localWidgets = localWidgets.concat(widgets);

      if (localInstantSearchInstance && Boolean(widgets.length)) {
        privateHelperSetState(helper, {
          state: getLocalWidgetsSearchParameters(localWidgets, {
            uiState: localUiState,
            initialSearchParameters: helper.state
          }),
          _uiState: localUiState
        }); // We compute the render state before calling `init` in a separate loop
        // to construct the whole render state object that is then passed to
        // `init`.

        widgets.forEach(function (widget) {
          if (widget.getRenderState) {
            var renderState = widget.getRenderState(localInstantSearchInstance.renderState[_this.getIndexId()] || {}, {
              uiState: localInstantSearchInstance._initialUiState,
              helper: _this.getHelper(),
              parent: _this,
              instantSearchInstance: localInstantSearchInstance,
              state: helper.state,
              renderState: localInstantSearchInstance.renderState,
              templatesConfig: localInstantSearchInstance.templatesConfig,
              createURL: _this.createURL,
              scopedResults: [],
              searchMetadata: {
                isSearchStalled: localInstantSearchInstance._isSearchStalled
              }
            });
            storeRenderState({
              renderState: renderState,
              instantSearchInstance: localInstantSearchInstance,
              parent: _this
            });
          }
        });
        widgets.forEach(function (widget) {
          if (widget.init) {
            widget.init({
              helper: helper,
              parent: _this,
              uiState: localInstantSearchInstance._initialUiState,
              instantSearchInstance: localInstantSearchInstance,
              state: helper.state,
              renderState: localInstantSearchInstance.renderState,
              templatesConfig: localInstantSearchInstance.templatesConfig,
              createURL: _this.createURL,
              scopedResults: [],
              searchMetadata: {
                isSearchStalled: localInstantSearchInstance._isSearchStalled
              }
            });
          }
        });
        localInstantSearchInstance.scheduleSearch();
      }

      return this;
    },
    removeWidgets: function removeWidgets(widgets) {
      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.dispose !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `dispose` method.'));
      }

      localWidgets = localWidgets.filter(function (widget) {
        return widgets.indexOf(widget) === -1;
      });

      if (localInstantSearchInstance && Boolean(widgets.length)) {
        var nextState = widgets.reduce(function (state, widget) {
          // the `dispose` method exists at this point we already assert it
          var next = widget.dispose({
            helper: helper,
            state: state
          });
          return next || state;
        }, helper.state);
        localUiState = getLocalWidgetsUiState(localWidgets, {
          searchParameters: nextState,
          helper: helper
        });
        helper.setState(getLocalWidgetsSearchParameters(localWidgets, {
          uiState: localUiState,
          initialSearchParameters: nextState
        }));

        if (localWidgets.length) {
          localInstantSearchInstance.scheduleSearch();
        }
      }

      return this;
    },
    init: function init(_ref2) {
      var _this2 = this;

      var instantSearchInstance = _ref2.instantSearchInstance,
          parent = _ref2.parent,
          uiState = _ref2.uiState;
      localInstantSearchInstance = instantSearchInstance;
      localParent = parent;
      localUiState = uiState[indexId] || {}; // The `mainHelper` is already defined at this point. The instance is created
      // inside InstantSearch at the `start` method, which occurs before the `init`
      // step.

      var mainHelper = instantSearchInstance.mainHelper;
      var parameters = getLocalWidgetsSearchParameters(localWidgets, {
        uiState: localUiState,
        initialSearchParameters: new algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default.a.SearchParameters({
          index: indexName
        })
      }); // This Helper is only used for state management we do not care about the
      // `searchClient`. Only the "main" Helper created at the `InstantSearch`
      // level is aware of the client.

      helper = algoliasearch_helper__WEBPACK_IMPORTED_MODULE_0___default()({}, parameters.index, parameters); // We forward the call to `search` to the "main" instance of the Helper
      // which is responsible for managing the queries (it's the only one that is
      // aware of the `searchClient`).

      helper.search = function () {
        if (instantSearchInstance.onStateChange) {
          instantSearchInstance.onStateChange({
            uiState: instantSearchInstance.mainIndex.getWidgetUiState({}),
            setUiState: instantSearchInstance.setUiState.bind(instantSearchInstance)
          }); // We don't trigger a search when controlled because it becomes the
          // responsibility of `setUiState`.

          return mainHelper;
        }

        return mainHelper.search();
      };

      helper.searchWithoutTriggeringOnStateChange = function () {
        return mainHelper.search();
      }; // We use the same pattern for the `searchForFacetValues`.


      helper.searchForFacetValues = function (facetName, facetValue, maxFacetHits, userState) {
        var state = helper.state.setQueryParameters(userState);
        return mainHelper.searchForFacetValues(facetName, facetValue, maxFacetHits, state);
      };

      derivedHelper = mainHelper.derive(function () {
        return _lib_utils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].apply(void 0, _toConsumableArray(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(_this2)));
      }); // Subscribe to the Helper state changes for the page before widgets
      // are initialized. This behavior mimics the original one of the Helper.
      // It makes sense to replicate it at the `init` step. We have another
      // listener on `change` below, once `init` is done.

      helper.on('change', function (_ref3) {
        var isPageReset = _ref3.isPageReset;

        if (isPageReset) {
          resetPageFromWidgets(localWidgets);
        }
      });
      derivedHelper.on('search', function () {
        // The index does not manage the "staleness" of the search. This is the
        // responsibility of the main instance. It does not make sense to manage
        // it at the index level because it's either: all of them or none of them
        // that are stalled. The queries are performed into a single network request.
        instantSearchInstance.scheduleStalledRender();

        if (false) {}
      });
      derivedHelper.on('result', function (_ref4) {
        var results = _ref4.results; // The index does not render the results it schedules a new render
        // to let all the other indices emit their own results. It allows us to
        // run the render process in one pass.

        instantSearchInstance.scheduleRender(); // the derived helper is the one which actually searches, but the helper
        // which is exposed e.g. via instance.helper, doesn't search, and thus
        // does not have access to lastResults, which it used to in pre-federated
        // search behavior.

        helper.lastResults = results;
      }); // We compute the render state before calling `render` in a separate loop
      // to construct the whole render state object that is then passed to
      // `render`.

      localWidgets.forEach(function (widget) {
        if (widget.getRenderState) {
          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this2.getIndexId()] || {}, {
            uiState: uiState,
            helper: helper,
            parent: _this2,
            instantSearchInstance: instantSearchInstance,
            state: helper.state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this2.createURL,
            scopedResults: [],
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
          storeRenderState({
            renderState: renderState,
            instantSearchInstance: instantSearchInstance,
            parent: _this2
          });
        }
      });
      localWidgets.forEach(function (widget) {
         false ? undefined : void 0;

        if (widget.init) {
          widget.init({
            uiState: uiState,
            helper: helper,
            parent: _this2,
            instantSearchInstance: instantSearchInstance,
            state: helper.state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this2.createURL,
            scopedResults: [],
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
        }
      }); // Subscribe to the Helper state changes for the `uiState` once widgets
      // are initialized. Until the first render, state changes are part of the
      // configuration step. This is mainly for backward compatibility with custom
      // widgets. When the subscription happens before the `init` step, the (static)
      // configuration of the widget is pushed in the URL. That's what we want to avoid.
      // https://github.com/algolia/instantsearch.js/pull/994/commits/4a672ae3fd78809e213de0368549ef12e9dc9454

      helper.on('change', function (event) {
        var state = event.state; // @ts-ignore _uiState comes from privateHelperSetState and thus isn't typed on the helper event

        var _uiState = event._uiState;
        localUiState = getLocalWidgetsUiState(localWidgets, {
          searchParameters: state,
          helper: helper
        }, _uiState || {}); // We don't trigger an internal change when controlled because it
        // becomes the responsibility of `setUiState`.

        if (!instantSearchInstance.onStateChange) {
          instantSearchInstance.onInternalStateChange();
        }
      });
    },
    render: function render(_ref5) {
      var _this3 = this;

      var instantSearchInstance = _ref5.instantSearchInstance;

      if (!this.getResults()) {
        return;
      }

      localWidgets.forEach(function (widget) {
        if (widget.getRenderState) {
          var renderState = widget.getRenderState(instantSearchInstance.renderState[_this3.getIndexId()] || {}, {
            helper: _this3.getHelper(),
            parent: _this3,
            instantSearchInstance: instantSearchInstance,
            results: _this3.getResults(),
            scopedResults: _this3.getScopedResults(),
            state: _this3.getResults()._state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this3.createURL,
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
          storeRenderState({
            renderState: renderState,
            instantSearchInstance: instantSearchInstance,
            parent: _this3
          });
        }
      });
      localWidgets.forEach(function (widget) {
        // At this point, all the variables used below are set. Both `helper`
        // and `derivedHelper` have been created at the `init` step. The attribute
        // `lastResults` might be `null` though. It's possible that a stalled render
        // happens before the result e.g with a dynamically added index the request might
        // be delayed. The render is triggered for the complete tree but some parts do
        // not have results yet.
        if (widget.render) {
          widget.render({
            helper: helper,
            parent: _this3,
            instantSearchInstance: instantSearchInstance,
            results: _this3.getResults(),
            scopedResults: _this3.getScopedResults(),
            state: _this3.getResults()._state,
            renderState: instantSearchInstance.renderState,
            templatesConfig: instantSearchInstance.templatesConfig,
            createURL: _this3.createURL,
            searchMetadata: {
              isSearchStalled: instantSearchInstance._isSearchStalled
            }
          });
        }
      });
    },
    dispose: function dispose() {
      localWidgets.forEach(function (widget) {
        if (widget.dispose) {
          // The dispose function is always called once the instance is started
          // (it's an effect of `removeWidgets`). The index is initialized and
          // the Helper is available. We don't care about the return value of
          // `dispose` because the index is removed. We can't call `removeWidgets`
          // because we want to keep the widgets on the instance, to allow idempotent
          // operations on `add` & `remove`.
          widget.dispose({
            helper: helper,
            state: helper.state
          });
        }
      });
      localInstantSearchInstance = null;
      localParent = null;
      helper.removeAllListeners();
      helper = null;
      derivedHelper.detach();
      derivedHelper = null;
    },
    getWidgetUiState: function getWidgetUiState(uiState) {
      return localWidgets.filter(isIndexWidget).reduce(function (previousUiState, innerIndex) {
        return innerIndex.getWidgetUiState(previousUiState);
      }, _objectSpread({}, uiState, _defineProperty({}, this.getIndexId(), localUiState)));
    },
    getWidgetState: function getWidgetState(uiState) {
       false ? undefined : void 0;
      return this.getWidgetUiState(uiState);
    },
    getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
      var uiState = _ref6.uiState;
      return getLocalWidgetsSearchParameters(localWidgets, {
        uiState: uiState,
        initialSearchParameters: searchParameters
      });
    },
    refreshUiState: function refreshUiState() {
      localUiState = getLocalWidgetsUiState(localWidgets, {
        searchParameters: this.getHelper().state,
        helper: this.getHelper()
      });
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (index);

function storeRenderState(_ref7) {
  var renderState = _ref7.renderState,
      instantSearchInstance = _ref7.instantSearchInstance,
      parent = _ref7.parent;
  var parentIndexName = parent ? parent.getIndexId() : instantSearchInstance.mainIndex.getIndexId();
  instantSearchInstance.renderState = _objectSpread({}, instantSearchInstance.renderState, _defineProperty({}, parentIndexName, _objectSpread({}, instantSearchInstance.renderState[parentIndexName], {}, renderState)));
}

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("vue-no-ssr");

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return aroundLatLngToPosition; });
/* unused harmony export insideBoundingBoxArrayToBoundingBox */
/* unused harmony export insideBoundingBoxStringToBoundingBox */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return insideBoundingBoxToBoundingBox; });
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var latLngRegExp = /^(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)$/;
function aroundLatLngToPosition(value) {
  var pattern = value.match(latLngRegExp); // Since the value provided is the one send with the request, the API should
  // throw an error due to the wrong format. So throw an error should be safe.

  if (!pattern) {
    throw new Error("Invalid value for \"aroundLatLng\" parameter: \"".concat(value, "\""));
  }

  return {
    lat: parseFloat(pattern[1]),
    lng: parseFloat(pattern[2])
  };
}
function insideBoundingBoxArrayToBoundingBox(value) {
  var _value = _slicedToArray(value, 1),
      _value$ = _value[0];

  _value$ = _value$ === void 0 ? [undefined, undefined, undefined, undefined] : _value$;

  var _value$2 = _slicedToArray(_value$, 4),
      neLat = _value$2[0],
      neLng = _value$2[1],
      swLat = _value$2[2],
      swLng = _value$2[3]; // Since the value provided is the one send with the request, the API should
  // throw an error due to the wrong format. So throw an error should be safe.


  if (!neLat || !neLng || !swLat || !swLng) {
    throw new Error("Invalid value for \"insideBoundingBox\" parameter: [".concat(value, "]"));
  }

  return {
    northEast: {
      lat: neLat,
      lng: neLng
    },
    southWest: {
      lat: swLat,
      lng: swLng
    }
  };
}
function insideBoundingBoxStringToBoundingBox(value) {
  var _value$split$map = value.split(',').map(parseFloat),
      _value$split$map2 = _slicedToArray(_value$split$map, 4),
      neLat = _value$split$map2[0],
      neLng = _value$split$map2[1],
      swLat = _value$split$map2[2],
      swLng = _value$split$map2[3]; // Since the value provided is the one send with the request, the API should
  // throw an error due to the wrong format. So throw an error should be safe.


  if (!neLat || !neLng || !swLat || !swLng) {
    throw new Error("Invalid value for \"insideBoundingBox\" parameter: \"".concat(value, "\""));
  }

  return {
    northEast: {
      lat: neLat,
      lng: neLng
    },
    southWest: {
      lat: swLat,
      lng: swLng
    }
  };
}
function insideBoundingBoxToBoundingBox(value) {
  if (Array.isArray(value)) {
    return insideBoundingBoxArrayToBoundingBox(value);
  }

  return insideBoundingBoxStringToBoundingBox(value);
}

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _findIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _uniq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}




var mergeWithRest = function mergeWithRest(left, right) {
  var facets = right.facets,
      disjunctiveFacets = right.disjunctiveFacets,
      facetsRefinements = right.facetsRefinements,
      facetsExcludes = right.facetsExcludes,
      disjunctiveFacetsRefinements = right.disjunctiveFacetsRefinements,
      numericRefinements = right.numericRefinements,
      tagRefinements = right.tagRefinements,
      hierarchicalFacets = right.hierarchicalFacets,
      hierarchicalFacetsRefinements = right.hierarchicalFacetsRefinements,
      ruleContexts = right.ruleContexts,
      rest = _objectWithoutProperties(right, ["facets", "disjunctiveFacets", "facetsRefinements", "facetsExcludes", "disjunctiveFacetsRefinements", "numericRefinements", "tagRefinements", "hierarchicalFacets", "hierarchicalFacetsRefinements", "ruleContexts"]);

  return left.setQueryParameters(rest);
}; // Merge facets


var mergeFacets = function mergeFacets(left, right) {
  return right.facets.reduce(function (_, name) {
    return _.addFacet(name);
  }, left);
};

var mergeDisjunctiveFacets = function mergeDisjunctiveFacets(left, right) {
  return right.disjunctiveFacets.reduce(function (_, name) {
    return _.addDisjunctiveFacet(name);
  }, left);
};

var mergeHierarchicalFacets = function mergeHierarchicalFacets(left, right) {
  return left.setQueryParameters({
    hierarchicalFacets: right.hierarchicalFacets.reduce(function (facets, facet) {
      var index = Object(_findIndex__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(facets, function (_) {
        return _.name === facet.name;
      });

      if (index === -1) {
        return facets.concat(facet);
      }

      var nextFacets = facets.slice();
      nextFacets.splice(index, 1, facet);
      return nextFacets;
    }, left.hierarchicalFacets)
  });
}; // Merge facet refinements


var mergeTagRefinements = function mergeTagRefinements(left, right) {
  return right.tagRefinements.reduce(function (_, value) {
    return _.addTagRefinement(value);
  }, left);
};

var mergeFacetRefinements = function mergeFacetRefinements(left, right) {
  return left.setQueryParameters({
    facetsRefinements: _objectSpread({}, left.facetsRefinements, {}, right.facetsRefinements)
  });
};

var mergeFacetsExcludes = function mergeFacetsExcludes(left, right) {
  return left.setQueryParameters({
    facetsExcludes: _objectSpread({}, left.facetsExcludes, {}, right.facetsExcludes)
  });
};

var mergeDisjunctiveFacetsRefinements = function mergeDisjunctiveFacetsRefinements(left, right) {
  return left.setQueryParameters({
    disjunctiveFacetsRefinements: _objectSpread({}, left.disjunctiveFacetsRefinements, {}, right.disjunctiveFacetsRefinements)
  });
};

var mergeNumericRefinements = function mergeNumericRefinements(left, right) {
  return left.setQueryParameters({
    numericRefinements: _objectSpread({}, left.numericRefinements, {}, right.numericRefinements)
  });
};

var mergeHierarchicalFacetsRefinements = function mergeHierarchicalFacetsRefinements(left, right) {
  return left.setQueryParameters({
    hierarchicalFacetsRefinements: _objectSpread({}, left.hierarchicalFacetsRefinements, {}, right.hierarchicalFacetsRefinements)
  });
};

var mergeRuleContexts = function mergeRuleContexts(left, right) {
  var ruleContexts = Object(_uniq__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])([].concat(left.ruleContexts).concat(right.ruleContexts).filter(Boolean));

  if (ruleContexts.length > 0) {
    return left.setQueryParameters({
      ruleContexts: ruleContexts
    });
  }

  return left;
};

var merge = function merge() {
  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {
    parameters[_key] = arguments[_key];
  }

  return parameters.reduce(function (left, right) {
    var hierarchicalFacetsRefinementsMerged = mergeHierarchicalFacetsRefinements(left, right);
    var hierarchicalFacetsMerged = mergeHierarchicalFacets(hierarchicalFacetsRefinementsMerged, right);
    var tagRefinementsMerged = mergeTagRefinements(hierarchicalFacetsMerged, right);
    var numericRefinementsMerged = mergeNumericRefinements(tagRefinementsMerged, right);
    var disjunctiveFacetsRefinementsMerged = mergeDisjunctiveFacetsRefinements(numericRefinementsMerged, right);
    var facetsExcludesMerged = mergeFacetsExcludes(disjunctiveFacetsRefinementsMerged, right);
    var facetRefinementsMerged = mergeFacetRefinements(facetsExcludesMerged, right);
    var disjunctiveFacetsMerged = mergeDisjunctiveFacets(facetRefinementsMerged, right);
    var ruleContextsMerged = mergeRuleContexts(disjunctiveFacetsMerged, right);
    var facetsMerged = mergeFacets(ruleContextsMerged, right);
    return mergeWithRest(facetsMerged, right);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (merge);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/4.17.11-npm/escape.js
 */
// Used to map characters to HTML entities.
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
}; // Used to match HTML entities and HTML characters.

var regexUnescapedHtml = /[&<>"']/g;
var regexHasUnescapedHtml = RegExp(regexUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 */

function escape(value) {
  return value && regexHasUnescapedHtml.test(value) ? value.replace(regexUnescapedHtml, function (character) {
    return htmlEscapes[character];
  }) : value;
}

/* harmony default export */ __webpack_exports__["a"] = (escape);

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
/**
 * This implementation is taken from Lodash implementation.
 * See: https://github.com/lodash/lodash/blob/master/isPlainObject.js
 */


function getTag(value) {
  if (value === null) {
    return value === undefined ? '[object Undefined]' : '[object Null]';
  }

  return Object.prototype.toString.call(value);
}

function isObjectLike(value) {
  return _typeof(value) === 'object' && value !== null;
}
/**
 * Checks if `value` is a plain object.
 *
 * A plain object is an object created by the `Object`
 * constructor or with a `[[Prototype]]` of `null`.
 */


function isPlainObject(value) {
  if (!isObjectLike(value) || getTag(value) !== '[object Object]') {
    return false;
  }

  if (Object.getPrototypeOf(value) === null) {
    return true;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var resolveSearchParameters = function resolveSearchParameters(current) {
  var parent = current.getParent();
  var states = [current.getHelper().state];

  while (parent !== null) {
    states = [parent.getHelper().state].concat(states);
    parent = parent.getParent();
  }

  return states;
};

/* harmony default export */ __webpack_exports__["a"] = (resolveSearchParameters);

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/MainHeader.vue?vue&type=template&id=1c7881d2&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"z-10 flex flex-shrink-0 h-16 w-full max-w-6xl items-center justify-between bg-white sm:px-3"},[_vm._ssrNode("<button class=\"md:hidden items-center px-4\"><svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\" class=\"h-6 w-6\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 6h16M4 12h16M4 18h16\"></path></svg></button> "),_vm._ssrNode("<div class=\"hidden md:flex px-4\">","</div>",[_c('nuxt-link',{staticClass:"md:text-2xl font-extrabold tracking-tight sm:text-xl text-gray-800",attrs:{"to":"/"}},[_vm._v("\n      Adonis Guru\n    ")])],1)],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/layout/MainHeader.vue?vue&type=template&id=1c7881d2&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/icons/GlobeIcon.vue?vue&type=template&id=9ba3eb14&
var GlobeIconvue_type_template_id_9ba3eb14_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('svg',{attrs:{"xmlns":"http://www.w3.org/2000/svg","fill":"none","viewBox":"0 0 24 24","stroke":"currentColor"}},[_vm._ssrNode("<path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9\"></path>")])}
var GlobeIconvue_type_template_id_9ba3eb14_staticRenderFns = []


// CONCATENATED MODULE: ./components/icons/GlobeIcon.vue?vue&type=template&id=9ba3eb14&

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(3);

// CONCATENATED MODULE: ./components/icons/GlobeIcon.vue

var script = {}


/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  script,
  GlobeIconvue_type_template_id_9ba3eb14_render,
  GlobeIconvue_type_template_id_9ba3eb14_staticRenderFns,
  false,
  null,
  null,
  "aa285ec4"
  
)

/* harmony default export */ var GlobeIcon = (component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/MainHeader.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var MainHeadervue_type_script_lang_js_ = ({
  components: {
    GlobeIcon: GlobeIcon
  },
  methods: {
    showMobileMenu() {
      this.$emit('showMobileMenu'); // closes the mobile menu if in open state and when route changes
    }

  }
});
// CONCATENATED MODULE: ./components/layout/MainHeader.vue?vue&type=script&lang=js&
 /* harmony default export */ var layout_MainHeadervue_type_script_lang_js_ = (MainHeadervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./components/layout/MainHeader.vue





/* normalize component */

var MainHeader_component = Object(componentNormalizer["a" /* default */])(
  layout_MainHeadervue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  "b93efe10"
  
)

/* harmony default export */ var MainHeader = __webpack_exports__["default"] = (MainHeader_component.exports);

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/MainFooter.vue?vue&type=template&id=63408bad&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('footer',{staticClass:"bg-white mt-12"},[_vm._ssrNode("<div class=\"mx-auto py-12 px-4 sm:px-6 md:flex md:items-center md:justify-between lg:px-6\"><div class=\"flex justify-center space-x-6 md:order-2\"><a href=\"https://cleavr.io\" target=\"_blank\" style=\"background-color: #0058F3; color: white; display: inline-flex; align-items: center; padding: 5px 15px 5px 6px; border-radius: 5px; font-family: Helvetica, Arial, sans-serif; font-size: 15px\"><svg width=\"15px\" height=\"15px\" viewBox=\"0 0 506 393\" style=\"margin: 0 6px 2px\"><g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"><g id=\"cleaver_logo\" transform=\"translate(-184.000000, -214.000000)\"><g id=\"logo_cleaver-copy\" transform=\"translate(184.000000, 214.000000)\"><g id=\"Group\" transform=\"translate(0.232002, 0.677165)\"><circle id=\"Oval\" cx=\"356.201069\" cy=\"41.4992126\" r=\"12.9259843\"></circle> <path id=\"Shape\" d=\"M465.051462,86.7401575 C428.314454,59.5275591 391.917604,32.3149606 359.602643,0 C290.890832,68.711811 222.179021,137.423622 153.46721,206.135433 C185.782171,238.450394 213.334927,275.527559 240.887683,312.604724 C328.648313,251.716535 427.974297,132.661417 465.051462,86.7401575 Z M347.016817,50.6834646 C341.914454,45.5811024 341.914454,37.4173228 347.016817,32.3149606 C352.119179,27.2125984 360.282958,27.2125984 365.385321,32.3149606 C370.487683,37.4173228 370.487683,45.5811024 365.385321,50.6834646 C360.282958,55.4456693 352.119179,55.4456693 347.016817,50.6834646 Z\" fill=\"#E7E8E9\" fill-rule=\"nonzero\"></path> <g id=\"Shape\" transform=\"translate(240.000000, 86.000000)\" fill-rule=\"nonzero\"><g id=\"path-4-link\" fill=\"#000000\"><path id=\"path-4\" d=\"M255.325478,73.193701 C269.271935,56.525984 268.251462,33.055118 253.284533,21.829921 C243.760124,14.686614 234.575872,7.5433071 225.051462,0.7401575 C187.974297,47.001575 88.648313,165.716535 0.887683,226.604724 C7.690832,235.788976 4.289258,230.006299 11.092407,239.190551 C22.317604,254.15748 45.78847,254.837795 62.456187,240.891339 C128.10658,185.105512 199.539651,139.184252 255.325478,73.193701 Z\"></path></g> <g id=\"path-4-link\" fill=\"#FFFFFF\"><path id=\"path-4\" d=\"M255.325478,73.193701 C269.271935,56.525984 268.251462,33.055118 253.284533,21.829921 C243.760124,14.686614 234.575872,7.5433071 225.051462,0.7401575 C187.974297,47.001575 88.648313,165.716535 0.887683,226.604724 C7.690832,235.788976 4.289258,230.006299 11.092407,239.190551 C22.317604,254.15748 45.78847,254.837795 62.456187,240.891339 C128.10658,185.105512 199.539651,139.184252 255.325478,73.193701 Z\"></path></g></g> <polygon id=\"Rectangle-path\" fill=\"#E7E8E9\" fill-rule=\"nonzero\" transform=\"translate(172.330405, 219.931744) rotate(45.000000) translate(-172.330405, -219.931744) \" points=\"149.369996 185.746245 195.290815 185.746245 195.290815 254.117243 149.369996 254.117243\"></polygon> <g id=\"Shape\" transform=\"translate(0.000000, 202.000000)\" fill-rule=\"nonzero\"><g id=\"path-6-link\" fill=\"#000000\"><path id=\"path-6\" d=\"M38.493982,188.16063 L2.09713161,151.76378 C-0.283970754,149.382677 -0.283970754,145.981102 2.09713161,143.6 L143.262486,2.434646 C145.643588,0.053543 149.045163,0.053543 151.426265,2.434646 L187.823116,38.831496 C190.204218,41.212598 190.204218,44.614173 187.823116,46.995276 L46.6577615,188.16063 C44.2766592,190.541732 40.5349269,190.541732 38.493982,188.16063 Z\"></path></g> <g id=\"path-6-link\" fill=\"#2B2B2B\"><path id=\"path-6\" d=\"M38.493982,188.16063 L2.09713161,151.76378 C-0.283970754,149.382677 -0.283970754,145.981102 2.09713161,143.6 L143.262486,2.434646 C145.643588,0.053543 149.045163,0.053543 151.426265,2.434646 L187.823116,38.831496 C190.204218,41.212598 190.204218,44.614173 187.823116,46.995276 L46.6577615,188.16063 C44.2766592,190.541732 40.5349269,190.541732 38.493982,188.16063 Z\"></path></g></g></g></g></g></g></svg> <span style=\"margin-left:5px; letter-spacing: 0.05em;\">Powered by Cleavr</span></a></div> <div class=\"mt-8 md:mt-0 md:order-1\"><p class=\"text-center text-base text-gray-700\">\n        © 2021 Little Bets, LLC. All rights reserved.\n      </p></div></div>")])}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/layout/MainFooter.vue?vue&type=template&id=63408bad&

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(3);

// CONCATENATED MODULE: ./components/layout/MainFooter.vue

var script = {}


/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  script,
  render,
  staticRenderFns,
  false,
  null,
  null,
  "fba3c5f4"
  
)

/* harmony default export */ var MainFooter = __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("vue-client-only");

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const info = __webpack_require__(75);

const rootKeys = ['class-name', 'class', 'style'];

function propsToData(props, doc) {
  return Object.keys(props).reduce(function (data, key) {
    const k = key.replace(/.*:/, '');
    let obj = rootKeys.includes(k) ? data : data.attrs;
    const value = props[key];
    const {
      attribute
    } = info.find(info.html, key);

    if (key === 'v-bind') {
      let val = doc[value];

      if (!val) {
        val = eval(`(${value})`);
      }

      obj = Object.assign(obj, val);
    } else if (key.indexOf(':') === 0 || key.indexOf('v-bind:') === 0) {
      key = key.replace('v-bind:', '').replace(':', '');

      if (doc[value]) {
        obj[key] = doc[value];
      } else {
        obj[key] = eval(`(${value})`);
      }
    } else if (Array.isArray(value)) {
      obj[attribute] = value.join(' ');
    } else {
      obj[attribute] = value;
    }

    return data;
  }, {
    attrs: {}
  });
}
/**
 * Create the scoped slots from `node` template children. Templates for default
 * slots are processed as regular children in `processNode`.
 */


function slotsToData(node, h, doc) {
  const data = {};
  const children = node.children || [];
  children.forEach(child => {
    // Regular children and default templates are processed inside `processNode`.
    if (!isTemplate(child) || isDefaultTemplate(child)) {
      return;
    } // Non-default templates are converted into slots.


    data.scopedSlots = data.scopedSlots || {};
    const template = child;
    const name = getSlotName(template);
    const vDomTree = template.content.map(tmplNode => processNode(tmplNode, h, doc));

    data.scopedSlots[name] = function () {
      return vDomTree;
    };
  });
  return data;
}

function processNode(node, h, doc) {
  /**
   * Return raw value as it is
   */
  if (node.type === 'text') {
    return node.value;
  }

  const slotData = slotsToData(node || {}, h, doc);
  const propData = propsToData(node.props, doc);
  const data = Object.assign({}, slotData, propData);
  /**
   * Process child nodes, flat-mapping templates pointing to default slots.
   */

  const children = [];

  for (const child of node.children) {
    // Template nodes pointing to non-default slots are processed inside `slotsToData`.
    if (isTemplate(child) && !isDefaultTemplate(child)) {
      continue;
    }

    const processQueue = isDefaultTemplate(child) ? child.content : [child];
    children.push(...processQueue.map(node => processNode(node, h, doc)));
  }

  return h(node.tag, data, children);
}

const DEFAULT_SLOT = 'default';

function isDefaultTemplate(node) {
  return isTemplate(node) && getSlotName(node) === DEFAULT_SLOT;
}

function isTemplate(node) {
  return node.tag === 'template';
}

function getSlotName(node) {
  let name = '';

  for (const propName of Object.keys(node.props)) {
    if (!propName.startsWith('#') && !propName.startsWith('v-slot:')) {
      continue;
    }

    name = propName.split(/[:#]/, 2)[1];
    break;
  }

  return name || DEFAULT_SLOT;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  name: 'NuxtContent',
  functional: true,
  props: {
    document: {
      required: true
    }
  },

  render(h, {
    data,
    props
  }) {
    const {
      document
    } = props;
    const {
      body
    } = document || {};

    if (!body || !body.children || !Array.isArray(body.children)) {
      return;
    }

    let classes = [];

    if (Array.isArray(data.class)) {
      classes = data.class;
    } else if (typeof data.class === 'object') {
      const keys = Object.keys(data.class);
      classes = keys.filter(key => data.class[key]);
    } else {
      classes = [data.class];
    }

    data.class = classes.concat('nuxt-content');
    data.props = Object.assign({ ...body.props
    }, data.props);
    return h('div', data, body.children.map(child => processNode(child, h, document)));
  }

});

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("hogan.js");

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("qs");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(63);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(7).default
module.exports.__inject__ = function (context) {
  add("4a1cbb1a", content, true, context)
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(65);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(7).default
module.exports.__inject__ = function (context) {
  add("fa7ff0ca", content, true, context)
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(73);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(7).default
module.exports.__inject__ = function (context) {
  add("56b15182", content, true, context)
};

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _getObjectType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);


function checkRendering(rendering, usage) {
  if (rendering === undefined || typeof rendering !== 'function') {
    throw new Error("The render function is not valid (received type ".concat(Object(_getObjectType__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(rendering), ").\n\n").concat(usage));
  }
}

/* harmony default export */ __webpack_exports__["a"] = (checkRendering);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Clears the refinements of a SearchParameters object based on rules provided.
 * The included attributes list is applied before the excluded attributes list. If the list
 * is not provided, this list of all the currently refined attributes is used as included attributes.
 * @param {object} $0 parameters
 * @param {Helper} $0.helper instance of the Helper
 * @param {string[]} [$0.attributesToClear = []] list of parameters to clear
 * @returns {SearchParameters} search parameters with refinements cleared
 */
function clearRefinements(_ref) {
  var helper = _ref.helper,
      _ref$attributesToClea = _ref.attributesToClear,
      attributesToClear = _ref$attributesToClea === void 0 ? [] : _ref$attributesToClea;
  var finalState = helper.state.setPage(0);
  finalState = attributesToClear.reduce(function (state, attribute) {
    if (finalState.isNumericRefined(attribute)) {
      return state.removeNumericRefinement(attribute);
    }

    if (finalState.isHierarchicalFacet(attribute)) {
      return state.removeHierarchicalFacetRefinement(attribute);
    }

    if (finalState.isDisjunctiveFacet(attribute)) {
      return state.removeDisjunctiveFacetRefinement(attribute);
    }

    if (finalState.isConjunctiveFacet(attribute)) {
      return state.removeFacetRefinement(attribute);
    }

    return state;
  }, finalState);

  if (attributesToClear.indexOf('query') !== -1) {
    finalState = finalState.setQuery('');
  }

  return finalState;
}

/* harmony default export */ __webpack_exports__["a"] = (clearRefinements);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _unescapeRefinement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);



function getRefinement(state, type, attribute, name) {
  var resultsFacets = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var res = {
    type: type,
    attribute: attribute,
    name: name
  };
  var facet = Object(_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(resultsFacets, function (resultsFacet) {
    return resultsFacet.name === attribute;
  });
  var count;

  if (type === 'hierarchical') {
    (function () {
      var facetDeclaration = state.getHierarchicalFacetByName(attribute);
      var nameParts = name.split(facetDeclaration.separator);

      var getFacetRefinement = function getFacetRefinement(facetData) {
        return function (refinementKey) {
          return facetData[refinementKey];
        };
      };

      var _loop = function _loop(i) {
        facet = facet && facet.data && Object(_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Object.keys(facet.data).map(getFacetRefinement(facet.data)), function (refinement) {
          return refinement.name === nameParts[i];
        });
      };

      for (var i = 0; facet !== undefined && i < nameParts.length; ++i) {
        _loop(i);
      }

      count = facet && facet.count;
    })();
  } else {
    count = facet && facet.data && facet.data[res.name];
  }

  var exhaustive = facet && facet.exhaustive;

  if (count !== undefined) {
    res.count = count;
  }

  if (exhaustive !== undefined) {
    res.exhaustive = exhaustive;
  }

  return res;
}

function getRefinements(results, state) {
  var clearsQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var refinements = [];
  var _state$facetsRefineme = state.facetsRefinements,
      facetsRefinements = _state$facetsRefineme === void 0 ? {} : _state$facetsRefineme,
      _state$facetsExcludes = state.facetsExcludes,
      facetsExcludes = _state$facetsExcludes === void 0 ? {} : _state$facetsExcludes,
      _state$disjunctiveFac = state.disjunctiveFacetsRefinements,
      disjunctiveFacetsRefinements = _state$disjunctiveFac === void 0 ? {} : _state$disjunctiveFac,
      _state$hierarchicalFa = state.hierarchicalFacetsRefinements,
      hierarchicalFacetsRefinements = _state$hierarchicalFa === void 0 ? {} : _state$hierarchicalFa,
      _state$numericRefinem = state.numericRefinements,
      numericRefinements = _state$numericRefinem === void 0 ? {} : _state$numericRefinem,
      _state$tagRefinements = state.tagRefinements,
      tagRefinements = _state$tagRefinements === void 0 ? [] : _state$tagRefinements;
  Object.keys(facetsRefinements).forEach(function (attribute) {
    var refinementNames = facetsRefinements[attribute];
    refinementNames.forEach(function (refinementName) {
      refinements.push(getRefinement(state, 'facet', attribute, refinementName, results.facets));
    });
  });
  Object.keys(facetsExcludes).forEach(function (attribute) {
    var refinementNames = facetsExcludes[attribute];
    refinementNames.forEach(function (refinementName) {
      refinements.push({
        type: 'exclude',
        attribute: attribute,
        name: refinementName,
        exclude: true
      });
    });
  });
  Object.keys(disjunctiveFacetsRefinements).forEach(function (attribute) {
    var refinementNames = disjunctiveFacetsRefinements[attribute];
    refinementNames.forEach(function (refinementName) {
      refinements.push(getRefinement(state, 'disjunctive', attribute, // We unescape any disjunctive refined values with `unescapeRefinement` because
      // they can be escaped on negative numeric values with `escapeRefinement`.
      Object(_unescapeRefinement__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(refinementName), results.disjunctiveFacets));
    });
  });
  Object.keys(hierarchicalFacetsRefinements).forEach(function (attribute) {
    var refinementNames = hierarchicalFacetsRefinements[attribute];
    refinementNames.forEach(function (refinement) {
      refinements.push(getRefinement(state, 'hierarchical', attribute, refinement, results.hierarchicalFacets));
    });
  });
  Object.keys(numericRefinements).forEach(function (attribute) {
    var operators = numericRefinements[attribute];
    Object.keys(operators).forEach(function (operatorOriginal) {
      var operator = operatorOriginal;
      var valueOrValues = operators[operator];
      var refinementNames = Array.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
      refinementNames.forEach(function (refinementName) {
        refinements.push({
          type: 'numeric',
          attribute: attribute,
          name: "".concat(refinementName),
          numericValue: refinementName,
          operator: operator
        });
      });
    });
  });
  tagRefinements.forEach(function (refinementName) {
    refinements.push({
      type: 'tag',
      attribute: '_tags',
      name: refinementName
    });
  });

  if (clearsQuery && state.query && state.query.trim()) {
    refinements.push({
      attribute: 'query',
      type: 'query',
      name: state.query,
      query: state.query
    });
  }

  return refinements;
}

/* harmony default export */ __webpack_exports__["a"] = (getRefinements);

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createSendEventForFacet; });
/* harmony import */ var _isFacetRefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}


function createSendEventForFacet(_ref) {
  var instantSearchInstance = _ref.instantSearchInstance,
      helper = _ref.helper,
      attribute = _ref.attribute,
      widgetType = _ref.widgetType;

  var sendEventForFacet = function sendEventForFacet() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var eventType = args[0],
        facetValue = args[1],
        _args$ = args[2],
        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;

    if (args.length === 1 && _typeof(args[0]) === 'object') {
      instantSearchInstance.sendEventToInsights(args[0]);
    } else if (eventType === 'click' && (args.length === 2 || args.length === 3)) {
      if (!Object(_isFacetRefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(helper, attribute, facetValue)) {
        // send event only when the facet is being checked "ON"
        instantSearchInstance.sendEventToInsights({
          insightsMethod: 'clickedFilters',
          widgetType: widgetType,
          eventType: eventType,
          payload: {
            eventName: eventName,
            index: helper.getIndex(),
            filters: ["".concat(attribute, ":").concat(JSON.stringify(facetValue))]
          }
        });
      }
    } else if (false) {}
  };

  return sendEventForFacet;
}

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createSendEventForHits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createBindEventForHits; });
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var buildPayload = function buildPayload(_ref) {
  var index = _ref.index,
      widgetType = _ref.widgetType,
      methodName = _ref.methodName,
      args = _ref.args;

  if (args.length === 1 && _typeof(args[0]) === 'object') {
    return args[0];
  }

  var eventType = args[0];
  var hits = args[1];
  var eventName = args[2];

  if (!hits) {
    if (false) {} else {
      return null;
    }
  }

  if ((eventType === 'click' || eventType === 'conversion') && !eventName) {
    if (false) {} else {
      return null;
    }
  }

  var hitsArray = Array.isArray(hits) ? hits : [hits];

  if (hitsArray.length === 0) {
    return null;
  }

  var queryID = hitsArray[0].__queryID;
  var objectIDs = hitsArray.map(function (hit) {
    return hit.objectID;
  });
  var positions = hitsArray.map(function (hit) {
    return hit.__position;
  });

  if (eventType === 'view') {
    return {
      insightsMethod: 'viewedObjectIDs',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName || 'Hits Viewed',
        index: index,
        objectIDs: objectIDs
      }
    };
  } else if (eventType === 'click') {
    return {
      insightsMethod: 'clickedObjectIDsAfterSearch',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName,
        index: index,
        queryID: queryID,
        objectIDs: objectIDs,
        positions: positions
      }
    };
  } else if (eventType === 'conversion') {
    return {
      insightsMethod: 'convertedObjectIDsAfterSearch',
      widgetType: widgetType,
      eventType: eventType,
      payload: {
        eventName: eventName,
        index: index,
        queryID: queryID,
        objectIDs: objectIDs
      }
    };
  } else if (false) {} else {
    return null;
  }
};

function createSendEventForHits(_ref2) {
  var instantSearchInstance = _ref2.instantSearchInstance,
      index = _ref2.index,
      widgetType = _ref2.widgetType;

  var sendEventForHits = function sendEventForHits() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var payload = buildPayload({
      widgetType: widgetType,
      index: index,
      methodName: 'sendEvent',
      args: args
    });

    if (payload) {
      instantSearchInstance.sendEventToInsights(payload);
    }
  };

  return sendEventForHits;
}
function createBindEventForHits(_ref3) {
  var index = _ref3.index,
      widgetType = _ref3.widgetType;

  var bindEventForHits = function bindEventForHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var payload = buildPayload({
      widgetType: widgetType,
      index: index,
      methodName: 'bindEvent',
      args: args
    });
    return payload ? "data-insights-event=".concat(btoa(JSON.stringify(payload))) : '';
  };

  return bindEventForHits;
}

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addAbsolutePosition; });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var addAbsolutePosition = function addAbsolutePosition(hits, page, hitsPerPage) {
  return hits.map(function (hit, idx) {
    return _objectSpread({}, hit, {
      __position: hitsPerPage * page + idx + 1
    });
  });
};

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addQueryID; });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var addQueryID = function addQueryID(hits, queryID) {
  if (!queryID) {
    return hits;
  }

  return hits.map(function (hit) {
    return _objectSpread({}, hit, {
      __queryID: queryID
    });
  });
};

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function isPrimitive(obj) {
  return obj !== Object(obj);
}

function isEqual(first, second) {
  if (first === second) {
    return true;
  }

  if (isPrimitive(first) || isPrimitive(second) || typeof first === 'function' || typeof second === 'function') {
    return first === second;
  }

  if (Object.keys(first).length !== Object.keys(second).length) {
    return false;
  }

  for (var _i = 0, _Object$keys = Object.keys(first); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (!(key in second)) {
      return false;
    }

    if (!isEqual(first[key], second[key])) {
      return false;
    }
  }

  return true;
}

/* harmony default export */ __webpack_exports__["a"] = (isEqual);

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return convertNumericRefinementsToFilters; });
function convertNumericRefinementsToFilters(state, attribute) {
  if (!state) {
    return null;
  }

  var filtersObj = state.numericRefinements[attribute];
  /*
    filtersObj === {
      "<=": [10],
      "=": [],
      ">=": [5]
    }
  */

  var filters = [];
  Object.keys(filtersObj).filter(function (operator) {
    return Array.isArray(filtersObj[operator]) && filtersObj[operator].length > 0;
  }).forEach(function (operator) {
    filtersObj[operator].forEach(function (value) {
      filters.push("".concat(attribute).concat(operator).concat(value));
    });
  });
  return filters;
}

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// This is the `Number.isFinite()` polyfill recommended by MDN.
// We do not provide any tests for this function.
// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
function isFiniteNumber(value) {
  return typeof value === 'number' && isFinite(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isFiniteNumber);

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function range(_ref) {
  var _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      end = _ref.end,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step; // We can't divide by 0 so we re-assign the step to 1 if it happens.

  var limitStep = step === 0 ? 1 : step; // In some cases the array to create has a decimal length.
  // We therefore need to round the value.
  // Example:
  //   { start: 1, end: 5000, step: 500 }
  //   => Array length = (5000 - 1) / 500 = 9.998

  var arrayLength = Math.round((end - start) / limitStep);
  return _toConsumableArray(Array(arrayLength)).map(function (_, current) {
    return start + current * limitStep;
  });
}

/* harmony default export */ __webpack_exports__["a"] = (range);

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}

/* harmony default export */ __webpack_exports__["a"] = (toArray);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function escapeRefinement(value) {
  if (typeof value === 'number' && value < 0) {
    value = String(value).replace(/^-/, '\\-');
  }

  return value;
}

/* harmony default export */ __webpack_exports__["a"] = (escapeRefinement);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function getPropertyByPath(object, path) {
  var parts = Array.isArray(path) ? path : path.split('.');
  return parts.reduce(function (current, key) {
    return current && current[key];
  }, object);
}

/* harmony default export */ __webpack_exports__["a"] = (getPropertyByPath);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var nextMicroTask = Promise.resolve();

var defer = function defer(callback) {
  var progress = null;
  var cancelled = false;

  var fn = function fn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (progress !== null) {
      return;
    }

    progress = nextMicroTask.then(function () {
      progress = null;

      if (cancelled) {
        cancelled = false;
        return;
      }

      callback.apply(void 0, args);
    });
  };

  fn.wait = function () {
    if (progress === null) {
      throw new Error('The deferred function should be called before calling `wait()`');
    }

    return progress;
  };

  fn.cancel = function () {
    if (progress === null) {
      return;
    }

    cancelled = true;
  };

  return fn;
};

/* harmony default export */ __webpack_exports__["a"] = (defer);

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concatHighlightedParts; });
/* harmony import */ var _escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

function concatHighlightedParts(parts) {
  var highlightPreTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ "b"].highlightPreTag,
      highlightPostTag = _escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ "b"].highlightPostTag;
  return parts.map(function (part) {
    return part.isHighlighted ? highlightPreTag + part.value + highlightPostTag : part.value;
  }).join('');
}

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getHighlightedParts; });
/* harmony import */ var _lib_escape_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

function getHighlightedParts(highlightedValue) {
  var highlightPostTag = _lib_escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ "b"].highlightPostTag,
      highlightPreTag = _lib_escape_highlight__WEBPACK_IMPORTED_MODULE_0__[/* TAG_REPLACEMENT */ "b"].highlightPreTag;
  var splitByPreTag = highlightedValue.split(highlightPreTag);
  var firstValue = splitByPreTag.shift();
  var elements = !firstValue ? [] : [{
    value: firstValue,
    isHighlighted: false
  }];
  splitByPreTag.forEach(function (split) {
    var splitByPostTag = split.split(highlightPostTag);
    elements.push({
      value: splitByPostTag[0],
      isHighlighted: true
    });

    if (splitByPostTag[1] !== '') {
      elements.push({
        value: splitByPostTag[1],
        isHighlighted: false
      });
    }
  });
  return elements;
}

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return reverseHighlightedParts; });
/* harmony import */ var _getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


function reverseHighlightedParts(parts) {
  if (!parts.some(function (part) {
    return part.isHighlighted;
  })) {
    return parts.map(function (part) {
      return _objectSpread({}, part, {
        isHighlighted: false
      });
    });
  }

  return parts.map(function (part, i) {
    return _objectSpread({}, part, {
      isHighlighted: !Object(_getHighlightFromSiblings__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(parts, i)
    });
  });
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = require("vue-meta");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopDefault(e) {
  return e && "object" == typeof e && "default" in e ? e.default : e;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var connectors = __webpack_require__(77),
    Vue = _interopDefault(__webpack_require__(0)),
    utils = __webpack_require__(1),
    indexWidget = _interopDefault(__webpack_require__(19)),
    instantsearch = _interopDefault(__webpack_require__(79)),
    algoliaHelper = _interopDefault(__webpack_require__(4));

function suit(e, t, n) {
  if (!e) throw new Error("You need to provide `widgetName` in your data");
  var i = ["ais-" + e];
  return t && i.push("-" + t), n && i.push("--" + n), i.join("");
}

var createSuitMixin = function (e) {
  var t = e.name;
  return {
    props: {
      classNames: {
        type: Object,
        default: void 0
      }
    },
    methods: {
      suit: function (e, n) {
        var i = suit(t, e, n),
            s = this.classNames && this.classNames[i];
        return s ? [i, s].join(" ") : i;
      }
    }
  };
},
    cache = new Set();

function warn(e) {
  cache.has(e) || (cache.add(e), console.warn(e));
}

var createWidgetMixin = function (e) {
  void 0 === e && (e = {});
  var t = e.connector;
  return {
    inject: {
      instantSearchInstance: {
        from: "$_ais_instantSearchInstance",
        default: function () {
          var e = this.$options._componentTag;
          throw new TypeError('It looks like you forgot to wrap your Algolia search component "<' + e + '>" inside of an "<ais-instant-search>" component.');
        }
      },
      getParentIndex: {
        from: "$_ais_getParentIndex",
        default: function () {
          var e = this;
          return function () {
            return e.instantSearchInstance.mainIndex;
          };
        }
      }
    },
    data: function () {
      return {
        state: null
      };
    },
    created: function () {
      if ("function" == typeof t) {
        if (this.factory = t(this.updateState, function () {}), this.widget = this.factory(this.widgetParams), this.getParentIndex().addWidgets([this.widget]), this.instantSearchInstance.__initialSearchResults && !this.instantSearchInstance.started) {
          if ("function" != typeof this.instantSearchInstance.__forceRender) throw new Error("You are using server side rendering with <ais-instant-search> instead of <ais-instant-search-ssr>.");

          this.instantSearchInstance.__forceRender(this.widget, this.getParentIndex());
        }
      } else !0 !== t && warn("You are using the InstantSearch widget mixin, but didn't provide a connector.\nWhile this is technically possible, and will give you access to the Helper,\nit's not the recommended way of making custom components.\n\nIf you want to disable this message, pass { connector: true } to the mixin.\n\nRead more on using connectors: https://alg.li/vue-custom");
    },
    beforeDestroy: function () {
      this.widget && this.getParentIndex().removeWidgets([this.widget]);
    },
    watch: {
      widgetParams: {
        handler: function (e) {
          this.state = null, this.getParentIndex().removeWidgets([this.widget]), this.widget = this.factory(e), this.getParentIndex().addWidgets([this.widget]);
        },
        deep: !0
      }
    },
    methods: {
      updateState: function (e, t) {
        void 0 === e && (e = {}), t || (this.state = e);
      }
    }
  };
},
    Autocomplete = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("p", [e._v("This widget doesn't render anything without a filled in default slot.")]), e._v(" "), n("p", [e._v("query, function to refine and results are provided.")]), e._v(" "), n("pre", [e._v("refine: Function")]), e._v(" "), n("pre", [e._v('currentRefinement: "' + e._s(e.state.currentRefinement) + '"')]), e._v(" "), n("details", [e._m(0), e._v(" "), n("pre", [e._v(e._s(e.state.indices))])])], {
      refine: e.state.refine,
      currentRefinement: e.state.currentRefinement,
      indices: e.state.indices
    })], 2) : e._e();
  },
  staticRenderFns: [function () {
    var e = this.$createElement,
        t = this._self._c || e;
    return t("summary", [t("code", [this._v("indices")]), this._v(":")]);
  }],
  name: "AisAutocomplete",
  mixins: [createWidgetMixin({
    connector: connectors.connectAutocomplete
  }), createSuitMixin({
    name: "Autocomplete"
  })],
  props: {
    escapeHTML: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  computed: {
    widgetParams: function () {
      return {
        escapeHTML: this.escapeHTML
      };
    }
  }
},
    PANEL_EMITTER_NAMESPACE = "instantSearchPanelEmitter",
    PANEL_CHANGE_EVENT = "PANEL_CHANGE_EVENT",
    createPanelProviderMixin = function () {
  return {
    props: {
      emitter: {
        type: Object,
        required: !1,
        default: function () {
          return new Vue({
            name: "PanelProvider"
          });
        }
      }
    },
    provide: function () {
      var e;
      return (e = {})[PANEL_EMITTER_NAMESPACE] = this.emitter, e;
    },
    data: function () {
      return {
        canRefine: !0
      };
    },
    created: function () {
      var e = this;
      this.emitter.$on(PANEL_CHANGE_EVENT, function (t) {
        e.updateCanRefine(t);
      });
    },
    beforeDestroy: function () {
      this.emitter.$destroy();
    },
    methods: {
      updateCanRefine: function (e) {
        this.canRefine = e;
      }
    }
  };
},
    createPanelConsumerMixin = function (e) {
  var t = e.mapStateToCanRefine;
  return {
    inject: {
      emitter: {
        from: PANEL_EMITTER_NAMESPACE,
        default: function () {
          return {
            $emit: function () {}
          };
        }
      }
    },
    data: function () {
      return {
        state: null,
        hasAlreadyEmitted: !1
      };
    },
    watch: {
      state: {
        immediate: !0,
        handler: function (e, n) {
          if (e) {
            var i = t(n || {}),
                s = t(e);
            this.hasAlreadyEmitted && i === s || (this.emitter.$emit(PANEL_CHANGE_EVENT, s), this.hasAlreadyEmitted = !0);
          }
        }
      }
    }
  };
},
    Breadcrumb = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.state.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("ul", {
      class: e.suit("list")
    }, [n("li", {
      class: [e.suit("item"), !e.state.items.length && e.suit("item", "selected")]
    }, [Boolean(e.state.items.length) ? n("a", {
      class: e.suit("link"),
      attrs: {
        href: e.state.createURL()
      },
      on: {
        click: function (t) {
          t.preventDefault(), e.state.refine();
        }
      }
    }, [e._t("rootLabel", [e._v("Home")])], 2) : n("span", [e._t("rootLabel", [e._v("Home")])], 2)]), e._v(" "), e._l(e.state.items, function (t, i) {
      return n("li", {
        key: t.label,
        class: [e.suit("item"), e.isLastItem(i) && e.suit("item", "selected")]
      }, [n("span", {
        class: e.suit("separator"),
        attrs: {
          "aria-hidden": "true"
        }
      }, [e._t("separator", [e._v(">")])], 2), e._v(" "), e.isLastItem(i) ? n("span", [e._v(e._s(t.label))]) : n("a", {
        class: e.suit("link"),
        attrs: {
          href: e.state.createURL(t.value)
        },
        on: {
          click: function (n) {
            n.preventDefault(), e.state.refine(t.value);
          }
        }
      }, [e._v(e._s(t.label))])]);
    })], 2)], {
      items: e.state.items,
      canRefine: e.state.canRefine,
      refine: e.state.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisBreadcrumb",
  mixins: [createWidgetMixin({
    connector: connectors.connectBreadcrumb
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.canRefine);
    }
  }), createSuitMixin({
    name: "Breadcrumb"
  })],
  props: {
    attributes: {
      type: Array,
      required: !0
    },
    separator: {
      type: String,
      default: " > "
    },
    rootPath: {
      type: String,
      default: null
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attributes: this.attributes,
        separator: this.separator,
        rootPath: this.rootPath,
        transformItems: this.transformItems
      };
    }
  },
  methods: {
    isLastItem: function (e) {
      return this.state.items.length - 1 === e;
    }
  }
},
    ClearRefinements = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("button", {
      class: [e.suit("button"), !e.canRefine && e.suit("button", "disabled")],
      attrs: {
        type: "reset",
        disabled: !e.canRefine
      },
      on: {
        click: function (t) {
          return t.preventDefault(), e.state.refine(t);
        }
      }
    }, [e._t("resetLabel", [e._v("Clear refinements")])], 2)], {
      canRefine: e.canRefine,
      refine: e.state.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisClearRefinements",
  mixins: [createWidgetMixin({
    connector: connectors.connectClearRefinements
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.hasRefinements);
    }
  }), createSuitMixin({
    name: "ClearRefinements"
  })],
  props: {
    excludedAttributes: {
      type: Array
    },
    includedAttributes: {
      type: Array
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        includedAttributes: this.includedAttributes,
        excludedAttributes: this.excludedAttributes,
        transformItems: this.transformItems
      };
    },
    canRefine: function () {
      return this.state.hasRefinements;
    }
  }
},
    Configure = {
  inheritAttrs: !1,
  name: "AisConfigure",
  mixins: [createSuitMixin({
    name: "Configure"
  }), createWidgetMixin({
    connector: connectors.connectConfigure
  })],
  computed: {
    widgetParams: function () {
      return {
        searchParameters: this.$attrs
      };
    }
  },
  render: function (e) {
    return this.state && this.$scopedSlots.default ? e("div", {
      class: this.suit()
    }, [this.$scopedSlots.default({
      refine: this.state.refine,
      searchParameters: this.state.widgetParams.searchParameters
    })]) : null;
  }
},
    ConfigureRelatedItems = {
  inheritAttrs: !1,
  name: "AisExperimentalConfigureRelatedItems",
  mixins: [createWidgetMixin({
    connector: connectors.EXPERIMENTAL_connectConfigureRelatedItems
  })],
  props: {
    hit: {
      type: Object,
      required: !0
    },
    matchingPatterns: {
      type: Object,
      required: !0
    },
    transformSearchParameters: {
      type: Function,
      required: !1
    }
  },
  computed: {
    widgetParams: function () {
      return {
        hit: this.hit,
        matchingPatterns: this.matchingPatterns,
        transformSearchParameters: this.transformSearchParameters
      };
    }
  },
  render: function () {
    return null;
  }
},
    CurrentRefinements = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), e.noRefinement && e.suit("", "noRefinement")]
    }, [e._t("default", [n("ul", {
      class: e.suit("list")
    }, e._l(e.state.items, function (t) {
      return n("li", {
        key: t.attribute,
        class: e.suit("item")
      }, [e._t("item", [n("span", {
        class: e.suit("label")
      }, [e._v(e._s(e._f("capitalize")(t.label)) + ": ")]), e._v(" "), e._l(t.refinements, function (i) {
        return n("span", {
          key: e.createItemKey(i),
          class: e.suit("category")
        }, [e._t("refinement", [n("span", {
          class: e.suit("categoryLabel")
        }, ["query" === i.attribute ? n("q", [e._v(e._s(i.label))]) : [e._v(" " + e._s(i.label) + " ")]], 2), e._v(" "), n("button", {
          class: e.suit("delete"),
          on: {
            click: function (e) {
              t.refine(i);
            }
          }
        }, [e._v(" ✕ ")])], {
          refine: t.refine,
          refinement: i,
          createURL: e.state.createURL
        })], 2);
      })], {
        refine: t.refine,
        item: t,
        createURL: e.state.createURL
      })], 2);
    }))], {
      refine: e.state.refine,
      items: e.state.items,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisCurrentRefinements",
  mixins: [createSuitMixin({
    name: "CurrentRefinements"
  }), createWidgetMixin({
    connector: connectors.connectCurrentRefinements
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.items) && e.items.length > 0;
    }
  })],
  props: {
    includedAttributes: {
      type: Array
    },
    excludedAttributes: {
      type: Array
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    noRefinement: function () {
      return this.state && 0 === this.state.items.length;
    },
    widgetParams: function () {
      return {
        includedAttributes: this.includedAttributes,
        excludedAttributes: this.excludedAttributes,
        transformItems: this.transformItems
      };
    }
  },
  methods: {
    createItemKey: function (e) {
      var t = e.attribute,
          n = e.value;
      return [t, e.type, n, e.operator].join(":");
    }
  },
  filters: {
    capitalize: function (e) {
      return e ? e.toString().charAt(0).toLocaleUpperCase() + e.toString().slice(1) : "";
    }
  }
},
    HierarchicalMenuList = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return n("ul", {
      class: [e.suit("list"), e.level > 0 && e.suit("list", "child"), e.suit("list", "lvl" + e.level)]
    }, e._l(e.items, function (t) {
      return n("li", {
        key: t.value,
        class: [e.suit("item"), t.data && e.suit("item", "parent"), t.isRefined && e.suit("item", "selected")]
      }, [n("a", {
        class: e.suit("link"),
        attrs: {
          href: e.createURL(t.value)
        },
        on: {
          click: function (n) {
            n.preventDefault(), e.refine(t.value);
          }
        }
      }, [n("span", {
        class: e.suit("label")
      }, [e._v(e._s(t.label))]), e._v(" "), n("span", {
        class: e.suit("count")
      }, [e._v(e._s(t.count))])]), e._v(" "), t.data ? n("hierarchical-menu-list", {
        attrs: {
          items: t.data,
          level: e.level + 1,
          refine: e.refine,
          createURL: e.createURL,
          suit: e.suit
        }
      }) : e._e()], 1);
    }));
  },
  staticRenderFns: [],
  name: "HierarchicalMenuList",
  props: {
    items: {
      type: Array,
      required: !0
    },
    level: {
      type: Number,
      required: !0
    },
    refine: {
      type: Function,
      required: !0
    },
    createURL: {
      type: Function,
      required: !0
    },
    suit: {
      type: Function,
      required: !0
    }
  }
},
    mapStateToCanRefine = function (e) {
  return Boolean(e.items) && e.items.length > 0;
},
    HierarchicalMenu = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("hierarchical-menu-list", {
      attrs: {
        items: e.state.items,
        level: 0,
        refine: e.state.refine,
        createURL: e.state.createURL,
        suit: e.suit
      }
    }), e._v(" "), e.showMore ? n("button", {
      class: [e.suit("showMore"), !e.state.canToggleShowMore && e.suit("showMore", "disabled")],
      attrs: {
        disabled: !e.state.canToggleShowMore
      },
      on: {
        click: function (t) {
          return t.preventDefault(), e.state.toggleShowMore(t);
        }
      }
    }, [e._t("showMoreLabel", [e._v(e._s(e.state.isShowingMore ? "Show less" : "Show more"))], {
      isShowingMore: e.state.isShowingMore
    })], 2) : e._e()], {
      items: e.state.items,
      canRefine: e.canRefine,
      canToggleShowMore: e.state.canToggleShowMore,
      isShowingMore: e.state.isShowingMore,
      refine: e.state.refine,
      createURL: e.state.createURL,
      toggleShowMore: e.state.toggleShowMore
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisHierarchicalMenu",
  mixins: [createSuitMixin({
    name: "HierarchicalMenu"
  }), createWidgetMixin({
    connector: connectors.connectHierarchicalMenu
  }), createPanelConsumerMixin({
    mapStateToCanRefine: mapStateToCanRefine
  })],
  components: {
    HierarchicalMenuList: HierarchicalMenuList
  },
  props: {
    attributes: {
      type: Array,
      required: !0
    },
    limit: {
      type: Number,
      default: 10
    },
    showMoreLimit: {
      type: Number,
      default: 20
    },
    showMore: {
      type: Boolean,
      default: !1
    },
    sortBy: {
      type: [Array, Function],
      default: function () {
        return ["name:asc"];
      }
    },
    separator: {
      type: String,
      default: " > "
    },
    rootPath: {
      type: String,
      default: null
    },
    showParentLevel: {
      type: Boolean,
      default: !0
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attributes: this.attributes,
        limit: this.limit,
        showMore: this.showMore,
        showMoreLimit: this.showMoreLimit,
        separator: this.separator,
        rootPath: this.rootPath,
        showParentLevel: this.showParentLevel,
        sortBy: this.sortBy,
        transformItems: this.transformItems
      };
    },
    canRefine: function () {
      return mapStateToCanRefine(this.state);
    }
  }
},
    htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
},
    reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);

function unescape(e) {
  return e && reHasEscapedHtml.test(e) ? e.replace(reEscapedHtml, function (e) {
    return htmlUnescapes[e];
  }) : e;
}

var TAG_PLACEHOLDER = {
  highlightPreTag: "__ais-highlight__",
  highlightPostTag: "__/ais-highlight__"
};

function parseHighlightedAttribute(e) {
  var t = e.preTag,
      n = e.postTag,
      i = e.highlightedValue;
  void 0 === i && (i = "");
  var s = i.split(t),
      a = s.shift(),
      r = "" === a ? [] : [{
    value: a,
    isHighlighted: !1
  }];

  if (n === t) {
    var o = !0;
    s.forEach(function (e) {
      r.push({
        value: e,
        isHighlighted: o
      }), o = !o;
    });
  } else s.forEach(function (e) {
    var t = e.split(n);
    r.push({
      value: t[0],
      isHighlighted: !0
    }), "" !== t[1] && r.push({
      value: " " === t[1] ? "  " : t[1],
      isHighlighted: !1
    });
  });

  return r;
}

function parseAlgoliaHit(e) {
  var t = e.preTag;
  void 0 === t && (t = TAG_PLACEHOLDER.highlightPreTag);
  var n = e.postTag;
  void 0 === n && (n = TAG_PLACEHOLDER.highlightPostTag);
  var i = e.highlightProperty,
      s = e.attribute,
      a = e.hit;
  if (!a) throw new Error("`hit`, the matching record, must be provided");
  var r = utils.getPropertyByPath(a[i], s) || {};
  return Array.isArray(r) ? r.map(function (e) {
    return parseHighlightedAttribute({
      preTag: t,
      postTag: n,
      highlightedValue: unescape(e.value)
    });
  }) : parseHighlightedAttribute({
    preTag: t,
    postTag: n,
    highlightedValue: unescape(r.value)
  });
}

var AisHighlighter = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return n("span", {
      class: e.suit()
    }, e._l(e.parsedHighlights, function (t, i) {
      var s = t.value,
          a = t.isHighlighted;
      return n(a ? e.highlightedTagName : e.textNode, {
        key: i,
        tag: "component",
        class: [a && e.suit("highlighted")]
      }, [e._v(e._s(s))]);
    }), 1);
  },
  staticRenderFns: [],
  name: "AisHighlighter",
  props: {
    hit: {
      type: Object,
      required: !0
    },
    attribute: {
      type: String,
      required: !0
    },
    highlightedTagName: {
      type: String,
      default: "mark"
    },
    suit: {
      type: Function,
      required: !0
    },
    highlightProperty: {
      type: String,
      required: !0
    },
    preTag: {
      type: String,
      required: !0
    },
    postTag: {
      type: String,
      required: !0
    }
  },
  data: function () {
    return {
      textNode: {
        functional: !0,
        render: function (e, t) {
          return t.slots().default;
        }
      }
    };
  },
  computed: {
    parsedHighlights: function () {
      return parseAlgoliaHit({
        attribute: this.attribute,
        hit: this.hit,
        highlightProperty: this.highlightProperty,
        preTag: this.preTag,
        postTag: this.postTag
      });
    }
  }
},
    AisHighlight = {
  render: function () {
    var e = this.$createElement;
    return (this._self._c || e)("ais-highlighter", {
      attrs: {
        hit: this.hit,
        attribute: this.attribute,
        "highlighted-tag-name": this.highlightedTagName,
        suit: this.suit,
        "highlight-property": "_highlightResult",
        "pre-tag": "<mark>",
        "post-tag": "</mark>"
      }
    });
  },
  staticRenderFns: [],
  name: "AisHighlight",
  mixins: [createSuitMixin({
    name: "Highlight"
  })],
  components: {
    AisHighlighter: AisHighlighter
  },
  props: {
    hit: {
      type: Object,
      required: !0
    },
    attribute: {
      type: String,
      required: !0
    },
    highlightedTagName: {
      type: String,
      default: "mark"
    }
  }
},
    Hits = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("ol", {
      class: e.suit("list")
    }, e._l(e.items, function (t, i) {
      return n("li", {
        key: t.objectID,
        class: e.suit("item")
      }, [e._t("item", [e._v("objectID: " + e._s(t.objectID) + ", index: " + e._s(i))], {
        item: t,
        index: i,
        insights: e.state.insights
      })], 2);
    }))], {
      items: e.items,
      insights: e.state.insights
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisHits",
  mixins: [createWidgetMixin({
    connector: connectors.connectHitsWithInsights
  }), createSuitMixin({
    name: "Hits"
  })],
  props: {
    escapeHTML: {
      type: Boolean,
      default: !0
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    items: function () {
      return this.state.hits;
    },
    widgetParams: function () {
      return {
        escapeHTML: this.escapeHTML,
        transformItems: this.transformItems
      };
    }
  }
},
    HitsPerPage = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("select", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: e.selected,
        expression: "selected"
      }],
      class: e.suit("select"),
      on: {
        change: [function (t) {
          var n = Array.prototype.filter.call(t.target.options, function (e) {
            return e.selected;
          }).map(function (e) {
            return "_value" in e ? e._value : e.value;
          });
          e.selected = t.target.multiple ? n : n[0];
        }, e.handleChange]
      }
    }, e._l(e.state.items, function (t) {
      return n("option", {
        key: t.value,
        class: e.suit("option"),
        domProps: {
          value: t.value
        }
      }, [e._v(e._s(t.label))]);
    }))], {
      items: e.state.items,
      refine: e.state.refine,
      hasNoResults: e.state.hasNoResults
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisHitsPerPage",
  mixins: [createSuitMixin({
    name: "HitsPerPage"
  }), createWidgetMixin({
    connector: connectors.connectHitsPerPage
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return !1 === e.hasNoResults;
    }
  })],
  props: {
    items: {
      type: Array,
      required: !0,
      default: function () {
        return [];
      }
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  data: function () {
    return {
      selected: this.items.find(function (e) {
        return !0 === e.default;
      }).value
    };
  },
  computed: {
    widgetParams: function () {
      return {
        items: this.items,
        transformItems: this.transformItems
      };
    }
  },
  methods: {
    handleChange: function () {
      this.state.refine(this.selected);
    }
  }
},
    connectIndex = function () {
  return indexWidget;
},
    Index = {
  name: "AisIndex",
  mixins: [createSuitMixin({
    name: "Index"
  }), createWidgetMixin({
    connector: connectIndex
  })],
  provide: function () {
    var e = this;
    return {
      $_ais_getParentIndex: function () {
        return e.widget;
      }
    };
  },
  props: {
    indexName: {
      type: String,
      required: !0
    },
    indexId: {
      type: String,
      required: !1
    }
  },
  render: function (e) {
    return e("div", {}, this.$slots.default);
  },
  computed: {
    widgetParams: function () {
      return {
        indexName: this.indexName,
        indexId: this.indexId
      };
    }
  }
},
    version = "3.4.3";

function _objectSpread(e) {
  for (var t = arguments, n = 1; n < arguments.length; n++) {
    var i = null != t[n] ? t[n] : {},
        s = Object.keys(i);
    "function" == typeof Object.getOwnPropertySymbols && (s = s.concat(Object.getOwnPropertySymbols(i).filter(function (e) {
      return Object.getOwnPropertyDescriptor(i, e).enumerable;
    }))), s.forEach(function (t) {
      _defineProperty(e, t, i[t]);
    });
  }

  return e;
}

function _defineProperty(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}

var createInstantSearchComponent = function (e) {
  return _objectSpread({
    mixins: [createSuitMixin({
      name: "InstantSearch"
    })],
    provide: function () {
      return {
        $_ais_instantSearchInstance: this.instantSearchInstance
      };
    },
    watch: {
      searchClient: function (e) {
        this.instantSearchInstance.helper.setClient(e).search();
      },
      indexName: function (e) {
        this.instantSearchInstance.helper.setIndex(e).search();
      },
      stalledSearchDelay: function (e) {
        this.instantSearchInstance._stalledSearchDelay = e;
      },
      routing: function () {
        throw new Error("routing configuration can not be changed dynamically at this point.\n\nPlease open a new issue: https://github.com/algolia/vue-instantsearch/issues/new?template=feature.md");
      },
      searchFunction: function (e) {
        this.instantSearchInstance._searchFunction = e;
      }
    },
    created: function () {
      var e = this.instantSearchInstance.client;
      "function" == typeof e.addAlgoliaAgent && (e.addAlgoliaAgent("Vue (" + Vue.version + ")"), e.addAlgoliaAgent("Vue InstantSearch (" + version + ")"));
    },
    mounted: function () {
      var e = this;
      this.$nextTick(function () {
        e.instantSearchInstance.started || e.instantSearchInstance.start();
      });
    },
    beforeDestroy: function () {
      this.instantSearchInstance.started && this.instantSearchInstance.dispose(), this.instantSearchInstance.__initialSearchResults = void 0;
    }
  }, e);
},
    oldApiWarning = "Vue InstantSearch: You used the prop api-key or app-id.\nThese have been replaced by search-client.\n\nSee more info here: https://www.algolia.com/doc/api-reference/widgets/instantsearch/vue/#widget-param-search-client",
    InstantSearch = createInstantSearchComponent({
  name: "AisInstantSearch",
  props: {
    searchClient: {
      type: Object,
      required: !0
    },
    insightsClient: {
      type: Function,
      required: !1
    },
    indexName: {
      type: String,
      required: !0
    },
    routing: {
      default: null,
      validator: function (e) {
        return !("boolean" == typeof e || !e.router && !e.stateMapping) || (warn("The `routing` option expects an object with `router` and/or `stateMapping`.\n\nSee https://www.algolia.com/doc/api-reference/widgets/instantsearch/vue/#widget-param-routing"), !1);
      }
    },
    stalledSearchDelay: {
      type: Number,
      default: 200
    },
    searchFunction: {
      type: Function,
      default: null
    },
    initialUiState: {
      type: Object,
      required: !1
    },
    apiKey: {
      type: String,
      default: null,
      validator: function (e) {
        return e && warn(oldApiWarning), !1;
      }
    },
    appId: {
      type: String,
      default: null,
      validator: function (e) {
        return e && warn(oldApiWarning), !1;
      }
    }
  },
  data: function () {
    return {
      instantSearchInstance: instantsearch({
        searchClient: this.searchClient,
        insightsClient: this.insightsClient,
        indexName: this.indexName,
        routing: this.routing,
        stalledSearchDelay: this.stalledSearchDelay,
        searchFunction: this.searchFunction,
        initialUiState: this.initialUiState
      })
    };
  },
  render: function (e) {
    var t;
    return e("div", {
      class: (t = {}, t[this.suit()] = !0, t[this.suit("", "ssr")] = !1, t)
    }, this.$slots.default);
  }
}),
    InstantSearchSsr = createInstantSearchComponent({
  name: "AisInstantSearchSsr",
  inject: {
    $_ais_ssrInstantSearchInstance: {
      default: function () {
        throw new Error("`createServerRootMixin` is required when using SSR.");
      }
    }
  },
  data: function () {
    return {
      instantSearchInstance: this.$_ais_ssrInstantSearchInstance
    };
  },
  render: function (e) {
    var t;
    return e("div", {
      class: (t = {}, t[this.suit()] = !0, t[this.suit("", "ssr")] = !0, t)
    }, this.$slots.default);
  }
}),
    InfiniteHits = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e.showPrevious ? e._t("loadPrevious", [n("button", {
      class: [e.suit("loadPrevious"), e.state.isFirstPage && e.suit("loadPrevious", "disabled")],
      attrs: {
        disabled: e.state.isFirstPage
      },
      on: {
        click: function (t) {
          e.refinePrevious();
        }
      }
    }, [e._v("Show previous results")])], {
      refinePrevious: e.refinePrevious,
      page: e.state.results.page,
      isFirstPage: e.state.isFirstPage
    }) : e._e(), e._v(" "), e._t("default", [n("ol", {
      class: e.suit("list")
    }, e._l(e.items, function (t, i) {
      return n("li", {
        key: t.objectID,
        class: e.suit("item")
      }, [e._t("item", [e._v("objectID: " + e._s(t.objectID) + ", index: " + e._s(i))], {
        item: t,
        index: i,
        insights: e.state.insights
      })], 2);
    })), e._v(" "), e._t("loadMore", [n("button", {
      class: [e.suit("loadMore"), e.state.isLastPage && e.suit("loadMore", "disabled")],
      attrs: {
        disabled: e.state.isLastPage
      },
      on: {
        click: function (t) {
          e.refineNext();
        }
      }
    }, [e._v("Show more results")])], {
      refineNext: e.refineNext,
      refine: e.refineNext,
      page: e.state.results.page,
      isLastPage: e.state.isLastPage
    })], {
      items: e.items,
      results: e.state.results,
      isLastPage: e.state.isLastPage,
      refinePrevious: e.refinePrevious,
      refineNext: e.refineNext,
      refine: e.refineNext,
      insights: e.state.insights
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisInfiniteHits",
  mixins: [createWidgetMixin({
    connector: connectors.connectInfiniteHitsWithInsights
  }), createSuitMixin({
    name: "InfiniteHits"
  })],
  props: {
    showPrevious: {
      type: Boolean,
      default: !1
    },
    escapeHTML: {
      type: Boolean,
      default: !0
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    },
    cache: {
      type: Object,
      default: void 0
    }
  },
  computed: {
    widgetParams: function () {
      return {
        showPrevious: this.showPrevious,
        escapeHTML: this.escapeHTML,
        transformItems: this.transformItems,
        cache: this.cache
      };
    },
    items: function () {
      return this.state.hits;
    }
  },
  methods: {
    refinePrevious: function () {
      this.state.showPrevious();
    },
    refineNext: function () {
      this.state.showMore();
    }
  }
},
    Menu = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.state.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("ul", {
      class: e.suit("list")
    }, e._l(e.state.items, function (t) {
      return n("li", {
        key: t.value,
        class: [e.suit("item"), t.isRefined && e.suit("item", "selected")]
      }, [n("a", {
        class: e.suit("link"),
        attrs: {
          href: e.state.createURL(t.value)
        },
        on: {
          click: function (n) {
            n.preventDefault(), e.state.refine(t.value);
          }
        }
      }, [n("span", {
        class: e.suit("label")
      }, [e._v(e._s(t.label))]), e._v(" "), n("span", {
        class: e.suit("count")
      }, [e._v(e._s(t.count))])])]);
    })), e._v(" "), e.showShowMoreButton ? n("button", {
      class: [e.suit("showMore"), !e.state.canToggleShowMore && e.suit("showMore", "disabled")],
      attrs: {
        disabled: !e.state.canToggleShowMore
      },
      on: {
        click: function (t) {
          t.preventDefault(), e.state.toggleShowMore();
        }
      }
    }, [e._t("showMoreLabel", [e._v(e._s(e.state.isShowingMore ? "Show less" : "Show more"))], {
      isShowingMore: e.state.isShowingMore
    })], 2) : e._e()], {
      items: e.state.items,
      canRefine: e.state.canRefine,
      canToggleShowMore: e.state.canToggleShowMore,
      isShowingMore: e.state.isShowingMore,
      refine: e.state.refine,
      createURL: e.state.createURL,
      toggleShowMore: e.state.toggleShowMore
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisMenu",
  mixins: [createSuitMixin({
    name: "Menu"
  }), createWidgetMixin({
    connector: connectors.connectMenu
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.canRefine);
    }
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    limit: {
      type: Number,
      default: 10
    },
    showMoreLimit: {
      type: Number,
      default: 20
    },
    showMore: {
      type: Boolean,
      default: !1
    },
    sortBy: {
      type: [Array, Function],
      default: function () {
        return ["count:desc", "name:asc"];
      }
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        limit: this.limit,
        showMore: this.showMore,
        showMoreLimit: this.showMoreLimit,
        sortBy: this.sortBy,
        transformItems: this.transformItems
      };
    },
    showShowMoreButton: function () {
      return this.state.canRefine && this.showMore;
    }
  }
},
    MenuSelect = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.state.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("select", {
      class: e.suit("select"),
      on: {
        change: function (t) {
          e.refine(t.currentTarget.value);
        }
      }
    }, [n("option", {
      class: e.suit("option"),
      attrs: {
        value: ""
      }
    }, [e._t("defaultOption", [e._v("See all")])], 2), e._v(" "), e._l(e.state.items, function (t) {
      return n("option", {
        key: t.value,
        class: e.suit("option"),
        domProps: {
          value: t.value,
          selected: t.isRefined
        }
      }, [e._t("item", [e._v(e._s(t.label) + " (" + e._s(t.count) + ")")], {
        item: t
      })], 2);
    })], 2)], {
      items: e.state.items,
      canRefine: e.state.canRefine,
      refine: e.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisMenuSelect",
  mixins: [createSuitMixin({
    name: "MenuSelect"
  }), createWidgetMixin({
    connector: connectors.connectMenu
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.canRefine);
    }
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    limit: {
      type: Number,
      default: 10
    },
    sortBy: {
      type: [Array, Function],
      default: function () {
        return ["name:asc"];
      }
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        limit: this.limit,
        sortBy: this.sortBy,
        transformItems: this.transformItems
      };
    }
  },
  methods: {
    refine: function (e) {
      this.state.refine(e);
    }
  }
},
    NumericMenu = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("ul", {
      class: [e.suit("list")]
    }, e._l(e.state.items, function (t) {
      return n("li", {
        key: t.label,
        class: [e.suit("item"), t.isRefined && e.suit("item", "selected")]
      }, [n("label", {
        class: e.suit("label")
      }, [n("input", {
        class: e.suit("radio"),
        attrs: {
          type: "radio",
          name: e.attribute
        },
        domProps: {
          value: t.value,
          checked: t.isRefined
        },
        on: {
          change: function (t) {
            e.state.refine(t.target.value);
          }
        }
      }), e._v(" "), n("span", {
        class: e.suit("labelText")
      }, [e._v(e._s(t.label))])])]);
    }))], {
      items: e.state.items,
      canRefine: e.canRefine,
      refine: e.state.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisNumericMenu",
  mixins: [createWidgetMixin({
    connector: connectors.connectNumericMenu
  }), createSuitMixin({
    name: "NumericMenu"
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return !1 === e.hasNoResults;
    }
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    items: {
      type: Array,
      required: !0
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        transformItems: this.transformItems,
        items: this.items
      };
    },
    canRefine: function () {
      return !this.state.hasNoResults;
    }
  }
},
    Pagination = {
  render: function () {
    var e,
        t,
        n,
        i,
        s = this,
        a = s.$createElement,
        r = s._self._c || a;
    return s.state ? r("div", {
      class: s.suit()
    }, [s._t("default", [r("ul", {
      class: s.suit("list")
    }, [s.showFirst ? r("li", {
      class: (e = {}, e[s.suit("item")] = !0, e[s.suit("item", "firstPage")] = !0, e[s.suit("item", "disabled")] = s.state.isFirstPage, e)
    }, [s._t("first", [s.state.isFirstPage ? [r("span", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "First"
      }
    }, [s._v("‹‹")])] : [r("a", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "First",
        href: s.state.createURL(0)
      },
      on: {
        click: function (e) {
          e.preventDefault(), s.refine(0);
        }
      }
    }, [s._v("‹‹")])]], {
      createURL: function () {
        return s.state.createURL(0);
      },
      isFirstPage: s.state.isFirstPage,
      refine: function () {
        return s.refine(0);
      }
    })], 2) : s._e(), s._v(" "), s.showPrevious ? r("li", {
      class: (t = {}, t[s.suit("item")] = !0, t[s.suit("item", "previousPage")] = !0, t[s.suit("item", "disabled")] = s.state.isFirstPage, t)
    }, [s._t("previous", [s.state.isFirstPage ? [r("span", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Previous"
      }
    }, [s._v("‹")])] : [r("a", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Previous",
        href: s.state.createURL(s.state.currentRefinement - 1)
      },
      on: {
        click: function (e) {
          e.preventDefault(), s.refine(s.state.currentRefinement - 1);
        }
      }
    }, [s._v("‹")])]], {
      createURL: function () {
        return s.state.createURL(s.state.currentRefinement - 1);
      },
      isFirstPage: s.state.isFirstPage,
      refine: function () {
        return s.refine(s.state.currentRefinement - 1);
      }
    })], 2) : s._e(), s._v(" "), s._l(s.state.pages, function (e) {
      var t;
      return r("li", {
        key: e,
        class: (t = {}, t[s.suit("item")] = !0, t[s.suit("item", "selected")] = s.state.currentRefinement === e, t)
      }, [s._t("item", [r("a", {
        class: s.suit("link"),
        attrs: {
          href: s.state.createURL(e)
        },
        on: {
          click: function (t) {
            t.preventDefault(), s.refine(e);
          }
        }
      }, [s._v(s._s(e + 1))])], {
        page: e,
        createURL: function () {
          return s.state.createURL(e);
        },
        isFirstPage: s.state.isFirstPage,
        isLastPage: s.state.isLastPage,
        refine: function () {
          return s.refine(e);
        }
      })], 2);
    }), s._v(" "), s.showNext ? r("li", {
      class: (n = {}, n[s.suit("item")] = !0, n[s.suit("item", "nextPage")] = !0, n[s.suit("item", "disabled")] = s.state.isLastPage, n)
    }, [s._t("next", [s.state.isLastPage ? [r("span", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Next"
      }
    }, [s._v("›")])] : [r("a", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Next",
        href: s.state.createURL(s.state.currentRefinement + 1)
      },
      on: {
        click: function (e) {
          e.preventDefault(), s.refine(s.state.currentRefinement + 1);
        }
      }
    }, [s._v("›")])]], {
      createURL: function () {
        return s.state.createURL(s.state.currentRefinement + 1);
      },
      isLastPage: s.state.isLastPage,
      refine: function () {
        return s.refine(s.state.currentRefinement + 1);
      }
    })], 2) : s._e(), s._v(" "), s.showLast ? r("li", {
      class: (i = {}, i[s.suit("item")] = !0, i[s.suit("item", "lastPage")] = !0, i[s.suit("item", "disabled")] = s.state.isLastPage, i)
    }, [s._t("last", [s.state.isLastPage ? [r("span", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Last"
      }
    }, [s._v("››")])] : [r("a", {
      class: s.suit("link"),
      attrs: {
        "aria-label": "Last",
        href: s.state.createURL(s.state.nbPages - 1)
      },
      on: {
        click: function (e) {
          e.preventDefault(), s.refine(s.state.nbPages - 1);
        }
      }
    }, [s._v("››")])]], {
      createURL: function () {
        return s.state.createURL(s.state.nbPages - 1);
      },
      isLastPage: s.state.isLastPage,
      refine: function () {
        return s.refine(s.state.nbPages - 1);
      }
    })], 2) : s._e()], 2)], {
      refine: s.refine,
      createURL: s.state.createURL,
      currentRefinement: s.state.currentRefinement,
      nbHits: s.state.nbHits,
      nbPages: s.state.nbPages,
      pages: s.state.pages,
      isFirstPage: s.state.isFirstPage,
      isLastPage: s.state.isLastPage
    })], 2) : s._e();
  },
  staticRenderFns: [],
  name: "AisPagination",
  mixins: [createSuitMixin({
    name: "Pagination"
  }), createWidgetMixin({
    connector: connectors.connectPagination
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return e.nbPages > 1;
    }
  })],
  props: {
    padding: {
      type: Number,
      default: 3,
      validator: function (e) {
        return e > 0;
      }
    },
    totalPages: {
      type: Number,
      default: void 0,
      validator: function (e) {
        return e > 0;
      }
    },
    showFirst: {
      type: Boolean,
      default: !0
    },
    showLast: {
      type: Boolean,
      default: !0
    },
    showNext: {
      type: Boolean,
      default: !0
    },
    showPrevious: {
      type: Boolean,
      default: !0
    }
  },
  computed: {
    widgetParams: function () {
      return {
        padding: this.padding,
        totalPages: this.totalPages
      };
    }
  },
  methods: {
    refine: function (e) {
      var t = Math.min(Math.max(e, 0), this.state.nbPages - 1);
      this.state.refine(t), this.$emit("page-change", t);
    }
  }
},
    Panel = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return n("div", {
      class: [e.suit(), !e.canRefine && e.suit("", "noRefinement")]
    }, [e.$slots.header || e.$scopedSlots.header ? n("div", {
      class: e.suit("header")
    }, [e._t("header", null, {
      hasRefinements: e.canRefine
    })], 2) : e._e(), e._v(" "), n("div", {
      class: e.suit("body")
    }, [e._t("default", null, {
      hasRefinements: e.canRefine
    })], 2), e._v(" "), e.$slots.footer || e.$scopedSlots.footer ? n("div", {
      class: e.suit("footer")
    }, [e._t("footer", null, {
      hasRefinements: e.canRefine
    })], 2) : e._e()]);
  },
  staticRenderFns: [],
  name: "AisPanel",
  mixins: [createSuitMixin({
    name: "Panel"
  }), createPanelProviderMixin()]
},
    PoweredBy = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return n("div", {
      class: e.suit()
    }, [n("a", {
      class: e.suit("link"),
      attrs: {
        href: e.algoliaUrl,
        target: "_blank",
        rel: "noopener",
        "aria-label": "search by Algolia"
      }
    }, [n("svg", {
      class: [e.suit("logo"), e.suit("", e.theme)],
      staticStyle: {
        height: "1.2em",
        width: "auto"
      },
      attrs: {
        viewBox: "0 0 168 24"
      }
    }, [n("path", {
      attrs: {
        fill: "dark" === e.theme ? "#FFF" : "#5D6494",
        d: "M6.97 6.68V8.3a4.47 4.47 0 0 0-2.42-.67 2.2 2.2 0 0 0-1.38.4c-.34.26-.5.6-.5 1.02 0 .43.16.77.49 1.03.33.25.83.53 1.51.83a7.04 7.04 0 0 1 1.9 1.08c.34.24.58.54.73.89.15.34.23.74.23 1.18 0 .95-.33 1.7-1 2.24a4 4 0 0 1-2.6.81 5.71 5.71 0 0 1-2.94-.68v-1.71c.84.63 1.81.94 2.92.94.58 0 1.05-.14 1.39-.4.34-.28.5-.65.5-1.13 0-.29-.1-.55-.3-.8a2.2 2.2 0 0 0-.65-.53 23.03 23.03 0 0 0-1.64-.78 13.67 13.67 0 0 1-1.11-.64c-.12-.1-.28-.22-.46-.4a1.72 1.72 0 0 1-.39-.5 4.46 4.46 0 0 1-.22-.6c-.07-.23-.1-.48-.1-.75 0-.91.33-1.63 1-2.17a4 4 0 0 1 2.57-.8c.97 0 1.8.18 2.47.52zm7.47 5.7v-.3a2.26 2.26 0 0 0-.5-1.44c-.3-.35-.74-.53-1.32-.53-.53 0-.99.2-1.37.58-.38.39-.62.95-.72 1.68h3.91zm1 2.79v1.4c-.6.34-1.38.51-2.36.51a4.02 4.02 0 0 1-3-1.13 4.04 4.04 0 0 1-1.11-2.97c0-1.3.34-2.32 1.02-3.06a3.38 3.38 0 0 1 2.6-1.1c1.03 0 1.85.32 2.46.96.6.64.9 1.57.9 2.78 0 .33-.03.68-.09 1.04h-5.31c.1.7.4 1.24.89 1.61.49.38 1.1.56 1.85.56.86 0 1.58-.2 2.15-.6zm6.61-1.78h-1.21c-.6 0-1.05.12-1.35.36-.3.23-.46.53-.46.89 0 .37.12.66.36.88.23.2.57.32 1.02.32.5 0 .9-.15 1.2-.43.3-.28.44-.65.44-1.1v-.92zm-4.07-2.55V9.33a4.96 4.96 0 0 1 2.5-.55c2.1 0 3.17 1.03 3.17 3.08V17H22.1v-.96c-.42.68-1.15 1.02-2.19 1.02-.76 0-1.38-.22-1.84-.66-.46-.44-.7-1-.7-1.68 0-.78.3-1.38.88-1.81.59-.43 1.4-.65 2.46-.65h1.34v-.46c0-.55-.13-.97-.4-1.25-.26-.29-.7-.43-1.32-.43-.86 0-1.65.24-2.35.72zm9.34-1.93v1.42c.39-1 1.1-1.5 2.12-1.5.15 0 .31.02.5.05v1.53c-.23-.1-.48-.14-.76-.14-.54 0-.99.24-1.34.71a2.8 2.8 0 0 0-.52 1.71V17h-1.57V8.91h1.57zm5 4.09a3 3 0 0 0 .76 2.01c.47.53 1.14.8 2 .8.64 0 1.24-.18 1.8-.53v1.4c-.53.32-1.2.48-2 .48a3.98 3.98 0 0 1-4.17-4.18c0-1.16.38-2.15 1.14-2.98a4 4 0 0 1 3.1-1.23c.7 0 1.34.15 1.92.44v1.44a3.24 3.24 0 0 0-1.77-.5A2.65 2.65 0 0 0 32.33 13zm7.92-7.28v4.58c.46-1 1.3-1.5 2.5-1.5.8 0 1.42.24 1.9.73.48.5.72 1.17.72 2.05V17H43.8v-5.1c0-.56-.14-.99-.43-1.29-.28-.3-.65-.45-1.1-.45-.54 0-1 .2-1.42.6-.4.4-.61 1.02-.61 1.85V17h-1.56V5.72h1.56zM55.2 15.74c.6 0 1.1-.25 1.5-.76.4-.5.6-1.16.6-1.95 0-.92-.2-1.62-.6-2.12-.4-.5-.92-.74-1.55-.74-.56 0-1.05.22-1.5.67-.44.45-.66 1.13-.66 2.06 0 .96.22 1.67.64 2.14.43.47.95.7 1.57.7zM53 5.72v4.42a2.74 2.74 0 0 1 2.43-1.34c1.03 0 1.86.38 2.51 1.15.65.76.97 1.78.97 3.05 0 1.13-.3 2.1-.92 2.9-.62.81-1.47 1.21-2.54 1.21s-1.9-.45-2.46-1.34V17h-1.58V5.72H53zm9.9 11.1l-3.22-7.9h1.74l1 2.62 1.26 3.42c.1-.32.48-1.46 1.15-3.42l.91-2.63h1.66l-2.92 7.87c-.78 2.07-1.96 3.1-3.56 3.1-.28 0-.53-.02-.73-.07v-1.34c.17.04.35.06.54.06 1.03 0 1.76-.57 2.17-1.7z"
      }
    }), e._v(" "), n("path", {
      attrs: {
        fill: "#5468FF",
        d: "M78.99.94h16.6a2.97 2.97 0 0 1 2.96 2.96v16.6a2.97 2.97 0 0 1-2.97 2.96h-16.6a2.97 2.97 0 0 1-2.96-2.96V3.9A2.96 2.96 0 0 1 79 .94"
      }
    }), e._v(" "), n("path", {
      attrs: {
        fill: "#FFF",
        d: "M89.63 5.97v-.78a.98.98 0 0 0-.98-.97h-2.28a.98.98 0 0 0-.97.97V6c0 .09.08.15.17.13a7.13 7.13 0 0 1 3.9-.02c.08.02.16-.04.16-.13m-6.25 1L83 6.6a.98.98 0 0 0-1.38 0l-.46.46a.97.97 0 0 0 0 1.38l.38.39c.06.06.15.04.2-.02a7.49 7.49 0 0 1 1.63-1.62c.07-.04.08-.14.02-.2m4.16 2.45v3.34c0 .1.1.17.2.12l2.97-1.54c.06-.03.08-.12.05-.18a3.7 3.7 0 0 0-3.08-1.87c-.07 0-.14.06-.14.13m0 8.05a4.49 4.49 0 1 1 0-8.98 4.49 4.49 0 0 1 0 8.98m0-10.85a6.37 6.37 0 1 0 0 12.74 6.37 6.37 0 0 0 0-12.74"
      }
    }), e._v(" "), n("path", {
      attrs: {
        fill: "dark" === e.theme ? "#FFF" : "#5468FF",
        d: "M120.92 18.8c-4.38.02-4.38-3.54-4.38-4.1V1.36l2.67-.42v13.25c0 .32 0 2.36 1.71 2.37v2.24zm-10.84-2.18c.82 0 1.43-.04 1.85-.12v-2.72a5.48 5.48 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.11-.44.28-.58.49a.93.93 0 0 0-.22.65c0 .63.22 1 .61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.62.11 2.23.33.6.22 1.09.53 1.44.92.36.4.61.92.76 1.48.16.56.23 1.17.23 1.85v6.87c-.4.1-1.03.2-1.86.32-.84.12-1.78.18-2.82.18-.69 0-1.32-.07-1.9-.2a4 4 0 0 1-1.46-.63c-.4-.3-.72-.67-.96-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.39-1.53.26-.45.6-.82 1.04-1.1.45-.3.95-.5 1.54-.62a8.8 8.8 0 0 1 3.79.05v-.44c0-.3-.04-.6-.11-.87a1.78 1.78 0 0 0-1.1-1.22c-.31-.12-.7-.2-1.15-.2a9.75 9.75 0 0 0-2.95.46l-.33-2.19c.34-.12.84-.23 1.48-.35.65-.12 1.34-.18 2.08-.18zm52.84 9.63c.82 0 1.43-.05 1.85-.13V13.7a5.42 5.42 0 0 0-1.57-.2c-.3 0-.6.02-.9.07-.3.04-.57.12-.81.24-.24.12-.44.28-.58.5a.93.93 0 0 0-.22.65c0 .63.22.99.61 1.23.4.24.94.36 1.62.36zm-.23-9.7c.88 0 1.63.11 2.23.33.6.22 1.1.53 1.45.92.35.39.6.92.76 1.48.15.56.23 1.18.23 1.85v6.88c-.41.08-1.03.19-1.87.31-.83.12-1.77.18-2.81.18-.7 0-1.33-.06-1.9-.2a4 4 0 0 1-1.47-.63c-.4-.3-.72-.67-.95-1.13a4.3 4.3 0 0 1-.34-1.8c0-.66.13-1.08.38-1.53.26-.45.61-.82 1.05-1.1.44-.3.95-.5 1.53-.62a8.8 8.8 0 0 1 3.8.05v-.43c0-.31-.04-.6-.12-.88-.07-.28-.2-.52-.38-.73a1.78 1.78 0 0 0-.73-.5c-.3-.1-.68-.2-1.14-.2a9.85 9.85 0 0 0-2.95.47l-.32-2.19a11.63 11.63 0 0 1 3.55-.53zm-8.03-1.27a1.62 1.62 0 0 0 0-3.24 1.62 1.62 0 1 0 0 3.24zm1.35 13.22h-2.7V7.27l2.7-.42V18.8zm-4.72 0c-4.38.02-4.38-3.54-4.38-4.1l-.01-13.34 2.67-.42v13.25c0 .32 0 2.36 1.72 2.37v2.24zm-8.7-5.9a4.7 4.7 0 0 0-.74-2.79 2.4 2.4 0 0 0-2.07-1 2.4 2.4 0 0 0-2.06 1 4.7 4.7 0 0 0-.74 2.8c0 1.16.25 1.94.74 2.62a2.4 2.4 0 0 0 2.07 1.02c.88 0 1.57-.34 2.07-1.02.49-.68.73-1.46.73-2.63zm2.74 0a6.46 6.46 0 0 1-1.52 4.23c-.49.53-1.07.94-1.76 1.22-.68.29-1.73.45-2.26.45-.53 0-1.58-.15-2.25-.45a5.1 5.1 0 0 1-2.88-3.13 7.3 7.3 0 0 1-.01-4.84 5.13 5.13 0 0 1 2.9-3.1 5.67 5.67 0 0 1 2.22-.42c.81 0 1.56.14 2.24.42.69.29 1.28.69 1.75 1.22.49.52.87 1.15 1.14 1.89a7 7 0 0 1 .43 2.5zm-20.14 0c0 1.11.25 2.36.74 2.88.5.52 1.13.78 1.91.78a4.07 4.07 0 0 0 2.12-.6V9.33c-.19-.04-.99-.2-1.76-.23a2.67 2.67 0 0 0-2.23 1 4.73 4.73 0 0 0-.78 2.8zm7.44 5.27c0 1.82-.46 3.16-1.4 4-.94.85-2.37 1.27-4.3 1.27-.7 0-2.17-.13-3.34-.4l.43-2.11c.98.2 2.27.26 2.95.26 1.08 0 1.84-.22 2.3-.66.46-.43.68-1.08.68-1.94v-.44a5.2 5.2 0 0 1-2.54.6 5.6 5.6 0 0 1-2.01-.36 4.2 4.2 0 0 1-2.58-2.71 9.88 9.88 0 0 1 .02-5.35 4.92 4.92 0 0 1 2.93-2.96 6.6 6.6 0 0 1 2.43-.46 19.64 19.64 0 0 1 4.43.66v10.6z"
      }
    })])])]);
  },
  staticRenderFns: [],
  name: "AisPoweredBy",
  mixins: [createSuitMixin({
    name: "PoweredBy"
  })],
  props: {
    theme: {
      default: "light",
      validator: function (e) {
        return -1 !== ["light", "dark"].indexOf(e);
      }
    }
  },
  computed: {
    algoliaUrl: function () {
      return "https://www.algolia.com/?utm_source=vue-instantsearch&utm_medium=website&utm_content=" + (location ? location.hostname : "") + "&utm_campaign=poweredby";
    }
  }
},
    QueryRuleContext = {
  name: "AisQueryRuleContext",
  mixins: [createSuitMixin({
    name: "QueryRuleContext"
  }), createWidgetMixin({
    connector: connectors.connectQueryRules
  })],
  props: {
    trackedFilters: {
      type: Object,
      required: !0
    },
    transformRuleContexts: {
      type: Function,
      required: !1,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        trackedFilters: this.trackedFilters,
        transformRuleContexts: this.transformRuleContexts
      };
    }
  },
  render: function () {
    return null;
  }
},
    QueryRuleCustomData = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", e._l(e.state.items, function (t, i) {
      return n("div", {
        key: i
      }, [e._t("item", [n("pre", [e._v(e._s(t))])], {
        item: t
      })], 2);
    }), {
      items: e.state.items
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisQueryRuleCustomData",
  mixins: [createSuitMixin({
    name: "QueryRuleCustomData"
  }), createWidgetMixin({
    connector: connectors.connectQueryRules
  })],
  props: {
    transformItems: {
      type: Function,
      required: !1,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        transformItems: this.transformItems
      };
    }
  }
},
    mapStateToCanRefine$1 = function (e) {
  return e && Boolean(e.range) && e.range.min !== e.range.max;
},
    RangeInput = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("form", {
      class: e.suit("form"),
      on: {
        submit: function (t) {
          t.preventDefault(), e.refine({
            min: e.pick(e.minInput, e.values.min),
            max: e.pick(e.maxInput, e.values.max)
          });
        }
      }
    }, [n("label", {
      class: e.suit("label")
    }, [e._t("minLabel"), e._v(" "), n("input", {
      class: [e.suit("input"), e.suit("input", "min")],
      attrs: {
        type: "number",
        step: e.step,
        min: e.state.range.min,
        max: e.state.range.max,
        placeholder: e.state.range.min
      },
      domProps: {
        value: e.values.min
      },
      on: {
        change: function (t) {
          e.minInput = t.currentTarget.value;
        }
      }
    })], 2), e._v(" "), n("span", {
      class: e.suit("separator")
    }, [e._t("separator", [e._v("to")])], 2), e._v(" "), n("label", {
      class: e.suit("label")
    }, [e._t("maxLabel"), e._v(" "), n("input", {
      class: [e.suit("input"), e.suit("input", "max")],
      attrs: {
        type: "number",
        step: e.step,
        min: e.state.range.min,
        max: e.state.range.max,
        placeholder: e.state.range.max
      },
      domProps: {
        value: e.values.max
      },
      on: {
        change: function (t) {
          e.maxInput = t.currentTarget.value;
        }
      }
    })], 2), e._v(" "), n("button", {
      class: e.suit("submit"),
      attrs: {
        type: "submit"
      }
    }, [e._t("submitLabel", [e._v("Go")])], 2)])], {
      currentRefinement: e.values,
      refine: e.refine,
      canRefine: e.canRefine,
      range: e.state.range
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisRangeInput",
  mixins: [createSuitMixin({
    name: "RangeInput"
  }), createWidgetMixin({
    connector: connectors.connectRange
  }), createPanelConsumerMixin({
    mapStateToCanRefine: mapStateToCanRefine$1
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    min: {
      type: Number,
      required: !1,
      default: -1 / 0
    },
    max: {
      type: Number,
      required: !1,
      default: 1 / 0
    },
    precision: {
      type: Number,
      required: !1,
      default: 0
    }
  },
  data: function () {
    return {
      minInput: void 0,
      maxInput: void 0
    };
  },
  updated: function () {
    this.minInput = void 0, this.maxInput = void 0;
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        min: this.min,
        max: this.max,
        precision: this.precision
      };
    },
    canRefine: function () {
      return mapStateToCanRefine$1(this.state);
    },
    step: function () {
      return 1 / Math.pow(10, this.precision);
    },
    values: function () {
      var e = this.state.start,
          t = e[0],
          n = e[1],
          i = this.state.range,
          s = i.min,
          a = i.max;
      return {
        min: t !== -1 / 0 && t !== s ? t : void 0,
        max: n !== 1 / 0 && n !== a ? n : void 0
      };
    }
  },
  methods: {
    pick: function (e, t) {
      return null != e ? e : t;
    },
    refine: function (e) {
      var t = e.min,
          n = e.max;
      this.state.refine([t, n]);
    }
  }
},
    RatingMenu = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("svg", {
      staticStyle: {
        display: "none"
      },
      attrs: {
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [n("symbol", {
      attrs: {
        id: "ais-RatingMenu-starSymbol",
        viewBox: "0 0 24 24"
      }
    }, [n("path", {
      attrs: {
        d: "M12 .288l2.833 8.718h9.167l-7.417 5.389 2.833 8.718-7.416-5.388-7.417 5.388 2.833-8.718-7.416-5.389h9.167z"
      }
    })]), e._v(" "), n("symbol", {
      attrs: {
        id: "ais-RatingMenu-starEmptySymbol",
        viewBox: "0 0 24 24"
      }
    }, [n("path", {
      attrs: {
        d: "M12 6.76l1.379 4.246h4.465l-3.612 2.625 1.379 4.246-3.611-2.625-3.612 2.625 1.379-4.246-3.612-2.625h4.465l1.38-4.246zm0-6.472l-2.833 8.718h-9.167l7.416 5.389-2.833 8.718 7.417-5.388 7.416 5.388-2.833-8.718 7.417-5.389h-9.167l-2.833-8.718z"
      }
    })])]), e._v(" "), n("ul", {
      class: e.suit("list")
    }, e._l(e.state.items, function (t, i) {
      return n("li", {
        key: i,
        class: [e.suit("item"), t.isRefined && e.suit("item", "selected")]
      }, [n("a", {
        class: e.suit("link"),
        attrs: {
          href: e.state.createURL(t),
          "aria-label": t.value + " & Up"
        },
        on: {
          click: function (n) {
            n.preventDefault(), e.state.refine(t.value);
          }
        }
      }, [e._l(t.stars, function (t, i) {
        return [t ? n("svg", {
          key: i + "-full",
          class: [e.suit("starIcon"), e.suit("starIcon--full")],
          attrs: {
            "aria-hidden": "true",
            width: "24",
            height: "24"
          }
        }, [n("use", {
          attrs: {
            "xlink:href": "#ais-RatingMenu-starSymbol"
          }
        })]) : n("svg", {
          key: i + "-empty",
          class: [e.suit("starIcon"), e.suit("starIcon--empty")],
          attrs: {
            "aria-hidden": "true",
            width: "24",
            height: "24"
          }
        }, [n("use", {
          attrs: {
            "xlink:href": "#ais-RatingMenu-starEmptySymbol"
          }
        })])];
      }), e._v(" "), n("span", {
        class: e.suit("label"),
        attrs: {
          "aria-hidden": "true"
        }
      }, [e._t("andUp", [e._v("& Up")])], 2), e._v(" "), n("span", {
        class: e.suit("count")
      }, [e._v(e._s(t.count))])], 2)]);
    }))], {
      items: e.state.items,
      refine: e.state.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisRatingMenu",
  mixins: [createSuitMixin({
    name: "RatingMenu"
  }), createWidgetMixin({
    connector: connectors.connectRatingMenu
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return !1 === e.hasNoResults;
    }
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    max: {
      type: Number,
      default: 5
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        max: this.max
      };
    }
  }
},
    SearchInput = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return n("form", {
      class: e.suit("form"),
      attrs: {
        action: "",
        role: "search",
        novalidate: ""
      },
      on: {
        submit: function (t) {
          return t.preventDefault(), e.onFormSubmit(t);
        },
        reset: function (t) {
          return t.preventDefault(), e.onFormReset(t);
        }
      }
    }, [n("input", {
      ref: "input",
      class: e.suit("input"),
      attrs: {
        type: "search",
        autocorrect: "off",
        autocapitalize: "off",
        autocomplete: "off",
        spellcheck: "false",
        required: "",
        maxlength: "512",
        "aria-label": "Search",
        placeholder: e.placeholder,
        autofocus: e.autofocus
      },
      domProps: {
        value: e.value
      },
      on: {
        focus: function (t) {
          e.$emit("focus", t);
        },
        blur: function (t) {
          e.$emit("blur", t);
        },
        input: function (t) {
          e.$emit("input", t.target.value);
        }
      }
    }), e._v(" "), n("button", {
      class: e.suit("submit"),
      attrs: {
        type: "submit",
        title: e.submitTitle,
        hidden: e.showLoadingIndicator && e.shouldShowLoadingIndicator
      }
    }, [e._t("submit-icon", [n("svg", {
      class: e.suit("submitIcon"),
      attrs: {
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        width: "10",
        height: "10",
        viewBox: "0 0 40 40"
      }
    }, [n("path", {
      attrs: {
        d: "M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z",
        fillRule: "evenodd"
      }
    })])])], 2), e._v(" "), n("button", {
      class: e.suit("reset"),
      attrs: {
        type: "reset",
        title: e.resetTitle,
        hidden: !e.value || e.showLoadingIndicator && e.shouldShowLoadingIndicator
      }
    }, [e._t("reset-icon", [n("svg", {
      class: e.suit("resetIcon"),
      attrs: {
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        viewBox: "0 0 20 20"
      }
    }, [n("path", {
      attrs: {
        d: "M8.114 10L.944 2.83 0 1.885 1.886 0l.943.943L10 8.113l7.17-7.17.944-.943L20 1.886l-.943.943-7.17 7.17 7.17 7.17.943.944L18.114 20l-.943-.943-7.17-7.17-7.17 7.17-.944.943L0 18.114l.943-.943L8.113 10z",
        fillRule: "evenodd"
      }
    })])])], 2), e._v(" "), e.showLoadingIndicator ? n("span", {
      class: e.suit("loadingIndicator"),
      attrs: {
        hidden: !e.shouldShowLoadingIndicator
      }
    }, [e._t("loading-indicator", [n("svg", {
      class: e.suit("loadingIcon"),
      attrs: {
        role: "img",
        "aria-label": "Results are loading",
        width: "16",
        height: "16",
        xmlns: "http://www.w3.org/2000/svg",
        stroke: "#444",
        viewBox: "0 0 38 38"
      }
    }, [n("g", {
      attrs: {
        fill: "none",
        "fill-rule": "evenodd"
      }
    }, [n("g", {
      attrs: {
        transform: "translate(1 1)",
        "stroke-width": "2"
      }
    }, [n("circle", {
      attrs: {
        "stroke-opacity": ".5",
        cx: "18",
        cy: "18",
        r: "18"
      }
    }), e._v(" "), n("path", {
      attrs: {
        d: "M36 18c0-9.94-8.06-18-18-18"
      }
    }, [n("animateTransform", {
      attrs: {
        attributeName: "transform",
        type: "rotate",
        from: "0 18 18",
        to: "360 18 18",
        dur: "1s",
        repeatCount: "indefinite"
      }
    })], 1)])])])])], 2) : e._e()]);
  },
  staticRenderFns: [],
  name: "SearchInput",
  mixins: [createSuitMixin({
    name: "SearchBox"
  })],
  props: {
    placeholder: {
      type: String,
      default: "Search here…"
    },
    autofocus: {
      type: Boolean,
      default: !1
    },
    showLoadingIndicator: {
      type: Boolean,
      default: !1
    },
    shouldShowLoadingIndicator: {
      type: Boolean,
      default: !1
    },
    submitTitle: {
      type: String,
      default: "Search"
    },
    resetTitle: {
      type: String,
      default: "Clear"
    },
    value: {
      type: String,
      required: !0
    }
  },
  data: function () {
    return {
      query: ""
    };
  },
  methods: {
    onFormSubmit: function () {
      this.$refs.input.blur();
    },
    onFormReset: function () {
      this.$emit("input", ""), this.$emit("reset");
    }
  }
},
    noop = function () {},
    RefinementList = {
  render: function () {
    var e,
        t = this,
        n = t.$createElement,
        i = t._self._c || n;
    return t.state ? i("div", {
      class: [t.suit(), !t.state.canRefine && t.suit("", "noRefinement")]
    }, [t._t("default", [t.searchable ? i("div", {
      class: t.suit("searchBox")
    }, [i("search-input", {
      attrs: {
        placeholder: t.searchablePlaceholder,
        "class-names": t.classNames
      },
      model: {
        value: t.searchForFacetValues,
        callback: function (e) {
          t.searchForFacetValues = e;
        },
        expression: "searchForFacetValues"
      }
    })], 1) : t._e(), t._v(" "), t.state.isFromSearch && 0 === t.items.length ? t._t("noResults", [i("div", {
      class: t.suit("noResults")
    }, [t._v("No results.")])], {
      query: t.searchForFacetValues
    }) : t._e(), t._v(" "), i("ul", {
      class: t.suit("list")
    }, t._l(t.items, function (e) {
      return i("li", {
        key: e.value,
        class: [t.suit("item"), e.isRefined && t.suit("item", "selected")]
      }, [t._t("item", [i("label", {
        class: t.suit("label")
      }, [i("input", {
        class: t.suit("checkbox"),
        attrs: {
          type: "checkbox"
        },
        domProps: {
          value: e.value,
          checked: e.isRefined
        },
        on: {
          change: function (n) {
            t.refine(e.value);
          }
        }
      }), t._v(" "), t.searchable ? i("span", {
        class: t.suit("labelText")
      }, [i("ais-highlight", {
        attrs: {
          attribute: "item",
          hit: e
        }
      })], 1) : i("span", {
        class: t.suit("labelText")
      }, [t._v(t._s(e.label))]), t._v(" "), i("span", {
        class: t.suit("count")
      }, [t._v(t._s(e.count))])])], {
        item: e,
        refine: t.refine,
        createURL: t.state.createURL
      })], 2);
    })), t._v(" "), t.showMore ? i("button", {
      class: [t.suit("showMore"), (e = {}, e[t.suit("showMore", "disabled")] = !t.state.canToggleShowMore, e)],
      attrs: {
        disabled: !t.state.canToggleShowMore
      },
      on: {
        click: t.toggleShowMore
      }
    }, [t._t("showMoreLabel", [t._v("Show " + t._s(t.state.isShowingMore ? "less" : "more"))], {
      isShowingMore: t.state.isShowingMore
    })], 2) : t._e()], {
      items: t.items,
      refine: t.refine,
      searchForItems: t.state.searchForItems,
      searchForItemsQuery: t.searchForFacetValuesQuery,
      toggleShowMore: t.toggleShowMore,
      canToggleShowMore: t.state.canToggleShowMore,
      isShowingMore: t.state.isShowingMore,
      createURL: t.state.createURL,
      isFromSearch: t.state.isFromSearch,
      canRefine: t.state.canRefine
    })], 2) : t._e();
  },
  staticRenderFns: [],
  name: "AisRefinementList",
  components: {
    SearchInput: SearchInput,
    AisHighlight: AisHighlight
  },
  mixins: [createSuitMixin({
    name: "RefinementList"
  }), createWidgetMixin({
    connector: connectors.connectRefinementList
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return Boolean(e.canRefine);
    }
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    searchable: {
      type: Boolean,
      default: !1
    },
    searchablePlaceholder: {
      default: "Search here…",
      type: String,
      required: !1
    },
    operator: {
      default: "or",
      validator: function (e) {
        return "and" === e || "or" === e;
      },
      required: !1
    },
    limit: {
      type: Number,
      default: 10,
      required: !1
    },
    showMoreLimit: {
      type: Number,
      default: 20,
      required: !1
    },
    showMore: {
      type: Boolean,
      default: !1,
      required: !1
    },
    sortBy: {
      type: [Array, Function],
      default: function () {
        return ["isRefined", "count:desc", "name:asc"];
      },
      required: !1
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      },
      required: !1
    }
  },
  data: function () {
    return {
      searchForFacetValuesQuery: ""
    };
  },
  computed: {
    searchForFacetValues: {
      get: function () {
        return this.searchForFacetValuesQuery;
      },
      set: function (e) {
        this.state.searchForItems(e), this.searchForFacetValuesQuery = e;
      }
    },
    toggleShowMore: function () {
      return this.state.toggleShowMore || noop;
    },
    items: function () {
      return this.state.items.map(function (e) {
        return Object.assign({}, e, {
          _highlightResult: {
            item: {
              value: e.highlighted
            }
          }
        });
      });
    },
    widgetParams: function () {
      return {
        attribute: this.attribute,
        operator: this.operator,
        limit: this.limit,
        showMore: this.showMore,
        showMoreLimit: this.showMoreLimit,
        sortBy: this.sortBy,
        escapeFacetValues: !0,
        transformItems: this.transformItems
      };
    }
  },
  methods: {
    refine: function (e) {
      this.state.refine(e), this.searchForFacetValuesQuery = "";
    }
  }
},
    connectStateResults = function (e, t) {
  return void 0 === t && (t = function () {}), function (n) {
    return void 0 === n && (n = {}), {
      init: function (t) {
        var i = t.instantSearchInstance;
        e({
          state: void 0,
          results: void 0,
          instantSearchInstance: i,
          widgetParams: n
        }, !0);
      },
      render: function (t) {
        var i = t.results,
            s = t.instantSearchInstance,
            a = t.state,
            r = _objectSpread({}, i),
            o = _objectSpread({}, a);

        e({
          results: r,
          state: o,
          instantSearchInstance: s,
          widgetParams: n
        }, !1);
      },
      dispose: function () {
        t();
      }
    };
  };
},
    StateResults = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state && e.state.state && e.state.results ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("p", [e._v(" Use this component to have a different layout based on a certain state. ")]), e._v(" "), e._m(0), e._v(" "), n("pre", [e._v("results: " + e._s(Object.keys(e.state.results)))]), e._v(" "), n("pre", [e._v("state: " + e._s(Object.keys(e.state.state)))])], null, e.stateResults)], 2) : e._e();
  },
  staticRenderFns: [function () {
    var e = this.$createElement,
        t = this._self._c || e;
    return t("p", [this._v(" Fill in the slot, and get access to the following things on the "), t("code", [this._v("slot-scope")]), this._v(": ")]);
  }],
  name: "AisStateResults",
  mixins: [createWidgetMixin({
    connector: connectStateResults
  }), createSuitMixin({
    name: "StateResults"
  })],
  computed: {
    stateResults: function () {
      var e = this.state,
          t = e.state,
          n = e.results;
      return _objectSpread({}, n, {
        results: n,
        state: t
      });
    }
  }
},
    SearchBox = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("search-input", {
      attrs: {
        placeholder: e.placeholder,
        autofocus: e.autofocus,
        "show-loading-indicator": e.showLoadingIndicator,
        "should-show-loading-indicator": e.state.isSearchStalled,
        "submit-title": e.submitTitle,
        "reset-title": e.resetTitle,
        "class-names": e.classNames
      },
      on: {
        focus: function (t) {
          e.$emit("focus", t);
        },
        blur: function (t) {
          e.$emit("blur", t);
        },
        reset: function (t) {
          e.$emit("reset");
        }
      },
      model: {
        value: e.currentRefinement,
        callback: function (t) {
          e.currentRefinement = t;
        },
        expression: "currentRefinement"
      }
    }, [e._t("loading-indicator", null, {
      slot: "loading-indicator"
    }), e._v(" "), e._t("submit-icon", null, {
      slot: "submit-icon"
    }), e._v(" "), e._t("reset-icon", null, {
      slot: "reset-icon"
    })], 2)], {
      currentRefinement: e.currentRefinement,
      isSearchStalled: e.state.isSearchStalled,
      refine: e.state.refine
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisSearchBox",
  mixins: [createWidgetMixin({
    connector: connectors.connectSearchBox
  }), createSuitMixin({
    name: "SearchBox"
  })],
  components: {
    SearchInput: SearchInput
  },
  props: {
    placeholder: {
      type: String,
      default: "Search here…"
    },
    autofocus: {
      type: Boolean,
      default: !1
    },
    showLoadingIndicator: {
      type: Boolean,
      default: !1
    },
    submitTitle: {
      type: String,
      default: "Search"
    },
    resetTitle: {
      type: String,
      default: "Clear"
    },
    value: {
      type: String,
      default: void 0
    }
  },
  data: function () {
    return {
      localValue: ""
    };
  },
  computed: {
    isControlled: function () {
      return void 0 !== this.value;
    },
    currentRefinement: {
      get: function () {
        return this.isControlled && this.value !== this.localValue && (this.localValue = this.value, this.$emit("input", this.value), this.state.refine(this.value)), this.value || this.state.query || "";
      },
      set: function (e) {
        this.localValue = e, this.state.refine(e), this.isControlled && this.$emit("input", e);
      }
    }
  }
},
    Snippet = {
  render: function () {
    var e = this.$createElement;
    return (this._self._c || e)("ais-highlighter", {
      attrs: {
        hit: this.hit,
        attribute: this.attribute,
        "highlighted-tag-name": this.highlightedTagName,
        suit: this.suit,
        "highlight-property": "_snippetResult",
        "pre-tag": "<mark>",
        "post-tag": "</mark>"
      }
    });
  },
  staticRenderFns: [],
  name: "AisSnippet",
  mixins: [createSuitMixin({
    name: "Snippet"
  })],
  components: {
    AisHighlighter: AisHighlighter
  },
  props: {
    hit: {
      type: Object,
      required: !0
    },
    attribute: {
      type: String,
      required: !0
    },
    highlightedTagName: {
      type: String,
      default: "mark"
    }
  }
},
    SortBy = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("select", {
      class: e.suit("select"),
      on: {
        change: function (t) {
          e.state.refine(t.currentTarget.value);
        }
      }
    }, e._l(e.state.options, function (t) {
      return n("option", {
        key: t.value,
        class: e.suit("option"),
        domProps: {
          value: t.value,
          selected: t.value === e.state.currentRefinement
        }
      }, [e._v(e._s(t.label))]);
    }))], {
      items: e.state.options,
      hasNoResults: e.state.hasNoResults,
      refine: e.state.refine,
      currentRefinement: e.state.currentRefinement
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisSortBy",
  mixins: [createSuitMixin({
    name: "SortBy"
  }), createWidgetMixin({
    connector: connectors.connectSortBy
  }), createPanelConsumerMixin({
    mapStateToCanRefine: function (e) {
      return !1 === e.hasNoResults;
    }
  })],
  props: {
    items: {
      type: Array,
      required: !0
    },
    transformItems: {
      type: Function,
      default: function (e) {
        return e;
      }
    }
  },
  computed: {
    widgetParams: function () {
      return {
        items: this.items,
        transformItems: this.transformItems
      };
    }
  }
},
    Stats = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("span", {
      class: e.suit("text")
    }, [e._v(e._s(e.state.nbHits.toLocaleString()) + " results found in " + e._s(e.state.processingTimeMS.toLocaleString()) + "ms")])], {
      results: e.state.instantSearchInstance.helper.lastResults
    }, e.state)], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisStats",
  mixins: [createWidgetMixin({
    connector: connectors.connectStats
  }), createSuitMixin({
    name: "Stats"
  })],
  computed: {
    widgetParams: function () {
      return {};
    }
  }
},
    mapStateToCanRefine$2 = function (e) {
  return Boolean(e.value && e.value.count);
},
    ToggleRefinement = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: [e.suit(), !e.canRefine && e.suit("", "noRefinement")]
    }, [e._t("default", [n("label", {
      class: e.suit("label")
    }, [n("input", {
      class: e.suit("checkbox"),
      attrs: {
        type: "checkbox",
        name: e.state.value.name
      },
      domProps: {
        value: e.on,
        checked: e.state.value.isRefined
      },
      on: {
        change: function (t) {
          e.state.refine(e.state.value);
        }
      }
    }), e._v(" "), n("span", {
      class: e.suit("labelText")
    }, [e._v(e._s(e.label))]), e._v(" "), null !== e.state.value.count ? n("span", {
      class: e.suit("count")
    }, [e._v(e._s(e.state.value.count.toLocaleString()))]) : e._e()])], {
      value: e.state.value,
      canRefine: e.canRefine,
      refine: e.state.refine,
      createURL: e.state.createURL
    })], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisToggleRefinement",
  mixins: [createSuitMixin({
    name: "ToggleRefinement"
  }), createWidgetMixin({
    connector: connectors.connectToggleRefinement
  }), createPanelConsumerMixin({
    mapStateToCanRefine: mapStateToCanRefine$2
  })],
  props: {
    attribute: {
      type: String,
      required: !0
    },
    label: {
      type: String,
      required: !0
    },
    on: {
      type: [String, Number, Boolean, Array],
      required: !1,
      default: !0
    },
    off: {
      type: [String, Number, Boolean, Array],
      required: !1,
      default: void 0
    }
  },
  computed: {
    widgetParams: function () {
      return {
        attribute: this.attribute,
        label: this.label,
        on: this.on,
        off: this.off
      };
    },
    canRefine: function () {
      return mapStateToCanRefine$2(this.state);
    }
  }
},
    VoiceSearch = {
  render: function () {
    var e = this,
        t = e.$createElement,
        n = e._self._c || t;
    return e.state ? n("div", {
      class: e.suit()
    }, [e._t("default", [n("button", {
      class: e.suit("button"),
      attrs: {
        type: "button",
        title: e.state.isBrowserSupported ? e.buttonTitle : e.disabledButtonTitle,
        disabled: !e.state.isBrowserSupported
      },
      on: {
        click: e.handleClick
      }
    }, [e._t("buttonText", [e.errorNotAllowed ? n("svg", e._b({}, "svg", e.buttonSvgAttrs, !1), [n("line", {
      attrs: {
        x1: "1",
        y1: "1",
        x2: "23",
        y2: "23"
      }
    }), e._v(" "), n("path", {
      attrs: {
        d: "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"
      }
    }), e._v(" "), n("path", {
      attrs: {
        d: "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"
      }
    }), e._v(" "), n("line", {
      attrs: {
        x1: "12",
        y1: "19",
        x2: "12",
        y2: "23"
      }
    }), e._v(" "), n("line", {
      attrs: {
        x1: "8",
        y1: "23",
        x2: "16",
        y2: "23"
      }
    })]) : n("svg", e._b({}, "svg", e.buttonSvgAttrs, !1), [n("path", {
      attrs: {
        d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z",
        fill: e.state.isListening ? "currentColor" : "none"
      }
    }), e._v(" "), n("path", {
      attrs: {
        d: "M19 10v2a7 7 0 0 1-14 0v-2"
      }
    }), e._v(" "), n("line", {
      attrs: {
        x1: "12",
        y1: "19",
        x2: "12",
        y2: "23"
      }
    }), e._v(" "), n("line", {
      attrs: {
        x1: "8",
        y1: "23",
        x2: "16",
        y2: "23"
      }
    })])], null, e.innerSlotProps)], 2), e._v(" "), n("div", {
      class: e.suit("status")
    }, [e._t("status", [n("p", [e._v(e._s(e.state.voiceListeningState.transcript))])], null, e.innerSlotProps)], 2)], null, e.rootSlotProps)], 2) : e._e();
  },
  staticRenderFns: [],
  name: "AisVoiceSearch",
  mixins: [createWidgetMixin({
    connector: connectors.connectVoiceSearch
  }), createSuitMixin({
    name: "VoiceSearch"
  })],
  props: {
    searchAsYouSpeak: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    buttonTitle: {
      type: String,
      required: !1,
      default: "Search by voice"
    },
    disabledButtonTitle: {
      type: String,
      required: !1,
      default: "Search by voice (not supported on this browser)"
    }
  },
  data: function () {
    return {
      buttonSvgAttrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    };
  },
  computed: {
    widgetParams: function () {
      return {
        searchAsYouSpeak: this.searchAsYouSpeak
      };
    },
    errorNotAllowed: function () {
      return "error" === this.state.voiceListeningState.status && "not-allowed" === this.state.voiceListeningState.errorCode;
    },
    rootSlotProps: function () {
      return {
        isBrowserSupported: this.state.isBrowserSupported,
        isListening: this.state.isListening,
        toggleListening: this.state.toggleListening,
        voiceListeningState: this.state.voiceListeningState
      };
    },
    innerSlotProps: function () {
      return {
        status: this.state.voiceListeningState.status,
        errorCode: this.state.voiceListeningState.errorCode,
        isListening: this.state.isListening,
        transcript: this.state.voiceListeningState.transcript,
        isSpeechFinal: this.state.voiceListeningState.isSpeechFinal,
        isBrowserSupported: this.state.isBrowserSupported
      };
    }
  },
  methods: {
    handleClick: function (e) {
      e.currentTarget.blur(), this.state.toggleListening();
    }
  }
},
    widgets = Object.freeze({
  __proto__: null,
  AisAutocomplete: Autocomplete,
  AisBreadcrumb: Breadcrumb,
  AisClearRefinements: ClearRefinements,
  AisConfigure: Configure,
  AisExperimentalConfigureRelatedItems: ConfigureRelatedItems,
  AisCurrentRefinements: CurrentRefinements,
  AisHierarchicalMenu: HierarchicalMenu,
  AisHighlight: AisHighlight,
  AisHits: Hits,
  AisHitsPerPage: HitsPerPage,
  AisIndex: Index,
  AisInstantSearch: InstantSearch,
  AisInstantSearchSsr: InstantSearchSsr,
  AisInfiniteHits: InfiniteHits,
  AisMenu: Menu,
  AisMenuSelect: MenuSelect,
  AisNumericMenu: NumericMenu,
  AisPagination: Pagination,
  AisPanel: Panel,
  AisPoweredBy: PoweredBy,
  AisQueryRuleContext: QueryRuleContext,
  AisQueryRuleCustomData: QueryRuleCustomData,
  AisRangeInput: RangeInput,
  AisRatingMenu: RatingMenu,
  AisRefinementList: RefinementList,
  AisStateResults: StateResults,
  AisSearchBox: SearchBox,
  AisSnippet: Snippet,
  AisSortBy: SortBy,
  AisStats: Stats,
  AisToggleRefinement: ToggleRefinement,
  AisVoiceSearch: VoiceSearch
}),
    plugin = {
  install: function (e) {
    Object.keys(widgets).forEach(function (t) {
      e.component(widgets[t].name, widgets[t]);
    });
  }
},
    SearchResults = algoliaHelper.SearchResults,
    SearchParameters = algoliaHelper.SearchParameters;

function walkIndex(e, t) {
  return t(e), e.getWidgets().forEach(function (e) {
    "ais.index" === e.$$type && (t(e), walkIndex(e, t));
  });
}

function renderToString(e, t) {
  return new Promise(function (n, i) {
    return t(e, function (e, t) {
      e && i(e), n(t);
    });
  });
}

function searchOnlyWithDerivedHelpers(e) {
  return new Promise(function (t, n) {
    e.searchOnlyWithDerivedHelpers(), e.derivedHelpers[0].on("result", function () {
      t();
    }), e.derivedHelpers.forEach(function (e) {
      return e.on("error", function (e) {
        n(e);
      });
    });
  });
}

function augmentInstantSearch(e, t, n) {
  var i,
      s = algoliaHelper(t, n),
      a = instantsearch(e);
  return a.findResultsState = function (e) {
    var t, n;

    try {
      t = __webpack_require__(76);
    } catch (e) {}

    if (!t) throw new Error("you need to install vue-server-renderer");
    return Promise.resolve().then(function () {
      var t = {
        serverPrefetch: void 0,
        fetch: void 0,
        _base: void 0,
        name: "ais-ssr-root-component",
        router: e.$router,
        store: e.$store
      },
          i = e.$vnode ? e.$vnode.componentOptions.Ctor.extend(t) : Vue.component(Object.assign({}, e.$options, t));
      (n = new i({
        propsData: e.$options.propsData
      })).$slots = e.$slots, n.$root = e.$root, n.$options.serverPrefetch = [], n.instantsearch.helper = s, n.instantsearch.mainHelper = s, n.instantsearch.mainIndex.init({
        instantSearchInstance: n.instantsearch,
        parent: null,
        uiState: n.instantsearch._initialUiState
      });
    }).then(function () {
      return renderToString(n, t);
    }).then(function () {
      return searchOnlyWithDerivedHelpers(s);
    }).then(function () {
      var e = {};
      return walkIndex(n.instantsearch.mainIndex, function (t) {
        e[t.getIndexId()] = t.getResults();
      }), a.hydrate(e), i = Object.keys(e).map(function (t) {
        var n = e[t],
            i = n._state,
            s = n._rawResults;
        return [t, {
          _state: Object.keys(i).reduce(function (e, t) {
            return e[t] = i[t], e;
          }, {}),
          _rawResults: s
        }];
      }).reduce(function (e, t) {
        var n = t[0],
            i = t[1];
        return e[n] = i, e;
      }, {
        __identifier: "stringified"
      }), a.getState();
    });
  }, a.getState = function () {
    if (!i) throw new Error("You need to wait for findResultsState to finish");
    return i;
  }, a.__forceRender = function (e, t) {
    var n = t.getHelper(),
        i = a.__initialSearchResults[t.getIndexId()];

    if (i) {
      var s = i._state;
      n.state = s;
      e.render({
        helper: n,
        results: i,
        scopedResults: function e(t) {
          return t.filter(function (e) {
            return "ais.index" === e.$$type;
          }).reduce(function (t, n) {
            return t.concat.apply(t, [{
              indexId: n.getIndexId(),
              results: a.__initialSearchResults[n.getIndexId()],
              helper: n.getHelper()
            }].concat(e(n.getWidgets())));
          }, []);
        }([t]),
        state: s,
        templatesConfig: {},
        createURL: function (e) {
          var i;
          return a._createURL(((i = {})[t.getIndexId()] = t.getWidgets().filter(function (e) {
            return "ais.index" !== e.$$type;
          }).reduce(function (t, i) {
            return i.getWidgetState ? i.getWidgetState(t, {
              searchParameters: e,
              helper: n
            }) : t;
          }, {}), i));
        },
        instantSearchInstance: a,
        searchMetadata: {
          isSearchStalled: !1
        }
      });
    }
  }, a.hydrate = function (e) {
    if (e) {
      var t = "stringified" === e.__identifier ? Object.keys(e).reduce(function (t, n) {
        return "__identifier" === n ? t : (t[n] = new SearchResults(new SearchParameters(e[n]._state), e[n]._rawResults), t);
      }, {}) : e;
      a.__initialSearchResults = t, a.helper = s, a.mainHelper = s, a.mainIndex.init({
        instantSearchInstance: a,
        parent: null,
        uiState: a._initialUiState
      });
    } else warn("The result of `findResultsState()` needs to be passed to `hydrate()`.");
  }, a;
}

function createServerRootMixin(e) {
  void 0 === e && (e = {});
  var t = e.searchClient,
      n = e.indexName;
  if (!t || !n) throw new Error("createServerRootMixin requires `searchClient` and `indexName` in the first argument");
  var i = augmentInstantSearch(e, t, n);
  return {
    provide: function () {
      return {
        $_ais_ssrInstantSearchInstance: this.instantsearch
      };
    },
    data: function () {
      return {
        instantsearch: i
      };
    }
  };
}

exports.AisAutocomplete = Autocomplete, exports.AisBreadcrumb = Breadcrumb, exports.AisClearRefinements = ClearRefinements, exports.AisConfigure = Configure, exports.AisCurrentRefinements = CurrentRefinements, exports.AisExperimentalConfigureRelatedItems = ConfigureRelatedItems, exports.AisHierarchicalMenu = HierarchicalMenu, exports.AisHighlight = AisHighlight, exports.AisHits = Hits, exports.AisHitsPerPage = HitsPerPage, exports.AisIndex = Index, exports.AisInfiniteHits = InfiniteHits, exports.AisInstantSearch = InstantSearch, exports.AisInstantSearchSsr = InstantSearchSsr, exports.AisMenu = Menu, exports.AisMenuSelect = MenuSelect, exports.AisNumericMenu = NumericMenu, exports.AisPagination = Pagination, exports.AisPanel = Panel, exports.AisPoweredBy = PoweredBy, exports.AisQueryRuleContext = QueryRuleContext, exports.AisQueryRuleCustomData = QueryRuleCustomData, exports.AisRangeInput = RangeInput, exports.AisRatingMenu = RatingMenu, exports.AisRefinementList = RefinementList, exports.AisSearchBox = SearchBox, exports.AisSnippet = Snippet, exports.AisSortBy = SortBy, exports.AisStateResults = StateResults, exports.AisStats = Stats, exports.AisToggleRefinement = ToggleRefinement, exports.AisVoiceSearch = VoiceSearch, exports.createServerRootMixin = createServerRootMixin, exports.createSuitMixin = createSuitMixin, exports.createWidgetMixin = createWidgetMixin, exports.default = plugin;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(61);
module.exports = __webpack_require__(78);


/***/ }),
/* 61 */
/***/ (function(module, exports) {

global.installComponents = function (component, components) {
  var options = typeof component.exports === 'function'
    ? component.exports.extendOptions
    : component.options

  if (typeof component.exports === 'function') {
    options.components = component.exports.options.components
  }

  options.components = options.components || {}

  for (var i in components) {
    options.components[i] = options.components[i] || components[i]
  }


  if (options.functional) {
    provideFunctionalComponents(component, options.components)
  }
}

var functionalPatchKey = '_functionalComponents'

function provideFunctionalComponents(component, components) {
  if (component.exports[functionalPatchKey]) {
    return
  }
  component.exports[functionalPatchKey] = true

  var render = component.exports.render
  component.exports.render = function (h, vm) {
    return render(h, Object.assign({}, vm, {
      _c: function (n, a, b) {
        return vm._c(components[n] || n, a, b)
      }
    }))
  }
}


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_error_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".__nuxt-error-page{padding:1rem;background:#f7f8fb;color:#47494e;text-align:center;display:flex;justify-content:center;align-items:center;flex-direction:column;font-family:sans-serif;font-weight:100!important;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased;position:absolute;top:0;left:0;right:0;bottom:0}.__nuxt-error-page .error{max-width:450px}.__nuxt-error-page .title{font-size:1.5rem;margin-top:15px;color:#47494e;margin-bottom:8px}.__nuxt-error-page .description{color:#7f828b;line-height:21px;margin-bottom:10px}.__nuxt-error-page a{color:#7f828b!important;text-decoration:none}.__nuxt-error-page .logo{position:fixed;left:12px;bottom:12px}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _vue_style_loader_index_js_ref_3_oneOf_1_0_css_loader_dist_cjs_js_ref_3_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_3_oneOf_1_2_nuxt_components_dist_loader_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_nuxt_loading_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(67);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
__webpack_require__(7).default("0211d3d2", content, true)

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}button{background-color:transparent;background-image:none}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}html{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,BlinkMacSystemFont,\"Segoe UI\",\"Helvetica Neue\",Arial,\"Noto Sans\",\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";line-height:1.5}*,:after,:before{box-sizing:border-box;border:0 solid #e2e8f0}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#a0aec0}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#a0aec0}input::placeholder,textarea::placeholder{color:#a0aec0}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}.prose{color:#4a5568;max-width:65ch}.prose [class~=lead]{color:#4a5568;font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.prose a{color:#1a202c;text-decoration:underline}.prose strong{color:#1a202c;font-weight:600}.prose ol{counter-reset:list-counter;margin-top:1.25em;margin-bottom:1.25em}.prose ol>li{position:relative;counter-increment:list-counter;padding-left:1.75em}.prose ol>li:before{content:counter(list-counter) \".\";position:absolute;font-weight:400;color:#718096}.prose ul>li{position:relative;padding-left:1.75em}.prose ul>li:before{content:\"\";position:absolute;background-color:#cbd5e0;border-radius:50%;width:.375em;height:.375em;top:.6875em;left:.25em}.prose hr{border-color:#e2e8f0;border-top-width:1px;margin-top:3em;margin-bottom:3em}.prose blockquote{font-weight:500;font-style:italic;color:#1a202c;border-left-width:.25rem;border-left-color:#e2e8f0;quotes:\"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.prose blockquote p:first-of-type:before{content:open-quote}.prose blockquote p:last-of-type:after{content:close-quote}.prose h1{color:#1a202c;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.prose h2{color:#dd6b20;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.prose h3,.prose h4{color:#dd6b20;font-weight:600}.prose h4{margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.prose figure figcaption{color:#718096;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.prose code{color:#1a202c;font-weight:600;font-size:.875em}.prose code:after,.prose code:before{content:\"\"}.prose pre{color:#e2e8f0;background-color:#2d3748;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em}.prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.prose pre code:after,.prose pre code:before{content:\"\"}.prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.prose thead{color:#1a202c;font-weight:600;border-bottom-width:1px;border-bottom-color:#cbd5e0}.prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.prose tbody tr{border-bottom-width:1px;border-bottom-color:#e2e8f0}.prose tbody tr:last-child{border-bottom-width:0}.prose tbody td{vertical-align:top;padding:.5714286em}.prose{font-size:1rem;line-height:1.75}.prose p{margin-top:1.25em;margin-bottom:1.25em}.prose figure,.prose img,.prose video{margin-top:2em;margin-bottom:2em}.prose figure>*{margin-top:0;margin-bottom:0}.prose h2 code{font-size:.875em}.prose h3 code{font-size:.9em}.prose ul{margin-top:1.25em;margin-bottom:1.25em}.prose li{margin-top:.5em;margin-bottom:.5em}.prose ol>li:before{left:0}.prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.prose>ul>li>:first-child{margin-top:1.25em}.prose>ul>li>:last-child{margin-bottom:1.25em}.prose>ol>li>:first-child{margin-top:1.25em}.prose>ol>li>:last-child{margin-bottom:1.25em}.prose ol ol,.prose ol ul,.prose ul ol,.prose ul ul{margin-top:.75em;margin-bottom:.75em}.prose h2+*,.prose h3+*,.prose h4+*,.prose hr+*{margin-top:0}.prose thead th:first-child{padding-left:0}.prose thead th:last-child{padding-right:0}.prose tbody td:first-child{padding-left:0}.prose tbody td:last-child{padding-right:0}.prose>:first-child{margin-top:0}.prose>:last-child{margin-bottom:0}.prose-sm{font-size:.875rem;line-height:1.7142857}.prose-sm p{margin-top:1.1428571em;margin-bottom:1.1428571em}.prose-sm [class~=lead]{font-size:1.2857143em;line-height:1.5555556;margin-top:.8888889em;margin-bottom:.8888889em}.prose-sm blockquote{margin-top:1.3333333em;margin-bottom:1.3333333em;padding-left:1.1111111em}.prose-sm h1{font-size:2.1428571em;margin-top:0;margin-bottom:.8em;line-height:1.2}.prose-sm h2{font-size:1.4285714em;margin-top:1.6em;margin-bottom:.8em;line-height:1.4}.prose-sm h3{font-size:1.2857143em;margin-top:1.5555556em;margin-bottom:.4444444em;line-height:1.5555556}.prose-sm h4{margin-top:1.4285714em;margin-bottom:.5714286em;line-height:1.4285714}.prose-sm figure,.prose-sm img,.prose-sm video{margin-top:1.7142857em;margin-bottom:1.7142857em}.prose-sm figure>*{margin-top:0;margin-bottom:0}.prose-sm figure figcaption{font-size:.8571429em;line-height:1.3333333;margin-top:.6666667em}.prose-sm code{font-size:.8571429em}.prose-sm h2 code{font-size:.9em}.prose-sm h3 code{font-size:.8888889em}.prose-sm pre{font-size:.8571429em;line-height:1.6666667;margin-top:1.6666667em;margin-bottom:1.6666667em;border-radius:.25rem;padding:.6666667em 1em}.prose-sm ol,.prose-sm ul{margin-top:1.1428571em;margin-bottom:1.1428571em}.prose-sm li{margin-top:.2857143em;margin-bottom:.2857143em}.prose-sm ol>li{padding-left:1.5714286em}.prose-sm ol>li:before{left:0}.prose-sm ul>li{padding-left:1.5714286em}.prose-sm ul>li:before{height:.3571429em;width:.3571429em;top:.67857em;left:.2142857em}.prose-sm>ul>li p{margin-top:.5714286em;margin-bottom:.5714286em}.prose-sm>ul>li>:first-child{margin-top:1.1428571em}.prose-sm>ul>li>:last-child{margin-bottom:1.1428571em}.prose-sm>ol>li>:first-child{margin-top:1.1428571em}.prose-sm>ol>li>:last-child{margin-bottom:1.1428571em}.prose-sm ol ol,.prose-sm ol ul,.prose-sm ul ol,.prose-sm ul ul{margin-top:.5714286em;margin-bottom:.5714286em}.prose-sm hr{margin-top:2.8571429em;margin-bottom:2.8571429em}.prose-sm h2+*,.prose-sm h3+*,.prose-sm h4+*,.prose-sm hr+*{margin-top:0}.prose-sm table{font-size:.8571429em;line-height:1.5}.prose-sm thead th{padding-right:1em;padding-bottom:.6666667em;padding-left:1em}.prose-sm thead th:first-child{padding-left:0}.prose-sm thead th:last-child{padding-right:0}.prose-sm tbody td{padding:.6666667em 1em}.prose-sm tbody td:first-child{padding-left:0}.prose-sm tbody td:last-child{padding-right:0}.prose-sm>:first-child{margin-top:0}.prose-sm>:last-child{margin-bottom:0}.prose-lg{font-size:1.125rem;line-height:1.7777778}.prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-lg [class~=lead]{font-size:1.2222222em;line-height:1.4545455;margin-top:1.0909091em;margin-bottom:1.0909091em}.prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.prose-lg figure,.prose-lg img,.prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.prose-lg figure>*{margin-top:0;margin-bottom:0}.prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.prose-lg code{font-size:.8888889em}.prose-lg h2 code{font-size:.8666667em}.prose-lg h3 code{font-size:.875em}.prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding:1em 1.5em}.prose-lg ol,.prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.prose-lg ol>li{padding-left:1.6666667em}.prose-lg ol>li:before{left:0}.prose-lg ul>li{padding-left:1.6666667em}.prose-lg ul>li:before{width:.3333333em;height:.3333333em;top:.72222em;left:.2222222em}.prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.prose-lg>ul>li>:first-child{margin-top:1.3333333em}.prose-lg>ul>li>:last-child{margin-bottom:1.3333333em}.prose-lg>ol>li>:first-child{margin-top:1.3333333em}.prose-lg>ol>li>:last-child{margin-bottom:1.3333333em}.prose-lg ol ol,.prose-lg ol ul,.prose-lg ul ol,.prose-lg ul ul{margin-top:.8888889em;margin-bottom:.8888889em}.prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.prose-lg h2+*,.prose-lg h3+*,.prose-lg h4+*,.prose-lg hr+*{margin-top:0}.prose-lg table{font-size:.8888889em;line-height:1.5}.prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.prose-lg thead th:first-child{padding-left:0}.prose-lg thead th:last-child{padding-right:0}.prose-lg tbody td{padding:.75em}.prose-lg tbody td:first-child{padding-left:0}.prose-lg tbody td:last-child{padding-right:0}.prose-lg>:first-child{margin-top:0}.prose-lg>:last-child{margin-bottom:0}.prose-xl{font-size:1.25rem;line-height:1.8}.prose-xl p{margin-top:1.2em;margin-bottom:1.2em}.prose-xl [class~=lead]{font-size:1.2em;line-height:1.5;margin-top:1em;margin-bottom:1em}.prose-xl blockquote{margin-top:1.6em;margin-bottom:1.6em;padding-left:1.0666667em}.prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1}.prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111}.prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333}.prose-xl h4{margin-top:1.8em;margin-bottom:.6em;line-height:1.6}.prose-xl figure,.prose-xl img,.prose-xl video{margin-top:2em;margin-bottom:2em}.prose-xl figure>*{margin-top:0;margin-bottom:0}.prose-xl figure figcaption{font-size:.9em;line-height:1.5555556;margin-top:1em}.prose-xl code{font-size:.9em}.prose-xl h2 code{font-size:.8611111em}.prose-xl h3 code,.prose-xl pre{font-size:.9em}.prose-xl pre{line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em}.prose-xl ol,.prose-xl ul{margin-top:1.2em;margin-bottom:1.2em}.prose-xl li{margin-top:.6em;margin-bottom:.6em}.prose-xl ol>li{padding-left:1.8em}.prose-xl ol>li:before{left:0}.prose-xl ul>li{padding-left:1.8em}.prose-xl ul>li:before{width:.35em;height:.35em;top:.725em;left:.25em}.prose-xl>ul>li p{margin-top:.8em;margin-bottom:.8em}.prose-xl>ul>li>:first-child{margin-top:1.2em}.prose-xl>ul>li>:last-child{margin-bottom:1.2em}.prose-xl>ol>li>:first-child{margin-top:1.2em}.prose-xl>ol>li>:last-child{margin-bottom:1.2em}.prose-xl ol ol,.prose-xl ol ul,.prose-xl ul ol,.prose-xl ul ul{margin-top:.8em;margin-bottom:.8em}.prose-xl hr{margin-top:2.8em;margin-bottom:2.8em}.prose-xl h2+*,.prose-xl h3+*,.prose-xl h4+*,.prose-xl hr+*{margin-top:0}.prose-xl table{font-size:.9em;line-height:1.5555556}.prose-xl thead th{padding-right:.6666667em;padding-bottom:.8888889em;padding-left:.6666667em}.prose-xl thead th:first-child{padding-left:0}.prose-xl thead th:last-child{padding-right:0}.prose-xl tbody td{padding:.8888889em .6666667em}.prose-xl tbody td:first-child{padding-left:0}.prose-xl tbody td:last-child{padding-right:0}.prose-xl>:first-child{margin-top:0}.prose-xl>:last-child{margin-bottom:0}.prose-2xl{font-size:1.5rem;line-height:1.6666667}.prose-2xl p{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-2xl [class~=lead]{font-size:1.25em;line-height:1.4666667;margin-top:1.0666667em;margin-bottom:1.0666667em}.prose-2xl blockquote{margin-top:1.7777778em;margin-bottom:1.7777778em;padding-left:1.1111111em}.prose-2xl h1{font-size:2.6666667em;margin-top:0;margin-bottom:.875em;line-height:1}.prose-2xl h2{font-size:2em;margin-top:1.5em;margin-bottom:.8333333em;line-height:1.0833333}.prose-2xl h3{font-size:1.5em;margin-top:1.5555556em;margin-bottom:.6666667em;line-height:1.2222222}.prose-2xl h4{margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.prose-2xl figure,.prose-2xl img,.prose-2xl video{margin-top:2em;margin-bottom:2em}.prose-2xl figure>*{margin-top:0;margin-bottom:0}.prose-2xl figure figcaption{font-size:.8333333em;line-height:1.6;margin-top:1em}.prose-2xl code{font-size:.8333333em}.prose-2xl h2 code{font-size:.875em}.prose-2xl h3 code{font-size:.8888889em}.prose-2xl pre{font-size:.8333333em;line-height:1.8;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.2em 1.6em}.prose-2xl ol,.prose-2xl ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-2xl li{margin-top:.5em;margin-bottom:.5em}.prose-2xl ol>li{padding-left:1.6666667em}.prose-2xl ol>li:before{left:0}.prose-2xl ul>li{padding-left:1.6666667em}.prose-2xl ul>li:before{width:.3333333em;height:.3333333em;top:.66667em;left:.25em}.prose-2xl>ul>li p{margin-top:.8333333em;margin-bottom:.8333333em}.prose-2xl>ul>li>:first-child{margin-top:1.3333333em}.prose-2xl>ul>li>:last-child{margin-bottom:1.3333333em}.prose-2xl>ol>li>:first-child{margin-top:1.3333333em}.prose-2xl>ol>li>:last-child{margin-bottom:1.3333333em}.prose-2xl ol ol,.prose-2xl ol ul,.prose-2xl ul ol,.prose-2xl ul ul{margin-top:.6666667em;margin-bottom:.6666667em}.prose-2xl hr{margin-top:3em;margin-bottom:3em}.prose-2xl h2+*,.prose-2xl h3+*,.prose-2xl h4+*,.prose-2xl hr+*{margin-top:0}.prose-2xl table{font-size:.8333333em;line-height:1.4}.prose-2xl thead th{padding-right:.6em;padding-bottom:.8em;padding-left:.6em}.prose-2xl thead th:first-child{padding-left:0}.prose-2xl thead th:last-child{padding-right:0}.prose-2xl tbody td{padding:.8em .6em}.prose-2xl tbody td:first-child{padding-left:0}.prose-2xl tbody td:last-child{padding-right:0}.prose-2xl>:first-child{margin-top:0}.prose-2xl>:last-child{margin-bottom:0}.space-x-6>:not(template)~:not(template){--space-x-reverse:0;margin-right:calc(1.5rem*var(--space-x-reverse));margin-left:calc(1.5rem*(1 - var(--space-x-reverse)))}.divide-y>:not(template)~:not(template){--divide-y-reverse:0;border-top-width:calc(1px*(1 - var(--divide-y-reverse)));border-bottom-width:calc(1px*var(--divide-y-reverse))}.divide-blue-900>:not(template)~:not(template){--divide-opacity:1;border-color:#2a4365;border-color:rgba(42,67,101,var(--divide-opacity))}.bg-white{--bg-opacity:1;background-color:#fff;background-color:rgba(255,255,255,var(--bg-opacity))}.bg-gray-900{--bg-opacity:1;background-color:#1a202c;background-color:rgba(26,32,44,var(--bg-opacity))}.bg-orange-600{--bg-opacity:1;background-color:#dd6b20;background-color:rgba(221,107,32,var(--bg-opacity))}.bg-blue-100{--bg-opacity:1;background-color:#ebf8ff;background-color:rgba(235,248,255,var(--bg-opacity))}.bg-blue-900{--bg-opacity:1;background-color:#2a4365;background-color:rgba(42,67,101,var(--bg-opacity))}.hover\\:bg-orange-100:hover{--bg-opacity:1;background-color:#fffaf0;background-color:rgba(255,250,240,var(--bg-opacity))}.rounded-md{border-radius:.375rem}.rounded-lg{border-radius:.5rem}.rounded-2xl{border-radius:1rem}.rounded-full{border-radius:9999px}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.table{display:table}.grid{display:grid}.hidden{display:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.flex-shrink-0{flex-shrink:0}.font-medium{font-weight:500}.font-semibold{font-weight:600}.font-bold{font-weight:700}.font-extrabold{font-weight:800}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-10{height:2.5rem}.h-16{height:4rem}.h-full{height:100%}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-lg{font-size:1.125rem}.text-xl{font-size:1.25rem}.text-3xl{font-size:1.875rem}.mx-auto{margin-left:auto;margin-right:auto}.ml-1{margin-left:.25rem}.mt-3{margin-top:.75rem}.ml-3{margin-left:.75rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.mt-12{margin-top:3rem}.mt-16{margin-top:4rem}.max-w-md{max-width:28rem}.max-w-2xl{max-width:42rem}.max-w-3xl{max-width:48rem}.max-w-6xl{max-width:72rem}.opacity-0{opacity:0}.opacity-100{opacity:1}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.overflow-hidden{overflow:hidden}.overflow-y-auto{overflow-y:auto}.p-10{padding:2.5rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.py-12{padding-top:3rem;padding-bottom:3rem}.pb-2{padding-bottom:.5rem}.pl-3{padding-left:.75rem}.pt-4{padding-top:1rem}.pt-6{padding-top:1.5rem}.pb-6{padding-bottom:1.5rem}.pt-10{padding-top:2.5rem}.pr-10{padding-right:2.5rem}.pt-12{padding-top:3rem}.pr-12{padding-right:3rem}.pt-16{padding-top:4rem}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{top:0;right:0;bottom:0;left:0}.top-0{top:0}.right-0{right:0}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.shadow-xl{box-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 10px 10px -5px rgba(0,0,0,.04)}.text-center{text-align:center}.text-white{--text-opacity:1;color:#fff;color:rgba(255,255,255,var(--text-opacity))}.text-gray-100{--text-opacity:1;color:#f7fafc;color:rgba(247,250,252,var(--text-opacity))}.text-gray-600{--text-opacity:1;color:#718096;color:rgba(113,128,150,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.text-red-700{--text-opacity:1;color:#c53030;color:rgba(197,48,48,var(--text-opacity))}.text-orange-200{--text-opacity:1;color:#feebc8;color:rgba(254,235,200,var(--text-opacity))}.text-orange-500{--text-opacity:1;color:#ed8936;color:rgba(237,137,54,var(--text-opacity))}.text-orange-600{--text-opacity:1;color:#dd6b20;color:rgba(221,107,32,var(--text-opacity))}.text-blue-300{--text-opacity:1;color:#90cdf4;color:rgba(144,205,244,var(--text-opacity))}.text-blue-500{--text-opacity:1;color:#4299e1;color:rgba(66,153,225,var(--text-opacity))}.hover\\:text-gray-700:hover{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.hover\\:text-orange-500:hover{--text-opacity:1;color:#ed8936;color:rgba(237,137,54,var(--text-opacity))}.uppercase{text-transform:uppercase}.tracking-tight{letter-spacing:-.025em}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-10{width:2.5rem}.w-64{width:16rem}.w-full{width:100%}.z-10{z-index:10}.z-40{z-index:40}.gap-6{grid-gap:1.5rem;gap:1.5rem}.col-span-2{grid-column:span 2/span 2}.transform{--transform-translate-x:0;--transform-translate-y:0;--transform-rotate:0;--transform-skew-x:0;--transform-skew-y:0;--transform-scale-x:1;--transform-scale-y:1;transform:translateX(var(--transform-translate-x)) translateY(var(--transform-translate-y)) rotate(var(--transform-rotate)) skewX(var(--transform-skew-x)) skewY(var(--transform-skew-y)) scaleX(var(--transform-scale-x)) scaleY(var(--transform-scale-y))}.transition{transition-property:background-color,border-color,color,fill,stroke,opacity,box-shadow,transform}.transition-opacity{transition-property:opacity}.ease-linear{transition-timing-function:linear}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-150{transition-duration:.15s}.duration-300{transition-duration:.3s}@-webkit-keyframes spin{to{transform:rotate(1turn)}}@keyframes spin{to{transform:rotate(1turn)}}@-webkit-keyframes ping{75%,to{transform:scale(2);opacity:0}}@keyframes ping{75%,to{transform:scale(2);opacity:0}}@-webkit-keyframes pulse{50%{opacity:.5}}@keyframes pulse{50%{opacity:.5}}@-webkit-keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:none;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:none;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive>embed,.embed-responsive>iframe,.embed-responsive>object,.embed-responsive>video{position:absolute;top:0;left:0;bottom:0;height:100%;width:100%;border:0}.aspect-ratio-16\\/9{padding-bottom:56.25%}@media (min-width:640px){.sm\\:container{width:100%}}@media (min-width:640px) and (min-width:640px){.sm\\:container{max-width:640px}}@media (min-width:640px) and (min-width:768px){.sm\\:container{max-width:768px}}@media (min-width:640px) and (min-width:1024px){.sm\\:container{max-width:1024px}}@media (min-width:640px) and (min-width:1280px){.sm\\:container{max-width:1280px}}@media (min-width:640px){.sm\\:prose{color:#4a5568;max-width:65ch}.sm\\:prose [class~=lead]{color:#4a5568;font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.sm\\:prose a{color:#1a202c;text-decoration:underline}.sm\\:prose strong{color:#1a202c;font-weight:600}.sm\\:prose ol{counter-reset:list-counter;margin-top:1.25em;margin-bottom:1.25em}.sm\\:prose ol>li{position:relative;counter-increment:list-counter;padding-left:1.75em}.sm\\:prose ol>li:before{content:counter(list-counter) \".\";position:absolute;font-weight:400;color:#718096}.sm\\:prose ul>li{position:relative;padding-left:1.75em}.sm\\:prose ul>li:before{content:\"\";position:absolute;background-color:#cbd5e0;border-radius:50%;width:.375em;height:.375em;top:.6875em;left:.25em}.sm\\:prose hr{border-color:#e2e8f0;border-top-width:1px;margin-top:3em;margin-bottom:3em}.sm\\:prose blockquote{font-weight:500;font-style:italic;color:#1a202c;border-left-width:.25rem;border-left-color:#e2e8f0;quotes:\"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.sm\\:prose blockquote p:first-of-type:before{content:open-quote}.sm\\:prose blockquote p:last-of-type:after{content:close-quote}.sm\\:prose h1{color:#1a202c;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.sm\\:prose h2{color:#dd6b20;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.sm\\:prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.sm\\:prose h3,.sm\\:prose h4{color:#dd6b20;font-weight:600}.sm\\:prose h4{margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.sm\\:prose figure figcaption{color:#718096;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.sm\\:prose code{color:#1a202c;font-weight:600;font-size:.875em}.sm\\:prose code:after,.sm\\:prose code:before{content:\"\"}.sm\\:prose pre{color:#e2e8f0;background-color:#2d3748;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em}.sm\\:prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.sm\\:prose pre code:after,.sm\\:prose pre code:before{content:\"\"}.sm\\:prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.sm\\:prose thead{color:#1a202c;font-weight:600;border-bottom-width:1px;border-bottom-color:#cbd5e0}.sm\\:prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.sm\\:prose tbody tr{border-bottom-width:1px;border-bottom-color:#e2e8f0}.sm\\:prose tbody tr:last-child{border-bottom-width:0}.sm\\:prose tbody td{vertical-align:top;padding:.5714286em}.sm\\:prose{font-size:1rem;line-height:1.75}.sm\\:prose p{margin-top:1.25em;margin-bottom:1.25em}.sm\\:prose figure,.sm\\:prose img,.sm\\:prose video{margin-top:2em;margin-bottom:2em}.sm\\:prose figure>*{margin-top:0;margin-bottom:0}.sm\\:prose h2 code{font-size:.875em}.sm\\:prose h3 code{font-size:.9em}.sm\\:prose ul{margin-top:1.25em;margin-bottom:1.25em}.sm\\:prose li{margin-top:.5em;margin-bottom:.5em}.sm\\:prose ol>li:before{left:0}.sm\\:prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.sm\\:prose>ul>li>:first-child{margin-top:1.25em}.sm\\:prose>ul>li>:last-child{margin-bottom:1.25em}.sm\\:prose>ol>li>:first-child{margin-top:1.25em}.sm\\:prose>ol>li>:last-child{margin-bottom:1.25em}.sm\\:prose ol ol,.sm\\:prose ol ul,.sm\\:prose ul ol,.sm\\:prose ul ul{margin-top:.75em;margin-bottom:.75em}.sm\\:prose h2+*,.sm\\:prose h3+*,.sm\\:prose h4+*,.sm\\:prose hr+*{margin-top:0}.sm\\:prose thead th:first-child{padding-left:0}.sm\\:prose thead th:last-child{padding-right:0}.sm\\:prose tbody td:first-child{padding-left:0}.sm\\:prose tbody td:last-child{padding-right:0}.sm\\:prose>:first-child{margin-top:0}.sm\\:prose>:last-child{margin-bottom:0}.sm\\:prose-sm{font-size:.875rem;line-height:1.7142857}.sm\\:prose-sm p{margin-top:1.1428571em;margin-bottom:1.1428571em}.sm\\:prose-sm [class~=lead]{font-size:1.2857143em;line-height:1.5555556;margin-top:.8888889em;margin-bottom:.8888889em}.sm\\:prose-sm blockquote{margin-top:1.3333333em;margin-bottom:1.3333333em;padding-left:1.1111111em}.sm\\:prose-sm h1{font-size:2.1428571em;margin-top:0;margin-bottom:.8em;line-height:1.2}.sm\\:prose-sm h2{font-size:1.4285714em;margin-top:1.6em;margin-bottom:.8em;line-height:1.4}.sm\\:prose-sm h3{font-size:1.2857143em;margin-top:1.5555556em;margin-bottom:.4444444em;line-height:1.5555556}.sm\\:prose-sm h4{margin-top:1.4285714em;margin-bottom:.5714286em;line-height:1.4285714}.sm\\:prose-sm figure,.sm\\:prose-sm img,.sm\\:prose-sm video{margin-top:1.7142857em;margin-bottom:1.7142857em}.sm\\:prose-sm figure>*{margin-top:0;margin-bottom:0}.sm\\:prose-sm figure figcaption{font-size:.8571429em;line-height:1.3333333;margin-top:.6666667em}.sm\\:prose-sm code{font-size:.8571429em}.sm\\:prose-sm h2 code{font-size:.9em}.sm\\:prose-sm h3 code{font-size:.8888889em}.sm\\:prose-sm pre{font-size:.8571429em;line-height:1.6666667;margin-top:1.6666667em;margin-bottom:1.6666667em;border-radius:.25rem;padding:.6666667em 1em}.sm\\:prose-sm ol,.sm\\:prose-sm ul{margin-top:1.1428571em;margin-bottom:1.1428571em}.sm\\:prose-sm li{margin-top:.2857143em;margin-bottom:.2857143em}.sm\\:prose-sm ol>li{padding-left:1.5714286em}.sm\\:prose-sm ol>li:before{left:0}.sm\\:prose-sm ul>li{padding-left:1.5714286em}.sm\\:prose-sm ul>li:before{height:.3571429em;width:.3571429em;top:.67857em;left:.2142857em}.sm\\:prose-sm>ul>li p{margin-top:.5714286em;margin-bottom:.5714286em}.sm\\:prose-sm>ul>li>:first-child{margin-top:1.1428571em}.sm\\:prose-sm>ul>li>:last-child{margin-bottom:1.1428571em}.sm\\:prose-sm>ol>li>:first-child{margin-top:1.1428571em}.sm\\:prose-sm>ol>li>:last-child{margin-bottom:1.1428571em}.sm\\:prose-sm ol ol,.sm\\:prose-sm ol ul,.sm\\:prose-sm ul ol,.sm\\:prose-sm ul ul{margin-top:.5714286em;margin-bottom:.5714286em}.sm\\:prose-sm hr{margin-top:2.8571429em;margin-bottom:2.8571429em}.sm\\:prose-sm h2+*,.sm\\:prose-sm h3+*,.sm\\:prose-sm h4+*,.sm\\:prose-sm hr+*{margin-top:0}.sm\\:prose-sm table{font-size:.8571429em;line-height:1.5}.sm\\:prose-sm thead th{padding-right:1em;padding-bottom:.6666667em;padding-left:1em}.sm\\:prose-sm thead th:first-child{padding-left:0}.sm\\:prose-sm thead th:last-child{padding-right:0}.sm\\:prose-sm tbody td{padding:.6666667em 1em}.sm\\:prose-sm tbody td:first-child{padding-left:0}.sm\\:prose-sm tbody td:last-child{padding-right:0}.sm\\:prose-sm>:first-child{margin-top:0}.sm\\:prose-sm>:last-child{margin-bottom:0}.sm\\:prose-lg{font-size:1.125rem;line-height:1.7777778}.sm\\:prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.sm\\:prose-lg [class~=lead]{font-size:1.2222222em;line-height:1.4545455;margin-top:1.0909091em;margin-bottom:1.0909091em}.sm\\:prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.sm\\:prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.sm\\:prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.sm\\:prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.sm\\:prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.sm\\:prose-lg figure,.sm\\:prose-lg img,.sm\\:prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.sm\\:prose-lg figure>*{margin-top:0;margin-bottom:0}.sm\\:prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.sm\\:prose-lg code{font-size:.8888889em}.sm\\:prose-lg h2 code{font-size:.8666667em}.sm\\:prose-lg h3 code{font-size:.875em}.sm\\:prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding:1em 1.5em}.sm\\:prose-lg ol,.sm\\:prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.sm\\:prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.sm\\:prose-lg ol>li{padding-left:1.6666667em}.sm\\:prose-lg ol>li:before{left:0}.sm\\:prose-lg ul>li{padding-left:1.6666667em}.sm\\:prose-lg ul>li:before{width:.3333333em;height:.3333333em;top:.72222em;left:.2222222em}.sm\\:prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.sm\\:prose-lg>ul>li>:first-child{margin-top:1.3333333em}.sm\\:prose-lg>ul>li>:last-child{margin-bottom:1.3333333em}.sm\\:prose-lg>ol>li>:first-child{margin-top:1.3333333em}.sm\\:prose-lg>ol>li>:last-child{margin-bottom:1.3333333em}.sm\\:prose-lg ol ol,.sm\\:prose-lg ol ul,.sm\\:prose-lg ul ol,.sm\\:prose-lg ul ul{margin-top:.8888889em;margin-bottom:.8888889em}.sm\\:prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.sm\\:prose-lg h2+*,.sm\\:prose-lg h3+*,.sm\\:prose-lg h4+*,.sm\\:prose-lg hr+*{margin-top:0}.sm\\:prose-lg table{font-size:.8888889em;line-height:1.5}.sm\\:prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.sm\\:prose-lg thead th:first-child{padding-left:0}.sm\\:prose-lg thead th:last-child{padding-right:0}.sm\\:prose-lg tbody td{padding:.75em}.sm\\:prose-lg tbody td:first-child{padding-left:0}.sm\\:prose-lg tbody td:last-child{padding-right:0}.sm\\:prose-lg>:first-child{margin-top:0}.sm\\:prose-lg>:last-child{margin-bottom:0}.sm\\:prose-xl{font-size:1.25rem;line-height:1.8}.sm\\:prose-xl p{margin-top:1.2em;margin-bottom:1.2em}.sm\\:prose-xl [class~=lead]{font-size:1.2em;line-height:1.5;margin-top:1em;margin-bottom:1em}.sm\\:prose-xl blockquote{margin-top:1.6em;margin-bottom:1.6em;padding-left:1.0666667em}.sm\\:prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1}.sm\\:prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111}.sm\\:prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333}.sm\\:prose-xl h4{margin-top:1.8em;margin-bottom:.6em;line-height:1.6}.sm\\:prose-xl figure,.sm\\:prose-xl img,.sm\\:prose-xl video{margin-top:2em;margin-bottom:2em}.sm\\:prose-xl figure>*{margin-top:0;margin-bottom:0}.sm\\:prose-xl figure figcaption{font-size:.9em;line-height:1.5555556;margin-top:1em}.sm\\:prose-xl code{font-size:.9em}.sm\\:prose-xl h2 code{font-size:.8611111em}.sm\\:prose-xl h3 code{font-size:.9em}.sm\\:prose-xl pre{font-size:.9em;line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em}.sm\\:prose-xl ol,.sm\\:prose-xl ul{margin-top:1.2em;margin-bottom:1.2em}.sm\\:prose-xl li{margin-top:.6em;margin-bottom:.6em}.sm\\:prose-xl ol>li{padding-left:1.8em}.sm\\:prose-xl ol>li:before{left:0}.sm\\:prose-xl ul>li{padding-left:1.8em}.sm\\:prose-xl ul>li:before{width:.35em;height:.35em;top:.725em;left:.25em}.sm\\:prose-xl>ul>li p{margin-top:.8em;margin-bottom:.8em}.sm\\:prose-xl>ul>li>:first-child{margin-top:1.2em}.sm\\:prose-xl>ul>li>:last-child{margin-bottom:1.2em}.sm\\:prose-xl>ol>li>:first-child{margin-top:1.2em}.sm\\:prose-xl>ol>li>:last-child{margin-bottom:1.2em}.sm\\:prose-xl ol ol,.sm\\:prose-xl ol ul,.sm\\:prose-xl ul ol,.sm\\:prose-xl ul ul{margin-top:.8em;margin-bottom:.8em}.sm\\:prose-xl hr{margin-top:2.8em;margin-bottom:2.8em}.sm\\:prose-xl h2+*,.sm\\:prose-xl h3+*,.sm\\:prose-xl h4+*,.sm\\:prose-xl hr+*{margin-top:0}.sm\\:prose-xl table{font-size:.9em;line-height:1.5555556}.sm\\:prose-xl thead th{padding-right:.6666667em;padding-bottom:.8888889em;padding-left:.6666667em}.sm\\:prose-xl thead th:first-child{padding-left:0}.sm\\:prose-xl thead th:last-child{padding-right:0}.sm\\:prose-xl tbody td{padding:.8888889em .6666667em}.sm\\:prose-xl tbody td:first-child{padding-left:0}.sm\\:prose-xl tbody td:last-child{padding-right:0}.sm\\:prose-xl>:first-child{margin-top:0}.sm\\:prose-xl>:last-child{margin-bottom:0}.sm\\:prose-2xl{font-size:1.5rem;line-height:1.6666667}.sm\\:prose-2xl p{margin-top:1.3333333em;margin-bottom:1.3333333em}.sm\\:prose-2xl [class~=lead]{font-size:1.25em;line-height:1.4666667;margin-top:1.0666667em;margin-bottom:1.0666667em}.sm\\:prose-2xl blockquote{margin-top:1.7777778em;margin-bottom:1.7777778em;padding-left:1.1111111em}.sm\\:prose-2xl h1{font-size:2.6666667em;margin-top:0;margin-bottom:.875em;line-height:1}.sm\\:prose-2xl h2{font-size:2em;margin-top:1.5em;margin-bottom:.8333333em;line-height:1.0833333}.sm\\:prose-2xl h3{font-size:1.5em;margin-top:1.5555556em;margin-bottom:.6666667em;line-height:1.2222222}.sm\\:prose-2xl h4{margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.sm\\:prose-2xl figure,.sm\\:prose-2xl img,.sm\\:prose-2xl video{margin-top:2em;margin-bottom:2em}.sm\\:prose-2xl figure>*{margin-top:0;margin-bottom:0}.sm\\:prose-2xl figure figcaption{font-size:.8333333em;line-height:1.6;margin-top:1em}.sm\\:prose-2xl code{font-size:.8333333em}.sm\\:prose-2xl h2 code{font-size:.875em}.sm\\:prose-2xl h3 code{font-size:.8888889em}.sm\\:prose-2xl pre{font-size:.8333333em;line-height:1.8;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.2em 1.6em}.sm\\:prose-2xl ol,.sm\\:prose-2xl ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.sm\\:prose-2xl li{margin-top:.5em;margin-bottom:.5em}.sm\\:prose-2xl ol>li{padding-left:1.6666667em}.sm\\:prose-2xl ol>li:before{left:0}.sm\\:prose-2xl ul>li{padding-left:1.6666667em}.sm\\:prose-2xl ul>li:before{width:.3333333em;height:.3333333em;top:.66667em;left:.25em}.sm\\:prose-2xl>ul>li p{margin-top:.8333333em;margin-bottom:.8333333em}.sm\\:prose-2xl>ul>li>:first-child{margin-top:1.3333333em}.sm\\:prose-2xl>ul>li>:last-child{margin-bottom:1.3333333em}.sm\\:prose-2xl>ol>li>:first-child{margin-top:1.3333333em}.sm\\:prose-2xl>ol>li>:last-child{margin-bottom:1.3333333em}.sm\\:prose-2xl ol ol,.sm\\:prose-2xl ol ul,.sm\\:prose-2xl ul ol,.sm\\:prose-2xl ul ul{margin-top:.6666667em;margin-bottom:.6666667em}.sm\\:prose-2xl hr{margin-top:3em;margin-bottom:3em}.sm\\:prose-2xl h2+*,.sm\\:prose-2xl h3+*,.sm\\:prose-2xl h4+*,.sm\\:prose-2xl hr+*{margin-top:0}.sm\\:prose-2xl table{font-size:.8333333em;line-height:1.4}.sm\\:prose-2xl thead th{padding-right:.6em;padding-bottom:.8em;padding-left:.6em}.sm\\:prose-2xl thead th:first-child{padding-left:0}.sm\\:prose-2xl thead th:last-child{padding-right:0}.sm\\:prose-2xl tbody td{padding:.8em .6em}.sm\\:prose-2xl tbody td:first-child{padding-left:0}.sm\\:prose-2xl tbody td:last-child{padding-right:0}.sm\\:prose-2xl>:first-child{margin-top:0}.sm\\:prose-2xl>:last-child{margin-bottom:0}.sm\\:text-xl{font-size:1.25rem}.sm\\:text-4xl{font-size:2.25rem}.sm\\:-mt-32{margin-top:-8rem}.sm\\:p-8{padding:2rem}.sm\\:px-0{padding-left:0;padding-right:0}.sm\\:px-3{padding-left:.75rem;padding-right:.75rem}.sm\\:px-6{padding-left:1.5rem;padding-right:1.5rem}.sm\\:text-center{text-align:center}.sm\\:gap-8{grid-gap:2rem;gap:2rem}}@media (min-width:768px){.md\\:container{width:100%}}@media (min-width:768px) and (min-width:640px){.md\\:container{max-width:640px}}@media (min-width:768px) and (min-width:768px){.md\\:container{max-width:768px}}@media (min-width:768px) and (min-width:1024px){.md\\:container{max-width:1024px}}@media (min-width:768px) and (min-width:1280px){.md\\:container{max-width:1280px}}@media (min-width:768px){.md\\:prose{color:#4a5568;max-width:65ch}.md\\:prose [class~=lead]{color:#4a5568;font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.md\\:prose a{color:#1a202c;text-decoration:underline}.md\\:prose strong{color:#1a202c;font-weight:600}.md\\:prose ol{counter-reset:list-counter;margin-top:1.25em;margin-bottom:1.25em}.md\\:prose ol>li{position:relative;counter-increment:list-counter;padding-left:1.75em}.md\\:prose ol>li:before{content:counter(list-counter) \".\";position:absolute;font-weight:400;color:#718096}.md\\:prose ul>li{position:relative;padding-left:1.75em}.md\\:prose ul>li:before{content:\"\";position:absolute;background-color:#cbd5e0;border-radius:50%;width:.375em;height:.375em;top:.6875em;left:.25em}.md\\:prose hr{border-color:#e2e8f0;border-top-width:1px;margin-top:3em;margin-bottom:3em}.md\\:prose blockquote{font-weight:500;font-style:italic;color:#1a202c;border-left-width:.25rem;border-left-color:#e2e8f0;quotes:\"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.md\\:prose blockquote p:first-of-type:before{content:open-quote}.md\\:prose blockquote p:last-of-type:after{content:close-quote}.md\\:prose h1{color:#1a202c;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.md\\:prose h2{color:#dd6b20;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.md\\:prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.md\\:prose h3,.md\\:prose h4{color:#dd6b20;font-weight:600}.md\\:prose h4{margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.md\\:prose figure figcaption{color:#718096;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.md\\:prose code{color:#1a202c;font-weight:600;font-size:.875em}.md\\:prose code:after,.md\\:prose code:before{content:\"\"}.md\\:prose pre{color:#e2e8f0;background-color:#2d3748;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em}.md\\:prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.md\\:prose pre code:after,.md\\:prose pre code:before{content:\"\"}.md\\:prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.md\\:prose thead{color:#1a202c;font-weight:600;border-bottom-width:1px;border-bottom-color:#cbd5e0}.md\\:prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.md\\:prose tbody tr{border-bottom-width:1px;border-bottom-color:#e2e8f0}.md\\:prose tbody tr:last-child{border-bottom-width:0}.md\\:prose tbody td{vertical-align:top;padding:.5714286em}.md\\:prose{font-size:1rem;line-height:1.75}.md\\:prose p{margin-top:1.25em;margin-bottom:1.25em}.md\\:prose figure,.md\\:prose img,.md\\:prose video{margin-top:2em;margin-bottom:2em}.md\\:prose figure>*{margin-top:0;margin-bottom:0}.md\\:prose h2 code{font-size:.875em}.md\\:prose h3 code{font-size:.9em}.md\\:prose ul{margin-top:1.25em;margin-bottom:1.25em}.md\\:prose li{margin-top:.5em;margin-bottom:.5em}.md\\:prose ol>li:before{left:0}.md\\:prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.md\\:prose>ul>li>:first-child{margin-top:1.25em}.md\\:prose>ul>li>:last-child{margin-bottom:1.25em}.md\\:prose>ol>li>:first-child{margin-top:1.25em}.md\\:prose>ol>li>:last-child{margin-bottom:1.25em}.md\\:prose ol ol,.md\\:prose ol ul,.md\\:prose ul ol,.md\\:prose ul ul{margin-top:.75em;margin-bottom:.75em}.md\\:prose h2+*,.md\\:prose h3+*,.md\\:prose h4+*,.md\\:prose hr+*{margin-top:0}.md\\:prose thead th:first-child{padding-left:0}.md\\:prose thead th:last-child{padding-right:0}.md\\:prose tbody td:first-child{padding-left:0}.md\\:prose tbody td:last-child{padding-right:0}.md\\:prose>:first-child{margin-top:0}.md\\:prose>:last-child{margin-bottom:0}.md\\:prose-sm{font-size:.875rem;line-height:1.7142857}.md\\:prose-sm p{margin-top:1.1428571em;margin-bottom:1.1428571em}.md\\:prose-sm [class~=lead]{font-size:1.2857143em;line-height:1.5555556;margin-top:.8888889em;margin-bottom:.8888889em}.md\\:prose-sm blockquote{margin-top:1.3333333em;margin-bottom:1.3333333em;padding-left:1.1111111em}.md\\:prose-sm h1{font-size:2.1428571em;margin-top:0;margin-bottom:.8em;line-height:1.2}.md\\:prose-sm h2{font-size:1.4285714em;margin-top:1.6em;margin-bottom:.8em;line-height:1.4}.md\\:prose-sm h3{font-size:1.2857143em;margin-top:1.5555556em;margin-bottom:.4444444em;line-height:1.5555556}.md\\:prose-sm h4{margin-top:1.4285714em;margin-bottom:.5714286em;line-height:1.4285714}.md\\:prose-sm figure,.md\\:prose-sm img,.md\\:prose-sm video{margin-top:1.7142857em;margin-bottom:1.7142857em}.md\\:prose-sm figure>*{margin-top:0;margin-bottom:0}.md\\:prose-sm figure figcaption{font-size:.8571429em;line-height:1.3333333;margin-top:.6666667em}.md\\:prose-sm code{font-size:.8571429em}.md\\:prose-sm h2 code{font-size:.9em}.md\\:prose-sm h3 code{font-size:.8888889em}.md\\:prose-sm pre{font-size:.8571429em;line-height:1.6666667;margin-top:1.6666667em;margin-bottom:1.6666667em;border-radius:.25rem;padding:.6666667em 1em}.md\\:prose-sm ol,.md\\:prose-sm ul{margin-top:1.1428571em;margin-bottom:1.1428571em}.md\\:prose-sm li{margin-top:.2857143em;margin-bottom:.2857143em}.md\\:prose-sm ol>li{padding-left:1.5714286em}.md\\:prose-sm ol>li:before{left:0}.md\\:prose-sm ul>li{padding-left:1.5714286em}.md\\:prose-sm ul>li:before{height:.3571429em;width:.3571429em;top:.67857em;left:.2142857em}.md\\:prose-sm>ul>li p{margin-top:.5714286em;margin-bottom:.5714286em}.md\\:prose-sm>ul>li>:first-child{margin-top:1.1428571em}.md\\:prose-sm>ul>li>:last-child{margin-bottom:1.1428571em}.md\\:prose-sm>ol>li>:first-child{margin-top:1.1428571em}.md\\:prose-sm>ol>li>:last-child{margin-bottom:1.1428571em}.md\\:prose-sm ol ol,.md\\:prose-sm ol ul,.md\\:prose-sm ul ol,.md\\:prose-sm ul ul{margin-top:.5714286em;margin-bottom:.5714286em}.md\\:prose-sm hr{margin-top:2.8571429em;margin-bottom:2.8571429em}.md\\:prose-sm h2+*,.md\\:prose-sm h3+*,.md\\:prose-sm h4+*,.md\\:prose-sm hr+*{margin-top:0}.md\\:prose-sm table{font-size:.8571429em;line-height:1.5}.md\\:prose-sm thead th{padding-right:1em;padding-bottom:.6666667em;padding-left:1em}.md\\:prose-sm thead th:first-child{padding-left:0}.md\\:prose-sm thead th:last-child{padding-right:0}.md\\:prose-sm tbody td{padding:.6666667em 1em}.md\\:prose-sm tbody td:first-child{padding-left:0}.md\\:prose-sm tbody td:last-child{padding-right:0}.md\\:prose-sm>:first-child{margin-top:0}.md\\:prose-sm>:last-child{margin-bottom:0}.md\\:prose-lg{font-size:1.125rem;line-height:1.7777778}.md\\:prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.md\\:prose-lg [class~=lead]{font-size:1.2222222em;line-height:1.4545455;margin-top:1.0909091em;margin-bottom:1.0909091em}.md\\:prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.md\\:prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.md\\:prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.md\\:prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.md\\:prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.md\\:prose-lg figure,.md\\:prose-lg img,.md\\:prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.md\\:prose-lg figure>*{margin-top:0;margin-bottom:0}.md\\:prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.md\\:prose-lg code{font-size:.8888889em}.md\\:prose-lg h2 code{font-size:.8666667em}.md\\:prose-lg h3 code{font-size:.875em}.md\\:prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding:1em 1.5em}.md\\:prose-lg ol,.md\\:prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.md\\:prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.md\\:prose-lg ol>li{padding-left:1.6666667em}.md\\:prose-lg ol>li:before{left:0}.md\\:prose-lg ul>li{padding-left:1.6666667em}.md\\:prose-lg ul>li:before{width:.3333333em;height:.3333333em;top:.72222em;left:.2222222em}.md\\:prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.md\\:prose-lg>ul>li>:first-child{margin-top:1.3333333em}.md\\:prose-lg>ul>li>:last-child{margin-bottom:1.3333333em}.md\\:prose-lg>ol>li>:first-child{margin-top:1.3333333em}.md\\:prose-lg>ol>li>:last-child{margin-bottom:1.3333333em}.md\\:prose-lg ol ol,.md\\:prose-lg ol ul,.md\\:prose-lg ul ol,.md\\:prose-lg ul ul{margin-top:.8888889em;margin-bottom:.8888889em}.md\\:prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.md\\:prose-lg h2+*,.md\\:prose-lg h3+*,.md\\:prose-lg h4+*,.md\\:prose-lg hr+*{margin-top:0}.md\\:prose-lg table{font-size:.8888889em;line-height:1.5}.md\\:prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.md\\:prose-lg thead th:first-child{padding-left:0}.md\\:prose-lg thead th:last-child{padding-right:0}.md\\:prose-lg tbody td{padding:.75em}.md\\:prose-lg tbody td:first-child{padding-left:0}.md\\:prose-lg tbody td:last-child{padding-right:0}.md\\:prose-lg>:first-child{margin-top:0}.md\\:prose-lg>:last-child{margin-bottom:0}.md\\:prose-xl{font-size:1.25rem;line-height:1.8}.md\\:prose-xl p{margin-top:1.2em;margin-bottom:1.2em}.md\\:prose-xl [class~=lead]{font-size:1.2em;line-height:1.5;margin-top:1em;margin-bottom:1em}.md\\:prose-xl blockquote{margin-top:1.6em;margin-bottom:1.6em;padding-left:1.0666667em}.md\\:prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1}.md\\:prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111}.md\\:prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333}.md\\:prose-xl h4{margin-top:1.8em;margin-bottom:.6em;line-height:1.6}.md\\:prose-xl figure,.md\\:prose-xl img,.md\\:prose-xl video{margin-top:2em;margin-bottom:2em}.md\\:prose-xl figure>*{margin-top:0;margin-bottom:0}.md\\:prose-xl figure figcaption{font-size:.9em;line-height:1.5555556;margin-top:1em}.md\\:prose-xl code{font-size:.9em}.md\\:prose-xl h2 code{font-size:.8611111em}.md\\:prose-xl h3 code{font-size:.9em}.md\\:prose-xl pre{font-size:.9em;line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em}.md\\:prose-xl ol,.md\\:prose-xl ul{margin-top:1.2em;margin-bottom:1.2em}.md\\:prose-xl li{margin-top:.6em;margin-bottom:.6em}.md\\:prose-xl ol>li{padding-left:1.8em}.md\\:prose-xl ol>li:before{left:0}.md\\:prose-xl ul>li{padding-left:1.8em}.md\\:prose-xl ul>li:before{width:.35em;height:.35em;top:.725em;left:.25em}.md\\:prose-xl>ul>li p{margin-top:.8em;margin-bottom:.8em}.md\\:prose-xl>ul>li>:first-child{margin-top:1.2em}.md\\:prose-xl>ul>li>:last-child{margin-bottom:1.2em}.md\\:prose-xl>ol>li>:first-child{margin-top:1.2em}.md\\:prose-xl>ol>li>:last-child{margin-bottom:1.2em}.md\\:prose-xl ol ol,.md\\:prose-xl ol ul,.md\\:prose-xl ul ol,.md\\:prose-xl ul ul{margin-top:.8em;margin-bottom:.8em}.md\\:prose-xl hr{margin-top:2.8em;margin-bottom:2.8em}.md\\:prose-xl h2+*,.md\\:prose-xl h3+*,.md\\:prose-xl h4+*,.md\\:prose-xl hr+*{margin-top:0}.md\\:prose-xl table{font-size:.9em;line-height:1.5555556}.md\\:prose-xl thead th{padding-right:.6666667em;padding-bottom:.8888889em;padding-left:.6666667em}.md\\:prose-xl thead th:first-child{padding-left:0}.md\\:prose-xl thead th:last-child{padding-right:0}.md\\:prose-xl tbody td{padding:.8888889em .6666667em}.md\\:prose-xl tbody td:first-child{padding-left:0}.md\\:prose-xl tbody td:last-child{padding-right:0}.md\\:prose-xl>:first-child{margin-top:0}.md\\:prose-xl>:last-child{margin-bottom:0}.md\\:prose-2xl{font-size:1.5rem;line-height:1.6666667}.md\\:prose-2xl p{margin-top:1.3333333em;margin-bottom:1.3333333em}.md\\:prose-2xl [class~=lead]{font-size:1.25em;line-height:1.4666667;margin-top:1.0666667em;margin-bottom:1.0666667em}.md\\:prose-2xl blockquote{margin-top:1.7777778em;margin-bottom:1.7777778em;padding-left:1.1111111em}.md\\:prose-2xl h1{font-size:2.6666667em;margin-top:0;margin-bottom:.875em;line-height:1}.md\\:prose-2xl h2{font-size:2em;margin-top:1.5em;margin-bottom:.8333333em;line-height:1.0833333}.md\\:prose-2xl h3{font-size:1.5em;margin-top:1.5555556em;margin-bottom:.6666667em;line-height:1.2222222}.md\\:prose-2xl h4{margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.md\\:prose-2xl figure,.md\\:prose-2xl img,.md\\:prose-2xl video{margin-top:2em;margin-bottom:2em}.md\\:prose-2xl figure>*{margin-top:0;margin-bottom:0}.md\\:prose-2xl figure figcaption{font-size:.8333333em;line-height:1.6;margin-top:1em}.md\\:prose-2xl code{font-size:.8333333em}.md\\:prose-2xl h2 code{font-size:.875em}.md\\:prose-2xl h3 code{font-size:.8888889em}.md\\:prose-2xl pre{font-size:.8333333em;line-height:1.8;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.2em 1.6em}.md\\:prose-2xl ol,.md\\:prose-2xl ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.md\\:prose-2xl li{margin-top:.5em;margin-bottom:.5em}.md\\:prose-2xl ol>li{padding-left:1.6666667em}.md\\:prose-2xl ol>li:before{left:0}.md\\:prose-2xl ul>li{padding-left:1.6666667em}.md\\:prose-2xl ul>li:before{width:.3333333em;height:.3333333em;top:.66667em;left:.25em}.md\\:prose-2xl>ul>li p{margin-top:.8333333em;margin-bottom:.8333333em}.md\\:prose-2xl>ul>li>:first-child{margin-top:1.3333333em}.md\\:prose-2xl>ul>li>:last-child{margin-bottom:1.3333333em}.md\\:prose-2xl>ol>li>:first-child{margin-top:1.3333333em}.md\\:prose-2xl>ol>li>:last-child{margin-bottom:1.3333333em}.md\\:prose-2xl ol ol,.md\\:prose-2xl ol ul,.md\\:prose-2xl ul ol,.md\\:prose-2xl ul ul{margin-top:.6666667em;margin-bottom:.6666667em}.md\\:prose-2xl hr{margin-top:3em;margin-bottom:3em}.md\\:prose-2xl h2+*,.md\\:prose-2xl h3+*,.md\\:prose-2xl h4+*,.md\\:prose-2xl hr+*{margin-top:0}.md\\:prose-2xl table{font-size:.8333333em;line-height:1.4}.md\\:prose-2xl thead th{padding-right:.6em;padding-bottom:.8em;padding-left:.6em}.md\\:prose-2xl thead th:first-child{padding-left:0}.md\\:prose-2xl thead th:last-child{padding-right:0}.md\\:prose-2xl tbody td{padding:.8em .6em}.md\\:prose-2xl tbody td:first-child{padding-left:0}.md\\:prose-2xl tbody td:last-child{padding-right:0}.md\\:prose-2xl>:first-child{margin-top:0}.md\\:prose-2xl>:last-child{margin-bottom:0}.md\\:flex{display:flex}.md\\:hidden{display:none}.md\\:items-center{align-items:center}.md\\:justify-between{justify-content:space-between}.md\\:order-1{order:1}.md\\:order-2{order:2}.md\\:text-2xl{font-size:1.5rem}.md\\:mt-0{margin-top:0}}@media (min-width:1024px){.lg\\:container{width:100%}}@media (min-width:1024px) and (min-width:640px){.lg\\:container{max-width:640px}}@media (min-width:1024px) and (min-width:768px){.lg\\:container{max-width:768px}}@media (min-width:1024px) and (min-width:1024px){.lg\\:container{max-width:1024px}}@media (min-width:1024px) and (min-width:1280px){.lg\\:container{max-width:1280px}}@media (min-width:1024px){.lg\\:prose{color:#4a5568;max-width:65ch}.lg\\:prose [class~=lead]{color:#4a5568;font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.lg\\:prose a{color:#1a202c;text-decoration:underline}.lg\\:prose strong{color:#1a202c;font-weight:600}.lg\\:prose ol{counter-reset:list-counter;margin-top:1.25em;margin-bottom:1.25em}.lg\\:prose ol>li{position:relative;counter-increment:list-counter;padding-left:1.75em}.lg\\:prose ol>li:before{content:counter(list-counter) \".\";position:absolute;font-weight:400;color:#718096}.lg\\:prose ul>li{position:relative;padding-left:1.75em}.lg\\:prose ul>li:before{content:\"\";position:absolute;background-color:#cbd5e0;border-radius:50%;width:.375em;height:.375em;top:.6875em;left:.25em}.lg\\:prose hr{border-color:#e2e8f0;border-top-width:1px;margin-top:3em;margin-bottom:3em}.lg\\:prose blockquote{font-weight:500;font-style:italic;color:#1a202c;border-left-width:.25rem;border-left-color:#e2e8f0;quotes:\"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.lg\\:prose blockquote p:first-of-type:before{content:open-quote}.lg\\:prose blockquote p:last-of-type:after{content:close-quote}.lg\\:prose h1{color:#1a202c;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.lg\\:prose h2{color:#dd6b20;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.lg\\:prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.lg\\:prose h3,.lg\\:prose h4{color:#dd6b20;font-weight:600}.lg\\:prose h4{margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.lg\\:prose figure figcaption{color:#718096;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.lg\\:prose code{color:#1a202c;font-weight:600;font-size:.875em}.lg\\:prose code:after,.lg\\:prose code:before{content:\"\"}.lg\\:prose pre{color:#e2e8f0;background-color:#2d3748;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em}.lg\\:prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.lg\\:prose pre code:after,.lg\\:prose pre code:before{content:\"\"}.lg\\:prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.lg\\:prose thead{color:#1a202c;font-weight:600;border-bottom-width:1px;border-bottom-color:#cbd5e0}.lg\\:prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.lg\\:prose tbody tr{border-bottom-width:1px;border-bottom-color:#e2e8f0}.lg\\:prose tbody tr:last-child{border-bottom-width:0}.lg\\:prose tbody td{vertical-align:top;padding:.5714286em}.lg\\:prose{font-size:1rem;line-height:1.75}.lg\\:prose p{margin-top:1.25em;margin-bottom:1.25em}.lg\\:prose figure,.lg\\:prose img,.lg\\:prose video{margin-top:2em;margin-bottom:2em}.lg\\:prose figure>*{margin-top:0;margin-bottom:0}.lg\\:prose h2 code{font-size:.875em}.lg\\:prose h3 code{font-size:.9em}.lg\\:prose ul{margin-top:1.25em;margin-bottom:1.25em}.lg\\:prose li{margin-top:.5em;margin-bottom:.5em}.lg\\:prose ol>li:before{left:0}.lg\\:prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.lg\\:prose>ul>li>:first-child{margin-top:1.25em}.lg\\:prose>ul>li>:last-child{margin-bottom:1.25em}.lg\\:prose>ol>li>:first-child{margin-top:1.25em}.lg\\:prose>ol>li>:last-child{margin-bottom:1.25em}.lg\\:prose ol ol,.lg\\:prose ol ul,.lg\\:prose ul ol,.lg\\:prose ul ul{margin-top:.75em;margin-bottom:.75em}.lg\\:prose h2+*,.lg\\:prose h3+*,.lg\\:prose h4+*,.lg\\:prose hr+*{margin-top:0}.lg\\:prose thead th:first-child{padding-left:0}.lg\\:prose thead th:last-child{padding-right:0}.lg\\:prose tbody td:first-child{padding-left:0}.lg\\:prose tbody td:last-child{padding-right:0}.lg\\:prose>:first-child{margin-top:0}.lg\\:prose>:last-child{margin-bottom:0}.lg\\:prose-sm{font-size:.875rem;line-height:1.7142857}.lg\\:prose-sm p{margin-top:1.1428571em;margin-bottom:1.1428571em}.lg\\:prose-sm [class~=lead]{font-size:1.2857143em;line-height:1.5555556;margin-top:.8888889em;margin-bottom:.8888889em}.lg\\:prose-sm blockquote{margin-top:1.3333333em;margin-bottom:1.3333333em;padding-left:1.1111111em}.lg\\:prose-sm h1{font-size:2.1428571em;margin-top:0;margin-bottom:.8em;line-height:1.2}.lg\\:prose-sm h2{font-size:1.4285714em;margin-top:1.6em;margin-bottom:.8em;line-height:1.4}.lg\\:prose-sm h3{font-size:1.2857143em;margin-top:1.5555556em;margin-bottom:.4444444em;line-height:1.5555556}.lg\\:prose-sm h4{margin-top:1.4285714em;margin-bottom:.5714286em;line-height:1.4285714}.lg\\:prose-sm figure,.lg\\:prose-sm img,.lg\\:prose-sm video{margin-top:1.7142857em;margin-bottom:1.7142857em}.lg\\:prose-sm figure>*{margin-top:0;margin-bottom:0}.lg\\:prose-sm figure figcaption{font-size:.8571429em;line-height:1.3333333;margin-top:.6666667em}.lg\\:prose-sm code{font-size:.8571429em}.lg\\:prose-sm h2 code{font-size:.9em}.lg\\:prose-sm h3 code{font-size:.8888889em}.lg\\:prose-sm pre{font-size:.8571429em;line-height:1.6666667;margin-top:1.6666667em;margin-bottom:1.6666667em;border-radius:.25rem;padding:.6666667em 1em}.lg\\:prose-sm ol,.lg\\:prose-sm ul{margin-top:1.1428571em;margin-bottom:1.1428571em}.lg\\:prose-sm li{margin-top:.2857143em;margin-bottom:.2857143em}.lg\\:prose-sm ol>li{padding-left:1.5714286em}.lg\\:prose-sm ol>li:before{left:0}.lg\\:prose-sm ul>li{padding-left:1.5714286em}.lg\\:prose-sm ul>li:before{height:.3571429em;width:.3571429em;top:.67857em;left:.2142857em}.lg\\:prose-sm>ul>li p{margin-top:.5714286em;margin-bottom:.5714286em}.lg\\:prose-sm>ul>li>:first-child{margin-top:1.1428571em}.lg\\:prose-sm>ul>li>:last-child{margin-bottom:1.1428571em}.lg\\:prose-sm>ol>li>:first-child{margin-top:1.1428571em}.lg\\:prose-sm>ol>li>:last-child{margin-bottom:1.1428571em}.lg\\:prose-sm ol ol,.lg\\:prose-sm ol ul,.lg\\:prose-sm ul ol,.lg\\:prose-sm ul ul{margin-top:.5714286em;margin-bottom:.5714286em}.lg\\:prose-sm hr{margin-top:2.8571429em;margin-bottom:2.8571429em}.lg\\:prose-sm h2+*,.lg\\:prose-sm h3+*,.lg\\:prose-sm h4+*,.lg\\:prose-sm hr+*{margin-top:0}.lg\\:prose-sm table{font-size:.8571429em;line-height:1.5}.lg\\:prose-sm thead th{padding-right:1em;padding-bottom:.6666667em;padding-left:1em}.lg\\:prose-sm thead th:first-child{padding-left:0}.lg\\:prose-sm thead th:last-child{padding-right:0}.lg\\:prose-sm tbody td{padding:.6666667em 1em}.lg\\:prose-sm tbody td:first-child{padding-left:0}.lg\\:prose-sm tbody td:last-child{padding-right:0}.lg\\:prose-sm>:first-child{margin-top:0}.lg\\:prose-sm>:last-child{margin-bottom:0}.lg\\:prose-lg{font-size:1.125rem;line-height:1.7777778}.lg\\:prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.lg\\:prose-lg [class~=lead]{font-size:1.2222222em;line-height:1.4545455;margin-top:1.0909091em;margin-bottom:1.0909091em}.lg\\:prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.lg\\:prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.lg\\:prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.lg\\:prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.lg\\:prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.lg\\:prose-lg figure,.lg\\:prose-lg img,.lg\\:prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.lg\\:prose-lg figure>*{margin-top:0;margin-bottom:0}.lg\\:prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.lg\\:prose-lg code{font-size:.8888889em}.lg\\:prose-lg h2 code{font-size:.8666667em}.lg\\:prose-lg h3 code{font-size:.875em}.lg\\:prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding:1em 1.5em}.lg\\:prose-lg ol,.lg\\:prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.lg\\:prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.lg\\:prose-lg ol>li{padding-left:1.6666667em}.lg\\:prose-lg ol>li:before{left:0}.lg\\:prose-lg ul>li{padding-left:1.6666667em}.lg\\:prose-lg ul>li:before{width:.3333333em;height:.3333333em;top:.72222em;left:.2222222em}.lg\\:prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.lg\\:prose-lg>ul>li>:first-child{margin-top:1.3333333em}.lg\\:prose-lg>ul>li>:last-child{margin-bottom:1.3333333em}.lg\\:prose-lg>ol>li>:first-child{margin-top:1.3333333em}.lg\\:prose-lg>ol>li>:last-child{margin-bottom:1.3333333em}.lg\\:prose-lg ol ol,.lg\\:prose-lg ol ul,.lg\\:prose-lg ul ol,.lg\\:prose-lg ul ul{margin-top:.8888889em;margin-bottom:.8888889em}.lg\\:prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.lg\\:prose-lg h2+*,.lg\\:prose-lg h3+*,.lg\\:prose-lg h4+*,.lg\\:prose-lg hr+*{margin-top:0}.lg\\:prose-lg table{font-size:.8888889em;line-height:1.5}.lg\\:prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.lg\\:prose-lg thead th:first-child{padding-left:0}.lg\\:prose-lg thead th:last-child{padding-right:0}.lg\\:prose-lg tbody td{padding:.75em}.lg\\:prose-lg tbody td:first-child{padding-left:0}.lg\\:prose-lg tbody td:last-child{padding-right:0}.lg\\:prose-lg>:first-child{margin-top:0}.lg\\:prose-lg>:last-child{margin-bottom:0}.lg\\:prose-xl{font-size:1.25rem;line-height:1.8}.lg\\:prose-xl p{margin-top:1.2em;margin-bottom:1.2em}.lg\\:prose-xl [class~=lead]{font-size:1.2em;line-height:1.5;margin-top:1em;margin-bottom:1em}.lg\\:prose-xl blockquote{margin-top:1.6em;margin-bottom:1.6em;padding-left:1.0666667em}.lg\\:prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1}.lg\\:prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111}.lg\\:prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333}.lg\\:prose-xl h4{margin-top:1.8em;margin-bottom:.6em;line-height:1.6}.lg\\:prose-xl figure,.lg\\:prose-xl img,.lg\\:prose-xl video{margin-top:2em;margin-bottom:2em}.lg\\:prose-xl figure>*{margin-top:0;margin-bottom:0}.lg\\:prose-xl figure figcaption{font-size:.9em;line-height:1.5555556;margin-top:1em}.lg\\:prose-xl code{font-size:.9em}.lg\\:prose-xl h2 code{font-size:.8611111em}.lg\\:prose-xl h3 code{font-size:.9em}.lg\\:prose-xl pre{font-size:.9em;line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em}.lg\\:prose-xl ol,.lg\\:prose-xl ul{margin-top:1.2em;margin-bottom:1.2em}.lg\\:prose-xl li{margin-top:.6em;margin-bottom:.6em}.lg\\:prose-xl ol>li{padding-left:1.8em}.lg\\:prose-xl ol>li:before{left:0}.lg\\:prose-xl ul>li{padding-left:1.8em}.lg\\:prose-xl ul>li:before{width:.35em;height:.35em;top:.725em;left:.25em}.lg\\:prose-xl>ul>li p{margin-top:.8em;margin-bottom:.8em}.lg\\:prose-xl>ul>li>:first-child{margin-top:1.2em}.lg\\:prose-xl>ul>li>:last-child{margin-bottom:1.2em}.lg\\:prose-xl>ol>li>:first-child{margin-top:1.2em}.lg\\:prose-xl>ol>li>:last-child{margin-bottom:1.2em}.lg\\:prose-xl ol ol,.lg\\:prose-xl ol ul,.lg\\:prose-xl ul ol,.lg\\:prose-xl ul ul{margin-top:.8em;margin-bottom:.8em}.lg\\:prose-xl hr{margin-top:2.8em;margin-bottom:2.8em}.lg\\:prose-xl h2+*,.lg\\:prose-xl h3+*,.lg\\:prose-xl h4+*,.lg\\:prose-xl hr+*{margin-top:0}.lg\\:prose-xl table{font-size:.9em;line-height:1.5555556}.lg\\:prose-xl thead th{padding-right:.6666667em;padding-bottom:.8888889em;padding-left:.6666667em}.lg\\:prose-xl thead th:first-child{padding-left:0}.lg\\:prose-xl thead th:last-child{padding-right:0}.lg\\:prose-xl tbody td{padding:.8888889em .6666667em}.lg\\:prose-xl tbody td:first-child{padding-left:0}.lg\\:prose-xl tbody td:last-child{padding-right:0}.lg\\:prose-xl>:first-child{margin-top:0}.lg\\:prose-xl>:last-child{margin-bottom:0}.lg\\:prose-2xl{font-size:1.5rem;line-height:1.6666667}.lg\\:prose-2xl p{margin-top:1.3333333em;margin-bottom:1.3333333em}.lg\\:prose-2xl [class~=lead]{font-size:1.25em;line-height:1.4666667;margin-top:1.0666667em;margin-bottom:1.0666667em}.lg\\:prose-2xl blockquote{margin-top:1.7777778em;margin-bottom:1.7777778em;padding-left:1.1111111em}.lg\\:prose-2xl h1{font-size:2.6666667em;margin-top:0;margin-bottom:.875em;line-height:1}.lg\\:prose-2xl h2{font-size:2em;margin-top:1.5em;margin-bottom:.8333333em;line-height:1.0833333}.lg\\:prose-2xl h3{font-size:1.5em;margin-top:1.5555556em;margin-bottom:.6666667em;line-height:1.2222222}.lg\\:prose-2xl h4{margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.lg\\:prose-2xl figure,.lg\\:prose-2xl img,.lg\\:prose-2xl video{margin-top:2em;margin-bottom:2em}.lg\\:prose-2xl figure>*{margin-top:0;margin-bottom:0}.lg\\:prose-2xl figure figcaption{font-size:.8333333em;line-height:1.6;margin-top:1em}.lg\\:prose-2xl code{font-size:.8333333em}.lg\\:prose-2xl h2 code{font-size:.875em}.lg\\:prose-2xl h3 code{font-size:.8888889em}.lg\\:prose-2xl pre{font-size:.8333333em;line-height:1.8;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.2em 1.6em}.lg\\:prose-2xl ol,.lg\\:prose-2xl ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.lg\\:prose-2xl li{margin-top:.5em;margin-bottom:.5em}.lg\\:prose-2xl ol>li{padding-left:1.6666667em}.lg\\:prose-2xl ol>li:before{left:0}.lg\\:prose-2xl ul>li{padding-left:1.6666667em}.lg\\:prose-2xl ul>li:before{width:.3333333em;height:.3333333em;top:.66667em;left:.25em}.lg\\:prose-2xl>ul>li p{margin-top:.8333333em;margin-bottom:.8333333em}.lg\\:prose-2xl>ul>li>:first-child{margin-top:1.3333333em}.lg\\:prose-2xl>ul>li>:last-child{margin-bottom:1.3333333em}.lg\\:prose-2xl>ol>li>:first-child{margin-top:1.3333333em}.lg\\:prose-2xl>ol>li>:last-child{margin-bottom:1.3333333em}.lg\\:prose-2xl ol ol,.lg\\:prose-2xl ol ul,.lg\\:prose-2xl ul ol,.lg\\:prose-2xl ul ul{margin-top:.6666667em;margin-bottom:.6666667em}.lg\\:prose-2xl hr{margin-top:3em;margin-bottom:3em}.lg\\:prose-2xl h2+*,.lg\\:prose-2xl h3+*,.lg\\:prose-2xl h4+*,.lg\\:prose-2xl hr+*{margin-top:0}.lg\\:prose-2xl table{font-size:.8333333em;line-height:1.4}.lg\\:prose-2xl thead th{padding-right:.6em;padding-bottom:.8em;padding-left:.6em}.lg\\:prose-2xl thead th:first-child{padding-left:0}.lg\\:prose-2xl thead th:last-child{padding-right:0}.lg\\:prose-2xl tbody td{padding:.8em .6em}.lg\\:prose-2xl tbody td:first-child{padding-left:0}.lg\\:prose-2xl tbody td:last-child{padding-right:0}.lg\\:prose-2xl>:first-child{margin-top:0}.lg\\:prose-2xl>:last-child{margin-bottom:0}.lg\\:px-6{padding-left:1.5rem;padding-right:1.5rem}}@media (min-width:1280px){.xl\\:container{width:100%}}@media (min-width:1280px) and (min-width:640px){.xl\\:container{max-width:640px}}@media (min-width:1280px) and (min-width:768px){.xl\\:container{max-width:768px}}@media (min-width:1280px) and (min-width:1024px){.xl\\:container{max-width:1024px}}@media (min-width:1280px) and (min-width:1280px){.xl\\:container{max-width:1280px}}@media (min-width:1280px){.xl\\:prose{color:#4a5568;max-width:65ch}.xl\\:prose [class~=lead]{color:#4a5568;font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.xl\\:prose a{color:#1a202c;text-decoration:underline}.xl\\:prose strong{color:#1a202c;font-weight:600}.xl\\:prose ol{counter-reset:list-counter;margin-top:1.25em;margin-bottom:1.25em}.xl\\:prose ol>li{position:relative;counter-increment:list-counter;padding-left:1.75em}.xl\\:prose ol>li:before{content:counter(list-counter) \".\";position:absolute;font-weight:400;color:#718096}.xl\\:prose ul>li{position:relative;padding-left:1.75em}.xl\\:prose ul>li:before{content:\"\";position:absolute;background-color:#cbd5e0;border-radius:50%;width:.375em;height:.375em;top:.6875em;left:.25em}.xl\\:prose hr{border-color:#e2e8f0;border-top-width:1px;margin-top:3em;margin-bottom:3em}.xl\\:prose blockquote{font-weight:500;font-style:italic;color:#1a202c;border-left-width:.25rem;border-left-color:#e2e8f0;quotes:\"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.xl\\:prose blockquote p:first-of-type:before{content:open-quote}.xl\\:prose blockquote p:last-of-type:after{content:close-quote}.xl\\:prose h1{color:#1a202c;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.xl\\:prose h2{color:#dd6b20;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.xl\\:prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.xl\\:prose h3,.xl\\:prose h4{color:#dd6b20;font-weight:600}.xl\\:prose h4{margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.xl\\:prose figure figcaption{color:#718096;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.xl\\:prose code{color:#1a202c;font-weight:600;font-size:.875em}.xl\\:prose code:after,.xl\\:prose code:before{content:\"\"}.xl\\:prose pre{color:#e2e8f0;background-color:#2d3748;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em}.xl\\:prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.xl\\:prose pre code:after,.xl\\:prose pre code:before{content:\"\"}.xl\\:prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.xl\\:prose thead{color:#1a202c;font-weight:600;border-bottom-width:1px;border-bottom-color:#cbd5e0}.xl\\:prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.xl\\:prose tbody tr{border-bottom-width:1px;border-bottom-color:#e2e8f0}.xl\\:prose tbody tr:last-child{border-bottom-width:0}.xl\\:prose tbody td{vertical-align:top;padding:.5714286em}.xl\\:prose{font-size:1rem;line-height:1.75}.xl\\:prose p{margin-top:1.25em;margin-bottom:1.25em}.xl\\:prose figure,.xl\\:prose img,.xl\\:prose video{margin-top:2em;margin-bottom:2em}.xl\\:prose figure>*{margin-top:0;margin-bottom:0}.xl\\:prose h2 code{font-size:.875em}.xl\\:prose h3 code{font-size:.9em}.xl\\:prose ul{margin-top:1.25em;margin-bottom:1.25em}.xl\\:prose li{margin-top:.5em;margin-bottom:.5em}.xl\\:prose ol>li:before{left:0}.xl\\:prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.xl\\:prose>ul>li>:first-child{margin-top:1.25em}.xl\\:prose>ul>li>:last-child{margin-bottom:1.25em}.xl\\:prose>ol>li>:first-child{margin-top:1.25em}.xl\\:prose>ol>li>:last-child{margin-bottom:1.25em}.xl\\:prose ol ol,.xl\\:prose ol ul,.xl\\:prose ul ol,.xl\\:prose ul ul{margin-top:.75em;margin-bottom:.75em}.xl\\:prose h2+*,.xl\\:prose h3+*,.xl\\:prose h4+*,.xl\\:prose hr+*{margin-top:0}.xl\\:prose thead th:first-child{padding-left:0}.xl\\:prose thead th:last-child{padding-right:0}.xl\\:prose tbody td:first-child{padding-left:0}.xl\\:prose tbody td:last-child{padding-right:0}.xl\\:prose>:first-child{margin-top:0}.xl\\:prose>:last-child{margin-bottom:0}.xl\\:prose-sm{font-size:.875rem;line-height:1.7142857}.xl\\:prose-sm p{margin-top:1.1428571em;margin-bottom:1.1428571em}.xl\\:prose-sm [class~=lead]{font-size:1.2857143em;line-height:1.5555556;margin-top:.8888889em;margin-bottom:.8888889em}.xl\\:prose-sm blockquote{margin-top:1.3333333em;margin-bottom:1.3333333em;padding-left:1.1111111em}.xl\\:prose-sm h1{font-size:2.1428571em;margin-top:0;margin-bottom:.8em;line-height:1.2}.xl\\:prose-sm h2{font-size:1.4285714em;margin-top:1.6em;margin-bottom:.8em;line-height:1.4}.xl\\:prose-sm h3{font-size:1.2857143em;margin-top:1.5555556em;margin-bottom:.4444444em;line-height:1.5555556}.xl\\:prose-sm h4{margin-top:1.4285714em;margin-bottom:.5714286em;line-height:1.4285714}.xl\\:prose-sm figure,.xl\\:prose-sm img,.xl\\:prose-sm video{margin-top:1.7142857em;margin-bottom:1.7142857em}.xl\\:prose-sm figure>*{margin-top:0;margin-bottom:0}.xl\\:prose-sm figure figcaption{font-size:.8571429em;line-height:1.3333333;margin-top:.6666667em}.xl\\:prose-sm code{font-size:.8571429em}.xl\\:prose-sm h2 code{font-size:.9em}.xl\\:prose-sm h3 code{font-size:.8888889em}.xl\\:prose-sm pre{font-size:.8571429em;line-height:1.6666667;margin-top:1.6666667em;margin-bottom:1.6666667em;border-radius:.25rem;padding:.6666667em 1em}.xl\\:prose-sm ol,.xl\\:prose-sm ul{margin-top:1.1428571em;margin-bottom:1.1428571em}.xl\\:prose-sm li{margin-top:.2857143em;margin-bottom:.2857143em}.xl\\:prose-sm ol>li{padding-left:1.5714286em}.xl\\:prose-sm ol>li:before{left:0}.xl\\:prose-sm ul>li{padding-left:1.5714286em}.xl\\:prose-sm ul>li:before{height:.3571429em;width:.3571429em;top:.67857em;left:.2142857em}.xl\\:prose-sm>ul>li p{margin-top:.5714286em;margin-bottom:.5714286em}.xl\\:prose-sm>ul>li>:first-child{margin-top:1.1428571em}.xl\\:prose-sm>ul>li>:last-child{margin-bottom:1.1428571em}.xl\\:prose-sm>ol>li>:first-child{margin-top:1.1428571em}.xl\\:prose-sm>ol>li>:last-child{margin-bottom:1.1428571em}.xl\\:prose-sm ol ol,.xl\\:prose-sm ol ul,.xl\\:prose-sm ul ol,.xl\\:prose-sm ul ul{margin-top:.5714286em;margin-bottom:.5714286em}.xl\\:prose-sm hr{margin-top:2.8571429em;margin-bottom:2.8571429em}.xl\\:prose-sm h2+*,.xl\\:prose-sm h3+*,.xl\\:prose-sm h4+*,.xl\\:prose-sm hr+*{margin-top:0}.xl\\:prose-sm table{font-size:.8571429em;line-height:1.5}.xl\\:prose-sm thead th{padding-right:1em;padding-bottom:.6666667em;padding-left:1em}.xl\\:prose-sm thead th:first-child{padding-left:0}.xl\\:prose-sm thead th:last-child{padding-right:0}.xl\\:prose-sm tbody td{padding:.6666667em 1em}.xl\\:prose-sm tbody td:first-child{padding-left:0}.xl\\:prose-sm tbody td:last-child{padding-right:0}.xl\\:prose-sm>:first-child{margin-top:0}.xl\\:prose-sm>:last-child{margin-bottom:0}.xl\\:prose-lg{font-size:1.125rem;line-height:1.7777778}.xl\\:prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.xl\\:prose-lg [class~=lead]{font-size:1.2222222em;line-height:1.4545455;margin-top:1.0909091em;margin-bottom:1.0909091em}.xl\\:prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.xl\\:prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.xl\\:prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.xl\\:prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.xl\\:prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.xl\\:prose-lg figure,.xl\\:prose-lg img,.xl\\:prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.xl\\:prose-lg figure>*{margin-top:0;margin-bottom:0}.xl\\:prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.xl\\:prose-lg code{font-size:.8888889em}.xl\\:prose-lg h2 code{font-size:.8666667em}.xl\\:prose-lg h3 code{font-size:.875em}.xl\\:prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding:1em 1.5em}.xl\\:prose-lg ol,.xl\\:prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.xl\\:prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.xl\\:prose-lg ol>li{padding-left:1.6666667em}.xl\\:prose-lg ol>li:before{left:0}.xl\\:prose-lg ul>li{padding-left:1.6666667em}.xl\\:prose-lg ul>li:before{width:.3333333em;height:.3333333em;top:.72222em;left:.2222222em}.xl\\:prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.xl\\:prose-lg>ul>li>:first-child{margin-top:1.3333333em}.xl\\:prose-lg>ul>li>:last-child{margin-bottom:1.3333333em}.xl\\:prose-lg>ol>li>:first-child{margin-top:1.3333333em}.xl\\:prose-lg>ol>li>:last-child{margin-bottom:1.3333333em}.xl\\:prose-lg ol ol,.xl\\:prose-lg ol ul,.xl\\:prose-lg ul ol,.xl\\:prose-lg ul ul{margin-top:.8888889em;margin-bottom:.8888889em}.xl\\:prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.xl\\:prose-lg h2+*,.xl\\:prose-lg h3+*,.xl\\:prose-lg h4+*,.xl\\:prose-lg hr+*{margin-top:0}.xl\\:prose-lg table{font-size:.8888889em;line-height:1.5}.xl\\:prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.xl\\:prose-lg thead th:first-child{padding-left:0}.xl\\:prose-lg thead th:last-child{padding-right:0}.xl\\:prose-lg tbody td{padding:.75em}.xl\\:prose-lg tbody td:first-child{padding-left:0}.xl\\:prose-lg tbody td:last-child{padding-right:0}.xl\\:prose-lg>:first-child{margin-top:0}.xl\\:prose-lg>:last-child{margin-bottom:0}.xl\\:prose-xl{font-size:1.25rem;line-height:1.8}.xl\\:prose-xl p{margin-top:1.2em;margin-bottom:1.2em}.xl\\:prose-xl [class~=lead]{font-size:1.2em;line-height:1.5;margin-top:1em;margin-bottom:1em}.xl\\:prose-xl blockquote{margin-top:1.6em;margin-bottom:1.6em;padding-left:1.0666667em}.xl\\:prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1}.xl\\:prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111}.xl\\:prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333}.xl\\:prose-xl h4{margin-top:1.8em;margin-bottom:.6em;line-height:1.6}.xl\\:prose-xl figure,.xl\\:prose-xl img,.xl\\:prose-xl video{margin-top:2em;margin-bottom:2em}.xl\\:prose-xl figure>*{margin-top:0;margin-bottom:0}.xl\\:prose-xl figure figcaption{font-size:.9em;line-height:1.5555556;margin-top:1em}.xl\\:prose-xl code{font-size:.9em}.xl\\:prose-xl h2 code{font-size:.8611111em}.xl\\:prose-xl h3 code{font-size:.9em}.xl\\:prose-xl pre{font-size:.9em;line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em}.xl\\:prose-xl ol,.xl\\:prose-xl ul{margin-top:1.2em;margin-bottom:1.2em}.xl\\:prose-xl li{margin-top:.6em;margin-bottom:.6em}.xl\\:prose-xl ol>li{padding-left:1.8em}.xl\\:prose-xl ol>li:before{left:0}.xl\\:prose-xl ul>li{padding-left:1.8em}.xl\\:prose-xl ul>li:before{width:.35em;height:.35em;top:.725em;left:.25em}.xl\\:prose-xl>ul>li p{margin-top:.8em;margin-bottom:.8em}.xl\\:prose-xl>ul>li>:first-child{margin-top:1.2em}.xl\\:prose-xl>ul>li>:last-child{margin-bottom:1.2em}.xl\\:prose-xl>ol>li>:first-child{margin-top:1.2em}.xl\\:prose-xl>ol>li>:last-child{margin-bottom:1.2em}.xl\\:prose-xl ol ol,.xl\\:prose-xl ol ul,.xl\\:prose-xl ul ol,.xl\\:prose-xl ul ul{margin-top:.8em;margin-bottom:.8em}.xl\\:prose-xl hr{margin-top:2.8em;margin-bottom:2.8em}.xl\\:prose-xl h2+*,.xl\\:prose-xl h3+*,.xl\\:prose-xl h4+*,.xl\\:prose-xl hr+*{margin-top:0}.xl\\:prose-xl table{font-size:.9em;line-height:1.5555556}.xl\\:prose-xl thead th{padding-right:.6666667em;padding-bottom:.8888889em;padding-left:.6666667em}.xl\\:prose-xl thead th:first-child{padding-left:0}.xl\\:prose-xl thead th:last-child{padding-right:0}.xl\\:prose-xl tbody td{padding:.8888889em .6666667em}.xl\\:prose-xl tbody td:first-child{padding-left:0}.xl\\:prose-xl tbody td:last-child{padding-right:0}.xl\\:prose-xl>:first-child{margin-top:0}.xl\\:prose-xl>:last-child{margin-bottom:0}.xl\\:prose-2xl{font-size:1.5rem;line-height:1.6666667}.xl\\:prose-2xl p{margin-top:1.3333333em;margin-bottom:1.3333333em}.xl\\:prose-2xl [class~=lead]{font-size:1.25em;line-height:1.4666667;margin-top:1.0666667em;margin-bottom:1.0666667em}.xl\\:prose-2xl blockquote{margin-top:1.7777778em;margin-bottom:1.7777778em;padding-left:1.1111111em}.xl\\:prose-2xl h1{font-size:2.6666667em;margin-top:0;margin-bottom:.875em;line-height:1}.xl\\:prose-2xl h2{font-size:2em;margin-top:1.5em;margin-bottom:.8333333em;line-height:1.0833333}.xl\\:prose-2xl h3{font-size:1.5em;margin-top:1.5555556em;margin-bottom:.6666667em;line-height:1.2222222}.xl\\:prose-2xl h4{margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.xl\\:prose-2xl figure,.xl\\:prose-2xl img,.xl\\:prose-2xl video{margin-top:2em;margin-bottom:2em}.xl\\:prose-2xl figure>*{margin-top:0;margin-bottom:0}.xl\\:prose-2xl figure figcaption{font-size:.8333333em;line-height:1.6;margin-top:1em}.xl\\:prose-2xl code{font-size:.8333333em}.xl\\:prose-2xl h2 code{font-size:.875em}.xl\\:prose-2xl h3 code{font-size:.8888889em}.xl\\:prose-2xl pre{font-size:.8333333em;line-height:1.8;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.2em 1.6em}.xl\\:prose-2xl ol,.xl\\:prose-2xl ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.xl\\:prose-2xl li{margin-top:.5em;margin-bottom:.5em}.xl\\:prose-2xl ol>li{padding-left:1.6666667em}.xl\\:prose-2xl ol>li:before{left:0}.xl\\:prose-2xl ul>li{padding-left:1.6666667em}.xl\\:prose-2xl ul>li:before{width:.3333333em;height:.3333333em;top:.66667em;left:.25em}.xl\\:prose-2xl>ul>li p{margin-top:.8333333em;margin-bottom:.8333333em}.xl\\:prose-2xl>ul>li>:first-child{margin-top:1.3333333em}.xl\\:prose-2xl>ul>li>:last-child{margin-bottom:1.3333333em}.xl\\:prose-2xl>ol>li>:first-child{margin-top:1.3333333em}.xl\\:prose-2xl>ol>li>:last-child{margin-bottom:1.3333333em}.xl\\:prose-2xl ol ol,.xl\\:prose-2xl ol ul,.xl\\:prose-2xl ul ol,.xl\\:prose-2xl ul ul{margin-top:.6666667em;margin-bottom:.6666667em}.xl\\:prose-2xl hr{margin-top:3em;margin-bottom:3em}.xl\\:prose-2xl h2+*,.xl\\:prose-2xl h3+*,.xl\\:prose-2xl h4+*,.xl\\:prose-2xl hr+*{margin-top:0}.xl\\:prose-2xl table{font-size:.8333333em;line-height:1.4}.xl\\:prose-2xl thead th{padding-right:.6em;padding-bottom:.8em;padding-left:.6em}.xl\\:prose-2xl thead th:first-child{padding-left:0}.xl\\:prose-2xl thead th:last-child{padding-right:0}.xl\\:prose-2xl tbody td{padding:.8em .6em}.xl\\:prose-2xl tbody td:first-child{padding-left:0}.xl\\:prose-2xl tbody td:last-child{padding-right:0}.xl\\:prose-2xl>:first-child{margin-top:0}.xl\\:prose-2xl>:last-child{margin-bottom:0}}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(69);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
__webpack_require__(7).default("2998b330", content, true)

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".page-enter-active,.page-leave-active{transition:opacity .3s}.page-enter,.page-leave-active{opacity:0}.nuxt-content-highlight{position:relative}.copy{position:absolute;right:0;bottom:0;margin-right:2.5rem;margin-top:2.5rem;line-height:1;--text-opacity:1;color:#1a202c;color:rgba(26,32,44,var(--text-opacity));padding:.75rem .5rem;font-size:.875rem;text-transform:uppercase;border-radius:.375rem;font-weight:600}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(71);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
__webpack_require__(7).default("517a8dd7", content, true)

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "code[class*=language-],pre[class*=language-]{color:#000;background:none;text-shadow:0 1px #fff;font-family:Consolas,Monaco,\"Andale Mono\",\"Ubuntu Mono\",monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_3_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_3_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_3_oneOf_1_2_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".prose code{color:orange}.prose a{color:#2563eb;text-decoration:none}.prose a:hover{color:#3b82f6;text-decoration:none}", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

// This file is intentionally left empty for noop aliases

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = require("property-information");

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = require("vue-server-renderer/basic");

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "connectClearRefinements", function() { return /* reexport */ clear_refinements_connectClearRefinements; });
__webpack_require__.d(__webpack_exports__, "connectCurrentRefinements", function() { return /* reexport */ current_refinements_connectCurrentRefinements; });
__webpack_require__.d(__webpack_exports__, "connectHierarchicalMenu", function() { return /* reexport */ connectHierarchicalMenu; });
__webpack_require__.d(__webpack_exports__, "connectHits", function() { return /* reexport */ hits_connectHits; });
__webpack_require__.d(__webpack_exports__, "connectHitsWithInsights", function() { return /* reexport */ hits_connectHitsWithInsights; });
__webpack_require__.d(__webpack_exports__, "connectHitsPerPage", function() { return /* reexport */ hits_per_page_connectHitsPerPage; });
__webpack_require__.d(__webpack_exports__, "connectInfiniteHits", function() { return /* reexport */ infinite_hits_connectInfiniteHits; });
__webpack_require__.d(__webpack_exports__, "connectInfiniteHitsWithInsights", function() { return /* reexport */ infinite_hits_connectInfiniteHitsWithInsights; });
__webpack_require__.d(__webpack_exports__, "connectMenu", function() { return /* reexport */ connectMenu; });
__webpack_require__.d(__webpack_exports__, "connectNumericMenu", function() { return /* reexport */ numeric_menu_connectNumericMenu; });
__webpack_require__.d(__webpack_exports__, "connectPagination", function() { return /* reexport */ pagination_connectPagination; });
__webpack_require__.d(__webpack_exports__, "connectRange", function() { return /* reexport */ range_connectRange; });
__webpack_require__.d(__webpack_exports__, "connectRefinementList", function() { return /* reexport */ connectRefinementList; });
__webpack_require__.d(__webpack_exports__, "connectSearchBox", function() { return /* reexport */ connectSearchBox; });
__webpack_require__.d(__webpack_exports__, "connectSortBy", function() { return /* reexport */ connectSortBy; });
__webpack_require__.d(__webpack_exports__, "connectRatingMenu", function() { return /* reexport */ connectRatingMenu; });
__webpack_require__.d(__webpack_exports__, "connectStats", function() { return /* reexport */ connectStats; });
__webpack_require__.d(__webpack_exports__, "connectToggleRefinement", function() { return /* reexport */ connectToggleRefinement; });
__webpack_require__.d(__webpack_exports__, "connectBreadcrumb", function() { return /* reexport */ breadcrumb_connectBreadcrumb; });
__webpack_require__.d(__webpack_exports__, "connectGeoSearch", function() { return /* reexport */ geo_search_connectGeoSearch; });
__webpack_require__.d(__webpack_exports__, "connectPoweredBy", function() { return /* reexport */ powered_by_connectPoweredBy; });
__webpack_require__.d(__webpack_exports__, "connectConfigure", function() { return /* reexport */ configure_connectConfigure; });
__webpack_require__.d(__webpack_exports__, "EXPERIMENTAL_connectConfigureRelatedItems", function() { return /* reexport */ configure_related_items_connectConfigureRelatedItems; });
__webpack_require__.d(__webpack_exports__, "connectAutocomplete", function() { return /* reexport */ autocomplete_connectAutocomplete; });
__webpack_require__.d(__webpack_exports__, "connectQueryRules", function() { return /* reexport */ query_rules_connectQueryRules; });
__webpack_require__.d(__webpack_exports__, "connectVoiceSearch", function() { return /* reexport */ voice_search_connectVoiceSearch; });

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js
var documentation = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js
var noop = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/checkRendering.js
var checkRendering = __webpack_require__(35);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/clearRefinements.js
var clearRefinements = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/mergeSearchParameters.js
var mergeSearchParameters = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/uniq.js
var uniq = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getRefinements.js
var getRefinements = __webpack_require__(37);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/clear-refinements/connectClearRefinements.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'clear-refinements',
  connector: true
});

var connectClearRefinements_connectClearRefinements = function connectClearRefinements(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        _ref$includedAttribut = _ref.includedAttributes,
        includedAttributes = _ref$includedAttribut === void 0 ? [] : _ref$includedAttribut,
        _ref$excludedAttribut = _ref.excludedAttributes,
        excludedAttributes = _ref$excludedAttribut === void 0 ? ['query'] : _ref$excludedAttribut,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    if (widgetParams.includedAttributes && widgetParams.excludedAttributes) {
      throw new Error(withUsage('The options `includedAttributes` and `excludedAttributes` cannot be used together.'));
    }

    var connectorState = {
      refine: noop["a" /* default */],
      createURL: function createURL() {
        return '';
      },
      attributesToClear: []
    };

    var cachedRefine = function cachedRefine() {
      return connectorState.refine();
    };

    var cachedCreateURL = function cachedCreateURL() {
      return connectorState.createURL();
    };

    return {
      $$type: 'ais.clearRefinements',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose() {
        unmountFn();
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return _objectSpread({}, renderState, {
          clearRefinements: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var createURL = _ref2.createURL,
            scopedResults = _ref2.scopedResults;
        connectorState.attributesToClear = scopedResults.reduce(function (results, scopedResult) {
          return results.concat(getAttributesToClear({
            scopedResult: scopedResult,
            includedAttributes: includedAttributes,
            excludedAttributes: excludedAttributes,
            transformItems: transformItems
          }));
        }, []);

        connectorState.refine = function () {
          connectorState.attributesToClear.forEach(function (_ref3) {
            var indexHelper = _ref3.helper,
                items = _ref3.items;
            indexHelper.setState(Object(clearRefinements["a" /* default */])({
              helper: indexHelper,
              attributesToClear: items
            })).search();
          });
        };

        connectorState.createURL = function () {
          return createURL(mergeSearchParameters["a" /* default */].apply(void 0, _toConsumableArray(connectorState.attributesToClear.map(function (_ref4) {
            var indexHelper = _ref4.helper,
                items = _ref4.items;
            return Object(clearRefinements["a" /* default */])({
              helper: indexHelper,
              attributesToClear: items
            });
          }))));
        };

        return {
          hasRefinements: connectorState.attributesToClear.some(function (attributeToClear) {
            return attributeToClear.items.length > 0;
          }),
          refine: cachedRefine,
          createURL: cachedCreateURL,
          widgetParams: widgetParams
        };
      }
    };
  };
};

function getAttributesToClear(_ref5) {
  var scopedResult = _ref5.scopedResult,
      includedAttributes = _ref5.includedAttributes,
      excludedAttributes = _ref5.excludedAttributes,
      transformItems = _ref5.transformItems;
  var clearsQuery = includedAttributes.indexOf('query') !== -1 || excludedAttributes.indexOf('query') === -1;
  return {
    helper: scopedResult.helper,
    items: transformItems(Object(uniq["a" /* default */])(Object(getRefinements["a" /* default */])(scopedResult.results, scopedResult.helper.state, clearsQuery).map(function (refinement) {
      return refinement.attribute;
    }).filter(function (attribute) {
      return (// If the array is empty (default case), we keep all the attributes
        includedAttributes.length === 0 || // Otherwise, only add the specified attributes
        includedAttributes.indexOf(attribute) !== -1
      );
    }).filter(function (attribute) {
      return (// If the query is included, we ignore the default `excludedAttributes = ['query']`
        attribute === 'query' && clearsQuery || // Otherwise, ignore the excluded attributes
        excludedAttributes.indexOf(attribute) === -1
      );
    })))
  };
}

/* harmony default export */ var clear_refinements_connectClearRefinements = (connectClearRefinements_connectClearRefinements);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/current-refinements/connectCurrentRefinements.js
function connectCurrentRefinements_toConsumableArray(arr) {
  return connectCurrentRefinements_arrayWithoutHoles(arr) || connectCurrentRefinements_iterableToArray(arr) || connectCurrentRefinements_nonIterableSpread();
}

function connectCurrentRefinements_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectCurrentRefinements_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectCurrentRefinements_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function connectCurrentRefinements_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectCurrentRefinements_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectCurrentRefinements_ownKeys(Object(source), true).forEach(function (key) {
        connectCurrentRefinements_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectCurrentRefinements_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectCurrentRefinements_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectCurrentRefinements_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'current-refinements',
  connector: true
});

var connectCurrentRefinements_connectCurrentRefinements = function connectCurrentRefinements(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectCurrentRefinements_withUsage());
  return function (widgetParams) {
    if ((widgetParams || {}).includedAttributes && (widgetParams || {}).excludedAttributes) {
      throw new Error(connectCurrentRefinements_withUsage('The options `includedAttributes` and `excludedAttributes` cannot be used together.'));
    }

    var _ref = widgetParams || {},
        includedAttributes = _ref.includedAttributes,
        _ref$excludedAttribut = _ref.excludedAttributes,
        excludedAttributes = _ref$excludedAttribut === void 0 ? ['query'] : _ref$excludedAttribut,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    return {
      $$type: 'ais.currentRefinements',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectCurrentRefinements_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectCurrentRefinements_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose() {
        unmountFn();
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectCurrentRefinements_objectSpread({}, renderState, {
          currentRefinements: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var results = _ref2.results,
            scopedResults = _ref2.scopedResults,
            _createURL = _ref2.createURL,
            helper = _ref2.helper;

        function getItems() {
          if (!results) {
            return transformItems(getRefinementsItems({
              results: {},
              helper: helper,
              includedAttributes: includedAttributes,
              excludedAttributes: excludedAttributes
            }));
          }

          return scopedResults.reduce(function (accResults, scopedResult) {
            return accResults.concat(transformItems(getRefinementsItems({
              results: scopedResult.results,
              helper: scopedResult.helper,
              includedAttributes: includedAttributes,
              excludedAttributes: excludedAttributes
            })));
          }, []);
        }

        return {
          items: getItems(),
          refine: function refine(refinement) {
            return clearRefinement(helper, refinement);
          },
          createURL: function createURL(refinement) {
            return _createURL(clearRefinementFromState(helper.state, refinement));
          },
          widgetParams: widgetParams
        };
      }
    };
  };
};

function getRefinementsItems(_ref3) {
  var results = _ref3.results,
      helper = _ref3.helper,
      includedAttributes = _ref3.includedAttributes,
      excludedAttributes = _ref3.excludedAttributes;
  var clearsQuery = (includedAttributes || []).indexOf('query') !== -1 || (excludedAttributes || []).indexOf('query') === -1;
  var filterFunction = includedAttributes ? function (item) {
    return includedAttributes.indexOf(item.attribute) !== -1;
  } : function (item) {
    return excludedAttributes.indexOf(item.attribute) === -1;
  };
  var items = Object(getRefinements["a" /* default */])(results, helper.state, clearsQuery).map(normalizeRefinement).filter(filterFunction);
  return items.reduce(function (allItems, currentItem) {
    return [].concat(connectCurrentRefinements_toConsumableArray(allItems.filter(function (item) {
      return item.attribute !== currentItem.attribute;
    })), [{
      indexName: helper.state.index,
      attribute: currentItem.attribute,
      label: currentItem.attribute,
      refinements: items.filter(function (result) {
        return result.attribute === currentItem.attribute;
      }) // We want to keep the order of refinements except the numeric ones.
      .sort(function (a, b) {
        return a.type === 'numeric' ? a.value - b.value : 0;
      }),
      refine: function refine(refinement) {
        return clearRefinement(helper, refinement);
      }
    }]);
  }, []);
}

function clearRefinementFromState(state, refinement) {
  switch (refinement.type) {
    case 'facet':
      return state.removeFacetRefinement(refinement.attribute, String(refinement.value));

    case 'disjunctive':
      return state.removeDisjunctiveFacetRefinement(refinement.attribute, String(refinement.value));

    case 'hierarchical':
      return state.removeHierarchicalFacetRefinement(refinement.attribute);

    case 'exclude':
      return state.removeExcludeRefinement(refinement.attribute, String(refinement.value));

    case 'numeric':
      return state.removeNumericRefinement(refinement.attribute, refinement.operator, String(refinement.value));

    case 'tag':
      return state.removeTagRefinement(String(refinement.value));

    case 'query':
      return state.setQueryParameter('query', '');

    default:
       false ? undefined : void 0;
      return state;
  }
}

function clearRefinement(helper, refinement) {
  helper.setState(clearRefinementFromState(helper.state, refinement)).search();
}

function getOperatorSymbol(operator) {
  switch (operator) {
    case '>=':
      return '≥';

    case '<=':
      return '≤';

    default:
      return operator;
  }
}

function normalizeRefinement(refinement) {
  var value = refinement.type === 'numeric' ? Number(refinement.name) : refinement.name;
  var label = refinement.operator ? "".concat(getOperatorSymbol(refinement.operator), " ").concat(refinement.name) : refinement.name;
  var normalizedRefinement = {
    attribute: refinement.attribute,
    type: refinement.type,
    value: value,
    label: label
  };

  if (refinement.operator !== undefined) {
    normalizedRefinement.operator = refinement.operator;
  }

  if (refinement.count !== undefined) {
    normalizedRefinement.count = refinement.count;
  }

  if (refinement.exhaustive !== undefined) {
    normalizedRefinement.exhaustive = refinement.exhaustive;
  }

  return normalizedRefinement;
}

/* harmony default export */ var current_refinements_connectCurrentRefinements = (connectCurrentRefinements_connectCurrentRefinements);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForFacet.js
var createSendEventForFacet = __webpack_require__(38);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hierarchical-menu/connectHierarchicalMenu.js
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function connectHierarchicalMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectHierarchicalMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectHierarchicalMenu_ownKeys(Object(source), true).forEach(function (key) {
        connectHierarchicalMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectHierarchicalMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectHierarchicalMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


var connectHierarchicalMenu_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'hierarchical-menu',
  connector: true
});
/**
 * @typedef {Object} HierarchicalMenuItem
 * @property {string} value Value of the menu item.
 * @property {string} label Human-readable value of the menu item.
 * @property {number} count Number of matched results after refinement is applied.
 * @property {isRefined} boolean Indicates if the refinement is applied.
 * @property {Object} [data = undefined] n+1 level of items, same structure HierarchicalMenuItem (default: `undefined`).
 */

/**
 * @typedef {Object} CustomHierarchicalMenuWidgetOptions
 * @property {string[]} attributes Attributes to use to generate the hierarchy of the menu.
 * @property {string} [separator = '>'] Separator used in the attributes to separate level values.
 * @property {string} [rootPath = null] Prefix path to use if the first level is not the root level.
 * @property {boolean} [showParentLevel=false] Show the siblings of the selected parent levels of the current refined value. This
 * does not impact the root level.
 * @property {number} [limit = 10] Max number of values to display.
 * @property {boolean} [showMore = false] Whether to display the "show more" button.
 * @property {number} [showMoreLimit = 20] Max number of values to display when showing more.
 * @property  {string[]|function} [sortBy = ['name:asc']] How to sort refinements. Possible values: `count|isRefined|name:asc|name:desc`.
 *
 * You can also use a sort function that behaves like the standard Javascript [compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Syntax).
 * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.
 */

/**
 * @typedef {Object} HierarchicalMenuRenderingOptions
 * @property {function(item.value): string} createURL Creates an url for the next state for a clicked item.
 * @property {HierarchicalMenuItem[]} items Values to be rendered.
 * @property {function(item.value)} refine Sets the path of the hierarchical filter and triggers a new search.
 * @property {Object} widgetParams All original `CustomHierarchicalMenuWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * **HierarchicalMenu** connector provides the logic to build a custom widget
 * that will give the user the ability to explore facets in a tree-like structure.
 *
 * This is commonly used for multi-level categorization of products on e-commerce
 * websites. From a UX point of view, we suggest not displaying more than two
 * levels deep.
 *
 * @type {Connector}
 * @param {function(HierarchicalMenuRenderingOptions, boolean)} renderFn Rendering function for the custom **HierarchicalMenu** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomHierarchicalMenuWidgetOptions)} Re-usable widget factory for a custom **HierarchicalMenu** widget.
 */

function connectHierarchicalMenu(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectHierarchicalMenu_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attributes = widgetParams.attributes,
        _widgetParams$separat = widgetParams.separator,
        separator = _widgetParams$separat === void 0 ? ' > ' : _widgetParams$separat,
        _widgetParams$rootPat = widgetParams.rootPath,
        rootPath = _widgetParams$rootPat === void 0 ? null : _widgetParams$rootPat,
        _widgetParams$showPar = widgetParams.showParentLevel,
        showParentLevel = _widgetParams$showPar === void 0 ? true : _widgetParams$showPar,
        _widgetParams$limit = widgetParams.limit,
        limit = _widgetParams$limit === void 0 ? 10 : _widgetParams$limit,
        _widgetParams$showMor = widgetParams.showMore,
        showMore = _widgetParams$showMor === void 0 ? false : _widgetParams$showMor,
        _widgetParams$showMor2 = widgetParams.showMoreLimit,
        showMoreLimit = _widgetParams$showMor2 === void 0 ? 20 : _widgetParams$showMor2,
        _widgetParams$sortBy = widgetParams.sortBy,
        sortBy = _widgetParams$sortBy === void 0 ? ['name:asc'] : _widgetParams$sortBy,
        _widgetParams$transfo = widgetParams.transformItems,
        transformItems = _widgetParams$transfo === void 0 ? function (items) {
      return items;
    } : _widgetParams$transfo;

    if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {
      throw new Error(connectHierarchicalMenu_withUsage('The `attributes` option expects an array of strings.'));
    }

    if (showMore === true && showMoreLimit <= limit) {
      throw new Error(connectHierarchicalMenu_withUsage('The `showMoreLimit` option must be greater than `limit`.'));
    } // we need to provide a hierarchicalFacet name for the search state
    // so that we can always map $hierarchicalFacetName => real attributes
    // we use the first attribute name


    var _attributes = _slicedToArray(attributes, 1),
        hierarchicalFacetName = _attributes[0];

    var sendEvent; // Provide the same function to the `renderFn` so that way the user
    // has to only bind it once when `isFirstRendering` for instance

    var toggleShowMore = function toggleShowMore() {};

    function cachedToggleShowMore() {
      toggleShowMore();
    }

    return {
      $$type: 'ais.hierarchicalMenu',
      isShowingMore: false,
      createToggleShowMore: function createToggleShowMore(renderOptions) {
        var _this = this;

        return function () {
          _this.isShowingMore = !_this.isShowingMore;

          _this.render(renderOptions);
        };
      },
      getLimit: function getLimit() {
        return this.isShowingMore ? showMoreLimit : limit;
      },
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectHierarchicalMenu_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      _prepareFacetValues: function _prepareFacetValues(facetValues) {
        var _this2 = this;

        return facetValues.slice(0, this.getLimit()).map(function (_ref) {
          var label = _ref.name,
              value = _ref.path,
              subValue = _objectWithoutProperties(_ref, ["name", "path"]);

          if (Array.isArray(subValue.data)) {
            subValue.data = _this2._prepareFacetValues(subValue.data);
          }

          return connectHierarchicalMenu_objectSpread({}, subValue, {
            label: label,
            value: value
          });
        });
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        toggleShowMore = this.createToggleShowMore(renderOptions);
        renderFn(connectHierarchicalMenu_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },

      /**
       * @param {Object} param0 cleanup arguments
       * @param {any} param0.state current search parameters
       * @returns {any} next search parameters
       */
      dispose: function dispose(_ref2) {
        var state = _ref2.state;
        unmountFn();
        return state.removeHierarchicalFacet(hierarchicalFacetName).setQueryParameter('maxValuesPerFacet', undefined);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectHierarchicalMenu_objectSpread({}, renderState, {
          hierarchicalMenu: connectHierarchicalMenu_objectSpread({}, renderState.hierarchicalMenu, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref3) {
        var _this3 = this;

        var results = _ref3.results,
            state = _ref3.state,
            createURL = _ref3.createURL,
            instantSearchInstance = _ref3.instantSearchInstance,
            helper = _ref3.helper; // Bind createURL to this specific attribute

        function _createURL(facetValue) {
          return createURL(state.toggleRefinement(hierarchicalFacetName, facetValue));
        }

        if (!sendEvent) {
          sendEvent = Object(createSendEventForFacet["a" /* createSendEventForFacet */])({
            instantSearchInstance: instantSearchInstance,
            helper: helper,
            attribute: hierarchicalFacetName,
            widgetType: this.$$type
          });
        }

        if (!this._refine) {
          this._refine = function (facetValue) {
            sendEvent('click', facetValue);
            helper.toggleRefinement(hierarchicalFacetName, facetValue).search();
          };
        }

        var facetValues = results ? results.getFacetValues(hierarchicalFacetName, {
          sortBy: sortBy
        }).data || [] : [];
        var items = transformItems(results ? this._prepareFacetValues(facetValues) : []);

        var getHasExhaustiveItems = function getHasExhaustiveItems() {
          if (!results) {
            return false;
          }

          var currentLimit = _this3.getLimit(); // If the limit is the max number of facet retrieved it is impossible to know
          // if the facets are exhaustive. The only moment we are sure it is exhaustive
          // is when it is strictly under the number requested unless we know that another
          // widget has requested more values (maxValuesPerFacet > getLimit()).
          // Because this is used for making the search of facets unable or not, it is important
          // to be conservative here.


          return state.maxValuesPerFacet > currentLimit ? facetValues.length <= currentLimit : facetValues.length < currentLimit;
        };

        return {
          items: items,
          refine: this._refine,
          createURL: _createURL,
          sendEvent: sendEvent,
          widgetParams: widgetParams,
          isShowingMore: this.isShowingMore,
          toggleShowMore: cachedToggleShowMore,
          canToggleShowMore: showMore && (this.isShowingMore || !getHasExhaustiveItems())
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {
        var searchParameters = _ref4.searchParameters;
        var path = searchParameters.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);

        if (!path.length) {
          return uiState;
        }

        return connectHierarchicalMenu_objectSpread({}, uiState, {
          hierarchicalMenu: connectHierarchicalMenu_objectSpread({}, uiState.hierarchicalMenu, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, path))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {
        var uiState = _ref5.uiState;
        var values = uiState.hierarchicalMenu && uiState.hierarchicalMenu[hierarchicalFacetName];

        if (searchParameters.isHierarchicalFacet(hierarchicalFacetName)) {
          var facet = searchParameters.getHierarchicalFacetByName(hierarchicalFacetName);
           false ? undefined : void 0;
        }

        var withFacetConfiguration = searchParameters.removeHierarchicalFacet(hierarchicalFacetName).addHierarchicalFacet({
          name: hierarchicalFacetName,
          attributes: attributes,
          separator: separator,
          rootPath: rootPath,
          showParentLevel: showParentLevel
        });
        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;
        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);
        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);

        if (!values) {
          return withMaxValuesPerFacet.setQueryParameters({
            hierarchicalFacetsRefinements: connectHierarchicalMenu_objectSpread({}, withMaxValuesPerFacet.hierarchicalFacetsRefinements, connectHierarchicalMenu_defineProperty({}, hierarchicalFacetName, []))
          });
        }

        return withMaxValuesPerFacet.addHierarchicalFacetRefinement(hierarchicalFacetName, values.join(separator));
      }
    };
  };
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/escape-highlight.js
var escape_highlight = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/createSendEventForHits.js
var createSendEventForHits = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-absolute-position.js
var hits_absolute_position = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/hits-query-id.js
var hits_query_id = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits/connectHits.js
function connectHits_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectHits_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectHits_ownKeys(Object(source), true).forEach(function (key) {
        connectHits_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectHits_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectHits_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var connectHits_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'hits',
  connector: true
});

var connectHits_connectHits = function connectHits(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectHits_withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        _ref$escapeHTML = _ref.escapeHTML,
        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    var sendEvent;
    var bindEvent;
    return {
      $$type: 'ais.hits',
      init: function init(initOptions) {
        renderFn(connectHits_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var renderState = this.getWidgetRenderState(renderOptions);
        renderState.sendEvent('view', renderState.hits);
        renderFn(connectHits_objectSpread({}, renderState, {
          instantSearchInstance: renderOptions.instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectHits_objectSpread({}, renderState, {
          hits: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var results = _ref2.results,
            helper = _ref2.helper,
            instantSearchInstance = _ref2.instantSearchInstance;

        if (!sendEvent) {
          sendEvent = Object(createSendEventForHits["b" /* createSendEventForHits */])({
            instantSearchInstance: instantSearchInstance,
            index: helper.getIndex(),
            widgetType: this.$$type
          });
        }

        if (!bindEvent) {
          bindEvent = Object(createSendEventForHits["a" /* createBindEventForHits */])({
            index: helper.getIndex(),
            widgetType: this.$$type
          });
        }

        if (!results) {
          return {
            hits: [],
            results: undefined,
            sendEvent: sendEvent,
            bindEvent: bindEvent,
            widgetParams: widgetParams
          };
        }

        if (escapeHTML && results.hits.length > 0) {
          results.hits = Object(escape_highlight["c" /* default */])(results.hits);
        }

        var initialEscaped = results.hits.__escaped;
        results.hits = Object(hits_absolute_position["a" /* addAbsolutePosition */])(results.hits, results.page, results.hitsPerPage);
        results.hits = Object(hits_query_id["a" /* addQueryID */])(results.hits, results.queryID);
        results.hits = transformItems(results.hits); // Make sure the escaped tag stays, even after mapping over the hits.
        // This prevents the hits from being double-escaped if there are multiple
        // hits widgets mounted on the page.

        results.hits.__escaped = initialEscaped;
        return {
          hits: results.hits,
          results: results,
          sendEvent: sendEvent,
          bindEvent: bindEvent,
          widgetParams: widgetParams
        };
      },
      dispose: function dispose(_ref3) {
        var state = _ref3.state;
        unmountFn();

        if (!escapeHTML) {
          return state;
        }

        return state.setQueryParameters(Object.keys(escape_highlight["a" /* TAG_PLACEHOLDER */]).reduce(function (acc, key) {
          return connectHits_objectSpread({}, acc, connectHits_defineProperty({}, key, undefined));
        }, {}));
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(state) {
        if (!escapeHTML) {
          return state;
        }

        return state.setQueryParameters(escape_highlight["a" /* TAG_PLACEHOLDER */]);
      }
    };
  };
};

/* harmony default export */ var hits_connectHits = (connectHits_connectHits);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/find.js
var find = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/insights/client.js
function client_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function client_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      client_ownKeys(Object(source), true).forEach(function (key) {
        client_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      client_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function client_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var client_getSelectedHits = function getSelectedHits(hits, selectedObjectIDs) {
  return selectedObjectIDs.map(function (objectID) {
    var hit = Object(find["a" /* default */])(hits, function (h) {
      return h.objectID === objectID;
    });

    if (typeof hit === 'undefined') {
      throw new Error("Could not find objectID \"".concat(objectID, "\" passed to `clickedObjectIDsAfterSearch` in the returned hits. This is necessary to infer the absolute position and the query ID."));
    }

    return hit;
  });
};

var client_getQueryID = function getQueryID(selectedHits) {
  var queryIDs = Object(uniq["a" /* default */])(selectedHits.map(function (hit) {
    return hit.__queryID;
  }));

  if (queryIDs.length > 1) {
    throw new Error('Insights currently allows a single `queryID`. The `objectIDs` provided map to multiple `queryID`s.');
  }

  var queryID = queryIDs[0];

  if (typeof queryID !== 'string') {
    throw new Error("Could not infer `queryID`. Ensure InstantSearch `clickAnalytics: true` was added with the Configure widget.\n\nSee: https://alg.li/lNiZZ7");
  }

  return queryID;
};

var getPositions = function getPositions(selectedHits) {
  return selectedHits.map(function (hit) {
    return hit.__position;
  });
};

var inferPayload = function inferPayload(_ref) {
  var method = _ref.method,
      results = _ref.results,
      hits = _ref.hits,
      objectIDs = _ref.objectIDs;
  var index = results.index;
  var selectedHits = client_getSelectedHits(hits, objectIDs);
  var queryID = client_getQueryID(selectedHits);

  switch (method) {
    case 'clickedObjectIDsAfterSearch':
      {
        var positions = getPositions(selectedHits);
        return {
          index: index,
          queryID: queryID,
          objectIDs: objectIDs,
          positions: positions
        };
      }

    case 'convertedObjectIDsAfterSearch':
      return {
        index: index,
        queryID: queryID,
        objectIDs: objectIDs
      };

    default:
      throw new Error("Unsupported method passed to insights: \"".concat(method, "\"."));
  }
};

var client_wrapInsightsClient = function wrapInsightsClient(aa, results, hits) {
  return function (method, payload) {
     false ? undefined : void 0;

    if (!aa) {
      var withInstantSearchUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
        name: 'instantsearch'
      });
      throw new Error(withInstantSearchUsage('The `insightsClient` option has not been provided to `instantsearch`.'));
    }

    if (!Array.isArray(payload.objectIDs)) {
      throw new TypeError('Expected `objectIDs` to be an array.');
    }

    var inferredPayload = inferPayload({
      method: method,
      results: results,
      hits: hits,
      objectIDs: payload.objectIDs
    });
    aa(method, client_objectSpread({}, inferredPayload, {}, payload));
  };
};
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 * It passes `insights` to `HitsWithInsightsListener` and `InfiniteHitsWithInsightsListener`.
 */


function withInsights(connector) {
  var wrapRenderFn = function wrapRenderFn(renderFn) {
    return function (renderOptions, isFirstRender) {
      var results = renderOptions.results,
          hits = renderOptions.hits,
          instantSearchInstance = renderOptions.instantSearchInstance;

      if (results && hits && instantSearchInstance) {
        var insights = client_wrapInsightsClient(instantSearchInstance.insightsClient, results, hits);
        return renderFn(client_objectSpread({}, renderOptions, {
          insights: insights
        }), isFirstRender);
      }

      return renderFn(renderOptions, isFirstRender);
    };
  };

  return function (renderFn, unmountFn) {
    return connector(wrapRenderFn(renderFn), unmountFn);
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits/connectHitsWithInsights.js


var connectHitsWithInsights = withInsights(hits_connectHits);
/* harmony default export */ var hits_connectHitsWithInsights = (connectHitsWithInsights);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/hits-per-page/connectHitsPerPage.js
function connectHitsPerPage_toConsumableArray(arr) {
  return connectHitsPerPage_arrayWithoutHoles(arr) || connectHitsPerPage_iterableToArray(arr) || connectHitsPerPage_nonIterableSpread();
}

function connectHitsPerPage_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectHitsPerPage_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectHitsPerPage_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function connectHitsPerPage_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectHitsPerPage_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectHitsPerPage_ownKeys(Object(source), true).forEach(function (key) {
        connectHitsPerPage_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectHitsPerPage_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectHitsPerPage_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectHitsPerPage_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'hits-per-page',
  connector: true
});

var connectHitsPerPage_connectHitsPerPage = function connectHitsPerPage(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectHitsPerPage_withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        userItems = _ref.items,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    var items = userItems;

    if (!Array.isArray(items)) {
      throw new Error(connectHitsPerPage_withUsage('The `items` option expects an array of objects.'));
    }

    var defaultItems = items.filter(function (item) {
      return item.default === true;
    });

    if (defaultItems.length === 0) {
      throw new Error(connectHitsPerPage_withUsage("A default value must be specified in `items`."));
    }

    if (defaultItems.length > 1) {
      throw new Error(connectHitsPerPage_withUsage('More than one default value is specified in `items`.'));
    }

    var defaultItem = defaultItems[0];

    var normalizeItems = function normalizeItems(_ref2) {
      var hitsPerPage = _ref2.hitsPerPage;
      return items.map(function (item) {
        return connectHitsPerPage_objectSpread({}, item, {
          isRefined: Number(item.value) === Number(hitsPerPage)
        });
      });
    };

    var connectorState = {
      getRefine: function getRefine(helper) {
        return function (value) {
          return !value && value !== 0 ? helper.setQueryParameter('hitsPerPage', undefined).search() : helper.setQueryParameter('hitsPerPage', value).search();
        };
      },
      createURLFactory: function createURLFactory(_ref3) {
        var state = _ref3.state,
            createURL = _ref3.createURL;
        return function (value) {
          return createURL(state.setQueryParameter('hitsPerPage', !value && value !== 0 ? undefined : value));
        };
      }
    };
    return {
      $$type: 'ais.hitsPerPage',
      init: function init(initOptions) {
        var state = initOptions.state,
            instantSearchInstance = initOptions.instantSearchInstance;
        var isCurrentInOptions = items.some(function (item) {
          return Number(state.hitsPerPage) === Number(item.value);
        });

        if (!isCurrentInOptions) {
           false ? undefined : void 0;
           false ? undefined : void 0;
          items = [// The helper will convert the empty string to `undefined`.
          {
            value: '',
            label: ''
          }].concat(connectHitsPerPage_toConsumableArray(items));
        }

        renderFn(connectHitsPerPage_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectHitsPerPage_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref4) {
        var state = _ref4.state;
        unmountFn();
        return state.setQueryParameter('hitsPerPage', undefined);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectHitsPerPage_objectSpread({}, renderState, {
          hitsPerPage: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref5) {
        var state = _ref5.state,
            results = _ref5.results,
            createURL = _ref5.createURL,
            helper = _ref5.helper;
        return {
          items: transformItems(normalizeItems(state)),
          refine: connectorState.getRefine(helper),
          createURL: connectorState.createURLFactory({
            state: state,
            createURL: createURL
          }),
          hasNoResults: results ? results.nbHits === 0 : true,
          widgetParams: widgetParams
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref6) {
        var searchParameters = _ref6.searchParameters;
        var hitsPerPage = searchParameters.hitsPerPage;

        if (hitsPerPage === undefined || hitsPerPage === defaultItem.value) {
          return uiState;
        }

        return connectHitsPerPage_objectSpread({}, uiState, {
          hitsPerPage: hitsPerPage
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref7) {
        var uiState = _ref7.uiState;
        return searchParameters.setQueryParameters({
          hitsPerPage: uiState.hitsPerPage || defaultItem.value
        });
      }
    };
  };
};

/* harmony default export */ var hits_per_page_connectHitsPerPage = (connectHitsPerPage_connectHitsPerPage);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js
var isEqual = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/infinite-hits/connectInfiniteHits.js
function connectInfiniteHits_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectInfiniteHits_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectInfiniteHits_ownKeys(Object(source), true).forEach(function (key) {
        connectInfiniteHits_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectInfiniteHits_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectInfiniteHits_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectInfiniteHits_toConsumableArray(arr) {
  return connectInfiniteHits_arrayWithoutHoles(arr) || connectInfiniteHits_iterableToArray(arr) || connectInfiniteHits_nonIterableSpread();
}

function connectInfiniteHits_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectInfiniteHits_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectInfiniteHits_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function connectInfiniteHits_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = connectInfiniteHits_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function connectInfiniteHits_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}



var connectInfiniteHits_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'infinite-hits',
  connector: true
});

function getStateWithoutPage(state) {
  var _ref = state || {},
      page = _ref.page,
      rest = connectInfiniteHits_objectWithoutProperties(_ref, ["page"]);

  return rest;
}

function getInMemoryCache() {
  var cachedHits = null;
  var cachedState = undefined;
  return {
    read: function read(_ref2) {
      var state = _ref2.state;
      return Object(isEqual["a" /* default */])(cachedState, getStateWithoutPage(state)) ? cachedHits : null;
    },
    write: function write(_ref3) {
      var state = _ref3.state,
          hits = _ref3.hits;
      cachedState = getStateWithoutPage(state);
      cachedHits = hits;
    }
  };
}

function extractHitsFromCachedHits(cachedHits) {
  return Object.keys(cachedHits).map(Number).sort(function (a, b) {
    return a - b;
  }).reduce(function (acc, page) {
    return acc.concat(cachedHits[page]);
  }, []);
}

var connectInfiniteHits_connectInfiniteHits = function connectInfiniteHits(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectInfiniteHits_withUsage());
  return function (widgetParams) {
    var _ref4 = widgetParams || {},
        _ref4$escapeHTML = _ref4.escapeHTML,
        escapeHTML = _ref4$escapeHTML === void 0 ? true : _ref4$escapeHTML,
        _ref4$transformItems = _ref4.transformItems,
        transformItems = _ref4$transformItems === void 0 ? function (items) {
      return items;
    } : _ref4$transformItems,
        _ref4$cache = _ref4.cache,
        cache = _ref4$cache === void 0 ? getInMemoryCache() : _ref4$cache;

    var showPrevious;
    var showMore;
    var sendEvent;
    var bindEvent;

    var getFirstReceivedPage = function getFirstReceivedPage(state, cachedHits) {
      var _state$page = state.page,
          page = _state$page === void 0 ? 0 : _state$page;
      var pages = Object.keys(cachedHits).map(Number);

      if (pages.length === 0) {
        return page;
      } else {
        return Math.min.apply(Math, [page].concat(connectInfiniteHits_toConsumableArray(pages)));
      }
    };

    var getLastReceivedPage = function getLastReceivedPage(state, cachedHits) {
      var _state$page2 = state.page,
          page = _state$page2 === void 0 ? 0 : _state$page2;
      var pages = Object.keys(cachedHits).map(Number);

      if (pages.length === 0) {
        return page;
      } else {
        return Math.max.apply(Math, [page].concat(connectInfiniteHits_toConsumableArray(pages)));
      }
    };

    var getShowPrevious = function getShowPrevious(helper, cachedHits) {
      return function () {
        // Using the helper's `overrideStateWithoutTriggeringChangeEvent` method
        // avoid updating the browser URL when the user displays the previous page.
        helper.overrideStateWithoutTriggeringChangeEvent(connectInfiniteHits_objectSpread({}, helper.state, {
          page: getFirstReceivedPage(helper.state, cachedHits) - 1
        })).searchWithoutTriggeringOnStateChange();
      };
    };

    var getShowMore = function getShowMore(helper, cachedHits) {
      return function () {
        helper.setPage(getLastReceivedPage(helper.state, cachedHits) + 1).search();
      };
    };

    return {
      $$type: 'ais.infiniteHits',
      init: function init(initOptions) {
        renderFn(connectInfiniteHits_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        var widgetRenderState = this.getWidgetRenderState(renderOptions);
        sendEvent('view', widgetRenderState.currentPageHits);
        renderFn(connectInfiniteHits_objectSpread({}, widgetRenderState, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectInfiniteHits_objectSpread({}, renderState, {
          infiniteHits: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref5) {
        var results = _ref5.results,
            helper = _ref5.helper,
            state = _ref5.state,
            instantSearchInstance = _ref5.instantSearchInstance;
        var isFirstPage;
        var currentPageHits = [];
        var cachedHits = cache.read({
          state: state
        }) || {};

        if (!results) {
          showPrevious = getShowPrevious(helper, cachedHits);
          showMore = getShowMore(helper, cachedHits);
          sendEvent = Object(createSendEventForHits["b" /* createSendEventForHits */])({
            instantSearchInstance: instantSearchInstance,
            index: helper.getIndex(),
            widgetType: this.$$type
          });
          bindEvent = Object(createSendEventForHits["a" /* createBindEventForHits */])({
            index: helper.getIndex(),
            widgetType: this.$$type
          });
          isFirstPage = helper.state.page === undefined || getFirstReceivedPage(helper.state, cachedHits) === 0;
        } else {
          var _state$page3 = state.page,
              _page = _state$page3 === void 0 ? 0 : _state$page3;

          if (escapeHTML && results.hits.length > 0) {
            results.hits = Object(escape_highlight["c" /* default */])(results.hits);
          }

          var initialEscaped = results.hits.__escaped;
          results.hits = Object(hits_absolute_position["a" /* addAbsolutePosition */])(results.hits, results.page, results.hitsPerPage);
          results.hits = Object(hits_query_id["a" /* addQueryID */])(results.hits, results.queryID);
          results.hits = transformItems(results.hits); // Make sure the escaped tag stays after mapping over the hits.
          // This prevents the hits from being double-escaped if there are multiple
          // hits widgets mounted on the page.

          results.hits.__escaped = initialEscaped;

          if (cachedHits[_page] === undefined) {
            cachedHits[_page] = results.hits;
            cache.write({
              state: state,
              hits: cachedHits
            });
          }

          currentPageHits = results.hits;
          isFirstPage = getFirstReceivedPage(state, cachedHits) === 0;
        }

        var hits = extractHitsFromCachedHits(cachedHits);
        var isLastPage = results ? results.nbPages <= getLastReceivedPage(state, cachedHits) + 1 : true;
        return {
          hits: hits,
          currentPageHits: currentPageHits,
          sendEvent: sendEvent,
          bindEvent: bindEvent,
          results: results,
          showPrevious: showPrevious,
          showMore: showMore,
          isFirstPage: isFirstPage,
          isLastPage: isLastPage,
          widgetParams: widgetParams
        };
      },
      dispose: function dispose(_ref6) {
        var state = _ref6.state;
        unmountFn();
        var stateWithoutPage = state.setQueryParameter('page', undefined);

        if (!escapeHTML) {
          return stateWithoutPage;
        }

        return stateWithoutPage.setQueryParameters(Object.keys(escape_highlight["a" /* TAG_PLACEHOLDER */]).reduce(function (acc, key) {
          return connectInfiniteHits_objectSpread({}, acc, connectInfiniteHits_defineProperty({}, key, undefined));
        }, {}));
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref7) {
        var searchParameters = _ref7.searchParameters;
        var page = searchParameters.page || 0;

        if (!page) {
          // return without adding `page` to uiState
          // because we don't want `page=1` in the URL
          return uiState;
        }

        return connectInfiniteHits_objectSpread({}, uiState, {
          // The page in the UI state is incremented by one
          // to expose the user value (not `0`).
          page: page + 1
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref8) {
        var uiState = _ref8.uiState;
        var widgetSearchParameters = searchParameters;

        if (escapeHTML) {
          widgetSearchParameters = searchParameters.setQueryParameters(escape_highlight["a" /* TAG_PLACEHOLDER */]);
        } // The page in the search parameters is decremented by one
        // to get to the actual parameter value from the UI state.


        var page = uiState.page ? uiState.page - 1 : 0;
        return widgetSearchParameters.setQueryParameter('page', page);
      }
    };
  };
};

/* harmony default export */ var infinite_hits_connectInfiniteHits = (connectInfiniteHits_connectInfiniteHits);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/infinite-hits/connectInfiniteHitsWithInsights.js


var connectInfiniteHitsWithInsights = withInsights(infinite_hits_connectInfiniteHits);
/* harmony default export */ var infinite_hits_connectInfiniteHitsWithInsights = (connectInfiniteHitsWithInsights);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/menu/connectMenu.js
function connectMenu_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = connectMenu_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function connectMenu_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function connectMenu_slicedToArray(arr, i) {
  return connectMenu_arrayWithHoles(arr) || connectMenu_iterableToArrayLimit(arr, i) || connectMenu_nonIterableRest();
}

function connectMenu_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function connectMenu_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function connectMenu_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function connectMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectMenu_ownKeys(Object(source), true).forEach(function (key) {
        connectMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectMenu_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'menu',
  connector: true
});
/**
 * @typedef {Object} MenuItem
 * @property {string} value The value of the menu item.
 * @property {string} label Human-readable value of the menu item.
 * @property {number} count Number of results matched after refinement is applied.
 * @property {boolean} isRefined Indicates if the refinement is applied.
 */

/**
 * @typedef {Object} CustomMenuWidgetOptions
 * @property {string} attribute Name of the attribute for faceting (eg. "free_shipping").
 * @property {number} [limit = 10] How many facets values to retrieve.
 * @property {boolean} [showMore = false] Whether to display a button that expands the number of items.
 * @property {number} [showMoreLimit = 20] How many facets values to retrieve when `toggleShowMore` is called, this value is meant to be greater than `limit` option.
 * @property {string[]|function} [sortBy = ['isRefined', 'name:asc']] How to sort refinements. Possible values: `count|isRefined|name:asc|name:desc`.
 *
 * You can also use a sort function that behaves like the standard Javascript [compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Syntax).
 * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.
 */

/**
 * @typedef {Object} MenuRenderingOptions
 * @property {MenuItem[]} items The elements that can be refined for the current search results.
 * @property {function(item.value): string} createURL Creates the URL for a single item name in the list.
 * @property {function(item.value)} refine Filter the search to item value.
 * @property {boolean} canRefine True if refinement can be applied.
 * @property {Object} widgetParams All original `CustomMenuWidgetOptions` forwarded to the `renderFn`.
 * @property {boolean} isShowingMore True if the menu is displaying all the menu items.
 * @property {function} toggleShowMore Toggles the number of values displayed between `limit` and `showMore.limit`.
 * @property {boolean} canToggleShowMore `true` if the toggleShowMore button can be activated (enough items to display more or
 * already displaying more than `limit` items)
 */

/**
 * **Menu** connector provides the logic to build a widget that will give the user the ability to choose a single value for a specific facet. The typical usage of menu is for navigation in categories.
 *
 * This connector provides a `toggleShowMore()` function to display more or less items and a `refine()`
 * function to select an item. While selecting a new element, the `refine` will also unselect the
 * one that is currently selected.
 *
 * **Requirement:** the attribute passed as `attribute` must be present in "attributes for faceting" on the Algolia dashboard or configured as attributesForFaceting via a set settings call to the Algolia API.
 * @type {Connector}
 * @param {function(MenuRenderingOptions, boolean)} renderFn Rendering function for the custom **Menu** widget. widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomMenuWidgetOptions)} Re-usable widget factory for a custom **Menu** widget.
 * @example
 * // custom `renderFn` to render the custom Menu widget
 * function renderFn(MenuRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) {
 *     MenuRenderingOptions.widgetParams.containerNode
 *       .html('<select></select');
 *
 *     MenuRenderingOptions.widgetParams.containerNode
 *       .find('select')
 *       .on('change', function(event) {
 *         MenuRenderingOptions.refine(event.target.value);
 *       });
 *   }
 *
 *   var options = MenuRenderingOptions.items.map(function(item) {
 *     return item.isRefined
 *       ? '<option value="' + item.value + '" selected>' + item.label + '</option>'
 *       : '<option value="' + item.value + '">' + item.label + '</option>';
 *   });
 *
 *   MenuRenderingOptions.widgetParams.containerNode
 *     .find('select')
 *     .html(options);
 * }
 *
 * // connect `renderFn` to Menu logic
 * var customMenu = instantsearch.connectors.connectMenu(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customMenu({
 *     containerNode: $('#custom-menu-container'),
 *     attribute: 'categories',
 *     limit: 10,
 *   })
 * ]);
 */

function connectMenu(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectMenu_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attribute = widgetParams.attribute,
        _widgetParams$limit = widgetParams.limit,
        limit = _widgetParams$limit === void 0 ? 10 : _widgetParams$limit,
        _widgetParams$showMor = widgetParams.showMore,
        showMore = _widgetParams$showMor === void 0 ? false : _widgetParams$showMor,
        _widgetParams$showMor2 = widgetParams.showMoreLimit,
        showMoreLimit = _widgetParams$showMor2 === void 0 ? 20 : _widgetParams$showMor2,
        _widgetParams$sortBy = widgetParams.sortBy,
        sortBy = _widgetParams$sortBy === void 0 ? ['isRefined', 'name:asc'] : _widgetParams$sortBy,
        _widgetParams$transfo = widgetParams.transformItems,
        transformItems = _widgetParams$transfo === void 0 ? function (items) {
      return items;
    } : _widgetParams$transfo;

    if (!attribute) {
      throw new Error(connectMenu_withUsage('The `attribute` option is required.'));
    }

    if (showMore === true && showMoreLimit <= limit) {
      throw new Error(connectMenu_withUsage('The `showMoreLimit` option must be greater than `limit`.'));
    }

    var sendEvent; // Provide the same function to the `renderFn` so that way the user
    // has to only bind it once when `isFirstRendering` for instance

    var toggleShowMore = function toggleShowMore() {};

    function cachedToggleShowMore() {
      toggleShowMore();
    }

    return {
      $$type: 'ais.menu',
      isShowingMore: false,
      createToggleShowMore: function createToggleShowMore(_ref) {
        var _this = this;

        var results = _ref.results,
            instantSearchInstance = _ref.instantSearchInstance;
        return function () {
          _this.isShowingMore = !_this.isShowingMore;

          _this.render({
            results: results,
            instantSearchInstance: instantSearchInstance
          });
        };
      },
      getLimit: function getLimit() {
        return this.isShowingMore ? showMoreLimit : limit;
      },
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectMenu_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectMenu_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref2) {
        var state = _ref2.state;
        unmountFn();
        return state.removeHierarchicalFacet(attribute).setQueryParameter('maxValuesPerFacet', undefined);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectMenu_objectSpread({}, renderState, {
          menu: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref3) {
        var results = _ref3.results,
            createURL = _ref3.createURL,
            instantSearchInstance = _ref3.instantSearchInstance,
            helper = _ref3.helper;
        var items = [];
        var canToggleShowMore = false;

        if (!sendEvent) {
          sendEvent = Object(createSendEventForFacet["a" /* createSendEventForFacet */])({
            instantSearchInstance: instantSearchInstance,
            helper: helper,
            attribute: attribute,
            widgetType: this.$$type
          });
        }

        if (!this._createURL) {
          this._createURL = function (facetValue) {
            return createURL(helper.state.toggleRefinement(attribute, facetValue));
          };
        }

        if (!this._refine) {
          this._refine = function (facetValue) {
            var _helper$getHierarchic = helper.getHierarchicalFacetBreadcrumb(attribute),
                _helper$getHierarchic2 = connectMenu_slicedToArray(_helper$getHierarchic, 1),
                refinedItem = _helper$getHierarchic2[0];

            sendEvent('click', facetValue ? facetValue : refinedItem);
            helper.toggleRefinement(attribute, facetValue ? facetValue : refinedItem).search();
          };
        }

        toggleShowMore = this.createToggleShowMore({
          results: results,
          instantSearchInstance: instantSearchInstance
        });

        if (results) {
          var facetValues = results.getFacetValues(attribute, {
            sortBy: sortBy
          });
          var facetItems = facetValues && facetValues.data ? facetValues.data : [];
          canToggleShowMore = showMore && (this.isShowingMore || facetItems.length > this.getLimit());
          items = transformItems(facetItems.slice(0, this.getLimit()).map(function (_ref4) {
            var label = _ref4.name,
                value = _ref4.path,
                item = connectMenu_objectWithoutProperties(_ref4, ["name", "path"]);

            return connectMenu_objectSpread({}, item, {
              label: label,
              value: value
            });
          }));
        }

        return {
          items: items,
          createURL: this._createURL,
          refine: this._refine,
          sendEvent: sendEvent,
          canRefine: items.length > 0,
          widgetParams: widgetParams,
          isShowingMore: this.isShowingMore,
          toggleShowMore: cachedToggleShowMore,
          canToggleShowMore: canToggleShowMore
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {
        var searchParameters = _ref5.searchParameters;

        var _searchParameters$get = searchParameters.getHierarchicalFacetBreadcrumb(attribute),
            _searchParameters$get2 = connectMenu_slicedToArray(_searchParameters$get, 1),
            value = _searchParameters$get2[0];

        if (!value) {
          return uiState;
        }

        return connectMenu_objectSpread({}, uiState, {
          menu: connectMenu_objectSpread({}, uiState.menu, connectMenu_defineProperty({}, attribute, value))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
        var uiState = _ref6.uiState;
        var value = uiState.menu && uiState.menu[attribute];
        var withFacetConfiguration = searchParameters.removeHierarchicalFacet(attribute).addHierarchicalFacet({
          name: attribute,
          attributes: [attribute]
        });
        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;
        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);
        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);

        if (!value) {
          return withMaxValuesPerFacet.setQueryParameters({
            hierarchicalFacetsRefinements: connectMenu_objectSpread({}, withMaxValuesPerFacet.hierarchicalFacetsRefinements, connectMenu_defineProperty({}, attribute, []))
          });
        }

        return withMaxValuesPerFacet.addHierarchicalFacetRefinement(attribute, value);
      }
    };
  };
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/convertNumericRefinementsToFilters.js
var convertNumericRefinementsToFilters = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isFiniteNumber.js
var isFiniteNumber = __webpack_require__(44);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/numeric-menu/connectNumericMenu.js
function connectNumericMenu_slicedToArray(arr, i) {
  return connectNumericMenu_arrayWithHoles(arr) || connectNumericMenu_iterableToArrayLimit(arr, i) || connectNumericMenu_nonIterableRest();
}

function connectNumericMenu_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function connectNumericMenu_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function connectNumericMenu_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function connectNumericMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectNumericMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectNumericMenu_ownKeys(Object(source), true).forEach(function (key) {
        connectNumericMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectNumericMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectNumericMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectNumericMenu_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'numeric-menu',
  connector: true
});
var $$type = 'ais.numericMenu';

var connectNumericMenu_createSendEvent = function createSendEvent(_ref) {
  var instantSearchInstance = _ref.instantSearchInstance,
      helper = _ref.helper,
      attribute = _ref.attribute;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1) {
      instantSearchInstance.sendEventToInsights(args[0]);
      return;
    }

    var eventType = args[0],
        facetValue = args[1],
        _args$ = args[2],
        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;

    if (eventType !== 'click') {
      return;
    } // facetValue === "%7B%22start%22:5,%22end%22:10%7D"


    var filters = Object(convertNumericRefinementsToFilters["a" /* convertNumericRefinementsToFilters */])(connectNumericMenu_getRefinedState(helper.state, attribute, facetValue), attribute);

    if (filters && filters.length > 0) {
      /*
          filters === ["price<=10", "price>=5"]
        */
      instantSearchInstance.sendEventToInsights({
        insightsMethod: 'clickedFilters',
        widgetType: $$type,
        eventType: eventType,
        payload: {
          eventName: eventName,
          index: helper.getIndex(),
          filters: filters
        }
      });
    }
  };
};

var connectNumericMenu_connectNumericMenu = function connectNumericMenu(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectNumericMenu_withUsage());
  return function (widgetParams) {
    var _ref2 = widgetParams || {},
        _ref2$attribute = _ref2.attribute,
        attribute = _ref2$attribute === void 0 ? '' : _ref2$attribute,
        _ref2$items = _ref2.items,
        items = _ref2$items === void 0 ? [] : _ref2$items,
        _ref2$transformItems = _ref2.transformItems,
        transformItems = _ref2$transformItems === void 0 ? function (x) {
      return x;
    } : _ref2$transformItems;

    if (attribute === '') {
      throw new Error(connectNumericMenu_withUsage('The `attribute` option is required.'));
    }

    if (!items || items.length === 0) {
      throw new Error(connectNumericMenu_withUsage('The `items` option expects an array of objects.'));
    }

    var prepareItems = function prepareItems(state) {
      return items.map(function (_ref3) {
        var start = _ref3.start,
            end = _ref3.end,
            label = _ref3.label;
        return {
          label: label,
          value: window.encodeURI(JSON.stringify({
            start: start,
            end: end
          })),
          isRefined: connectNumericMenu_isRefined(state, attribute, {
            start: start,
            end: end,
            label: label
          })
        };
      });
    };

    var connectorState = {};
    return {
      $$type: $$type,
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectNumericMenu_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectNumericMenu_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref4) {
        var state = _ref4.state;
        unmountFn();
        return state.clearRefinements(attribute);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {
        var searchParameters = _ref5.searchParameters;
        var values = searchParameters.getNumericRefinements(attribute);
        var equal = values['='] && values['='][0];

        if (equal || equal === 0) {
          return connectNumericMenu_objectSpread({}, uiState, {
            numericMenu: connectNumericMenu_objectSpread({}, uiState.numericMenu, connectNumericMenu_defineProperty({}, attribute, "".concat(values['='])))
          });
        }

        var min = values['>='] && values['>='][0] || '';
        var max = values['<='] && values['<='][0] || '';

        if (min === '' && max === '') {
          return uiState;
        }

        return connectNumericMenu_objectSpread({}, uiState, {
          numericMenu: connectNumericMenu_objectSpread({}, uiState.numericMenu, connectNumericMenu_defineProperty({}, attribute, "".concat(min, ":").concat(max)))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
        var uiState = _ref6.uiState;
        var value = uiState.numericMenu && uiState.numericMenu[attribute];
        var withoutRefinements = searchParameters.clearRefinements(attribute);

        if (!value) {
          return withoutRefinements.setQueryParameters({
            numericRefinements: connectNumericMenu_objectSpread({}, withoutRefinements.numericRefinements, connectNumericMenu_defineProperty({}, attribute, {}))
          });
        }

        var isExact = value.indexOf(':') === -1;

        if (isExact) {
          return withoutRefinements.addNumericRefinement(attribute, '=', Number(value));
        }

        var _value$split$map = value.split(':').map(parseFloat),
            _value$split$map2 = connectNumericMenu_slicedToArray(_value$split$map, 2),
            min = _value$split$map2[0],
            max = _value$split$map2[1];

        var withMinRefinement = Object(isFiniteNumber["a" /* default */])(min) ? withoutRefinements.addNumericRefinement(attribute, '>=', min) : withoutRefinements;
        var withMaxRefinement = Object(isFiniteNumber["a" /* default */])(max) ? withMinRefinement.addNumericRefinement(attribute, '<=', max) : withMinRefinement;
        return withMaxRefinement;
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectNumericMenu_objectSpread({}, renderState, {
          numericMenu: connectNumericMenu_objectSpread({}, renderState.numericMenu, connectNumericMenu_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref7) {
        var results = _ref7.results,
            state = _ref7.state,
            instantSearchInstance = _ref7.instantSearchInstance,
            helper = _ref7.helper,
            createURL = _ref7.createURL;

        if (!connectorState.refine) {
          connectorState.refine = function (facetValue) {
            var refinedState = connectNumericMenu_getRefinedState(helper.state, attribute, facetValue);
            connectorState.sendEvent('click', facetValue);
            helper.setState(refinedState).search();
          };
        }

        if (!connectorState.createURL) {
          connectorState.createURL = function (newState) {
            return function (facetValue) {
              return createURL(connectNumericMenu_getRefinedState(newState, attribute, facetValue));
            };
          };
        }

        if (!connectorState.sendEvent) {
          connectorState.sendEvent = connectNumericMenu_createSendEvent({
            instantSearchInstance: instantSearchInstance,
            helper: helper,
            attribute: attribute
          });
        }

        return {
          createURL: connectorState.createURL(state),
          items: transformItems(prepareItems(state)),
          hasNoResults: results ? results.nbHits === 0 : true,
          refine: connectorState.refine,
          sendEvent: connectorState.sendEvent,
          widgetParams: widgetParams
        };
      }
    };
  };
};

function connectNumericMenu_isRefined(state, attribute, option) {
  // @TODO: same as another spot, why is this mixing arrays & elements?
  var currentRefinements = state.getNumericRefinements(attribute);

  if (option.start !== undefined && option.end !== undefined) {
    if (option.start === option.end) {
      return hasNumericRefinement(currentRefinements, '=', option.start);
    }
  }

  if (option.start !== undefined) {
    return hasNumericRefinement(currentRefinements, '>=', option.start);
  }

  if (option.end !== undefined) {
    return hasNumericRefinement(currentRefinements, '<=', option.end);
  }

  if (option.start === undefined && option.end === undefined) {
    return Object.keys(currentRefinements).every(function (operator) {
      return (currentRefinements[operator] || []).length === 0;
    });
  }

  return false;
}

function connectNumericMenu_getRefinedState(state, attribute, facetValue) {
  var resolvedState = state;
  var refinedOption = JSON.parse(window.decodeURI(facetValue)); // @TODO: why is array / element mixed here & hasRefinements; seems wrong?

  var currentRefinements = resolvedState.getNumericRefinements(attribute);

  if (refinedOption.start === undefined && refinedOption.end === undefined) {
    return resolvedState.removeNumericRefinement(attribute);
  }

  if (!connectNumericMenu_isRefined(resolvedState, attribute, refinedOption)) {
    resolvedState = resolvedState.removeNumericRefinement(attribute);
  }

  if (refinedOption.start !== undefined && refinedOption.end !== undefined) {
    if (refinedOption.start > refinedOption.end) {
      throw new Error('option.start should be > to option.end');
    }

    if (refinedOption.start === refinedOption.end) {
      if (hasNumericRefinement(currentRefinements, '=', refinedOption.start)) {
        resolvedState = resolvedState.removeNumericRefinement(attribute, '=', refinedOption.start);
      } else {
        resolvedState = resolvedState.addNumericRefinement(attribute, '=', refinedOption.start);
      }

      return resolvedState;
    }
  }

  if (refinedOption.start !== undefined) {
    if (hasNumericRefinement(currentRefinements, '>=', refinedOption.start)) {
      resolvedState = resolvedState.removeNumericRefinement(attribute, '>=', refinedOption.start);
    } else {
      resolvedState = resolvedState.addNumericRefinement(attribute, '>=', refinedOption.start);
    }
  }

  if (refinedOption.end !== undefined) {
    if (hasNumericRefinement(currentRefinements, '<=', refinedOption.end)) {
      resolvedState = resolvedState.removeNumericRefinement(attribute, '<=', refinedOption.end);
    } else {
      resolvedState = resolvedState.addNumericRefinement(attribute, '<=', refinedOption.end);
    }
  }

  if (typeof resolvedState.page === 'number') {
    resolvedState.page = 0;
  }

  return resolvedState;
}

function hasNumericRefinement(currentRefinements, operator, value) {
  return currentRefinements[operator] !== undefined && currentRefinements[operator].includes(value);
}

/* harmony default export */ var numeric_menu_connectNumericMenu = (connectNumericMenu_connectNumericMenu);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/range.js
var range = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/pagination/Paginator.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function Paginator_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var Paginator_Paginator = /*#__PURE__*/function () {
  function Paginator(params) {
    _classCallCheck(this, Paginator);

    Paginator_defineProperty(this, "currentPage", void 0);

    Paginator_defineProperty(this, "total", void 0);

    Paginator_defineProperty(this, "padding", void 0);

    this.currentPage = params.currentPage;
    this.total = params.total;
    this.padding = params.padding;
  }

  _createClass(Paginator, [{
    key: "pages",
    value: function pages() {
      var total = this.total,
          currentPage = this.currentPage,
          padding = this.padding;
      if (total === 0) return [0];
      var totalDisplayedPages = this.nbPagesDisplayed(padding, total);

      if (totalDisplayedPages === total) {
        return Object(range["a" /* default */])({
          end: total
        });
      }

      var paddingLeft = this.calculatePaddingLeft(currentPage, padding, total, totalDisplayedPages);
      var paddingRight = totalDisplayedPages - paddingLeft;
      var first = currentPage - paddingLeft;
      var last = currentPage + paddingRight;
      return Object(range["a" /* default */])({
        start: first,
        end: last
      });
    }
  }, {
    key: "nbPagesDisplayed",
    value: function nbPagesDisplayed(padding, total) {
      return Math.min(2 * padding + 1, total);
    }
  }, {
    key: "calculatePaddingLeft",
    value: function calculatePaddingLeft(current, padding, total, totalDisplayedPages) {
      if (current <= padding) {
        return current;
      }

      if (current >= total - padding) {
        return totalDisplayedPages - (total - current);
      }

      return padding;
    }
  }, {
    key: "isLastPage",
    value: function isLastPage() {
      return this.currentPage === this.total - 1 || this.total === 0;
    }
  }, {
    key: "isFirstPage",
    value: function isFirstPage() {
      return this.currentPage === 0;
    }
  }]);

  return Paginator;
}();

/* harmony default export */ var pagination_Paginator = (Paginator_Paginator);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/pagination/connectPagination.js
function connectPagination_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectPagination_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectPagination_ownKeys(Object(source), true).forEach(function (key) {
        connectPagination_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectPagination_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectPagination_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var connectPagination_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'pagination',
  connector: true
});
/**
 * **Pagination** connector provides the logic to build a widget that will let the user
 * choose the current page of the results.
 *
 * When using the pagination with Algolia, you should be aware that the engine won't provide you pages
 * beyond the 1000th hits by default. You can find more information on the [Algolia documentation](https://www.algolia.com/doc/guides/searching/pagination/#pagination-limitations).
 */

var connectPagination_connectPagination = function connectPagination(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectPagination_withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        totalPages = _ref.totalPages,
        _ref$padding = _ref.padding,
        padding = _ref$padding === void 0 ? 3 : _ref$padding;

    var pager = new pagination_Paginator({
      currentPage: 0,
      total: 0,
      padding: padding
    });
    var connectorState = {};

    function getMaxPage(_ref2) {
      var nbPages = _ref2.nbPages;
      return totalPages !== undefined ? Math.min(totalPages, nbPages) : nbPages;
    }

    return {
      $$type: 'ais.pagination',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectPagination_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectPagination_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref3) {
        var state = _ref3.state;
        unmountFn();
        return state.setQueryParameter('page', undefined);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref4) {
        var searchParameters = _ref4.searchParameters;
        var page = searchParameters.page || 0;

        if (!page) {
          return uiState;
        }

        return connectPagination_objectSpread({}, uiState, {
          page: page + 1
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref5) {
        var uiState = _ref5.uiState;
        var page = uiState.page ? uiState.page - 1 : 0;
        return searchParameters.setQueryParameter('page', page);
      },
      getWidgetRenderState: function getWidgetRenderState(_ref6) {
        var results = _ref6.results,
            helper = _ref6.helper,
            createURL = _ref6.createURL;

        if (!connectorState.refine) {
          connectorState.refine = function (page) {
            helper.setPage(page);
            helper.search();
          };
        }

        if (!connectorState.createURL) {
          connectorState.createURL = function (state) {
            return function (page) {
              return createURL(state.setPage(page));
            };
          };
        }

        var state = helper.state;
        var page = state.page || 0;
        var nbPages = getMaxPage(results || {
          nbPages: 0
        });
        pager.currentPage = page;
        pager.total = nbPages;
        return {
          createURL: connectorState.createURL(state),
          refine: connectorState.refine,
          currentRefinement: page,
          nbHits: (results === null || results === void 0 ? void 0 : results.nbHits) || 0,
          nbPages: nbPages,
          pages: results ? pager.pages() : [],
          isFirstPage: pager.isFirstPage(),
          isLastPage: pager.isLastPage(),
          widgetParams: widgetParams
        };
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectPagination_objectSpread({}, renderState, {
          pagination: this.getWidgetRenderState(renderOptions)
        });
      }
    };
  };
};

/* harmony default export */ var pagination_connectPagination = (connectPagination_connectPagination);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/range/connectRange.js
function connectRange_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectRange_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectRange_ownKeys(Object(source), true).forEach(function (key) {
        connectRange_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectRange_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectRange_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectRange_slicedToArray(arr, i) {
  return connectRange_arrayWithHoles(arr) || connectRange_iterableToArrayLimit(arr, i) || connectRange_nonIterableRest();
}

function connectRange_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function connectRange_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function connectRange_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


var connectRange_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'range-input',
  connector: true
}, {
  name: 'range-slider',
  connector: true
});
var connectRange_$$type = 'ais.range';

function toPrecision(_ref) {
  var min = _ref.min,
      max = _ref.max,
      precision = _ref.precision;
  var pow = Math.pow(10, precision);
  return {
    min: min ? Math.floor(min * pow) / pow : min,
    max: max ? Math.ceil(max * pow) / pow : max
  };
}
/**
 * **Range** connector provides the logic to create custom widget that will let
 * the user refine results using a numeric range.
 *
 * This connectors provides a `refine()` function that accepts bounds. It will also provide
 * information about the min and max bounds for the current result set.
 */


var connectRange_connectRange = function connectRange(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectRange_withUsage());
  return function (widgetParams) {
    var _ref2 = widgetParams || {},
        attribute = _ref2.attribute,
        minBound = _ref2.min,
        maxBound = _ref2.max,
        _ref2$precision = _ref2.precision,
        precision = _ref2$precision === void 0 ? 0 : _ref2$precision;

    if (!attribute) {
      throw new Error(connectRange_withUsage('The `attribute` option is required.'));
    }

    if (Object(isFiniteNumber["a" /* default */])(minBound) && Object(isFiniteNumber["a" /* default */])(maxBound) && minBound > maxBound) {
      throw new Error(connectRange_withUsage("The `max` option can't be lower than `min`."));
    }

    var formatToNumber = function formatToNumber(v) {
      return Number(Number(v).toFixed(precision));
    };

    var rangeFormatter = {
      from: function from(v) {
        return v.toLocaleString();
      },
      to: function to(v) {
        return formatToNumber(v).toLocaleString();
      }
    }; // eslint-disable-next-line complexity

    var getRefinedState = function getRefinedState(helper, currentRange, nextMin, nextMax) {
      var resolvedState = helper.state;
      var currentRangeMin = currentRange.min,
          currentRangeMax = currentRange.max;

      var _ref3 = resolvedState.getNumericRefinement(attribute, '>=') || [],
          _ref4 = connectRange_slicedToArray(_ref3, 1),
          min = _ref4[0];

      var _ref5 = resolvedState.getNumericRefinement(attribute, '<=') || [],
          _ref6 = connectRange_slicedToArray(_ref5, 1),
          max = _ref6[0];

      var isResetMin = nextMin === undefined || nextMin === '';
      var isResetMax = nextMax === undefined || nextMax === '';

      var _toPrecision = toPrecision({
        min: !isResetMin ? parseFloat(nextMin) : undefined,
        max: !isResetMax ? parseFloat(nextMax) : undefined,
        precision: precision
      }),
          nextMinAsNumber = _toPrecision.min,
          nextMaxAsNumber = _toPrecision.max;

      var newNextMin;

      if (!Object(isFiniteNumber["a" /* default */])(minBound) && currentRangeMin === nextMinAsNumber) {
        newNextMin = undefined;
      } else if (Object(isFiniteNumber["a" /* default */])(minBound) && isResetMin) {
        newNextMin = minBound;
      } else {
        newNextMin = nextMinAsNumber;
      }

      var newNextMax;

      if (!Object(isFiniteNumber["a" /* default */])(maxBound) && currentRangeMax === nextMaxAsNumber) {
        newNextMax = undefined;
      } else if (Object(isFiniteNumber["a" /* default */])(maxBound) && isResetMax) {
        newNextMax = maxBound;
      } else {
        newNextMax = nextMaxAsNumber;
      }

      var isResetNewNextMin = newNextMin === undefined;
      var isGreaterThanCurrentRange = Object(isFiniteNumber["a" /* default */])(currentRangeMin) && currentRangeMin <= newNextMin;
      var isMinValid = isResetNewNextMin || Object(isFiniteNumber["a" /* default */])(newNextMin) && (!Object(isFiniteNumber["a" /* default */])(currentRangeMin) || isGreaterThanCurrentRange);
      var isResetNewNextMax = newNextMax === undefined;
      var isLowerThanRange = Object(isFiniteNumber["a" /* default */])(newNextMax) && currentRangeMax >= newNextMax;
      var isMaxValid = isResetNewNextMax || Object(isFiniteNumber["a" /* default */])(newNextMax) && (!Object(isFiniteNumber["a" /* default */])(currentRangeMax) || isLowerThanRange);
      var hasMinChange = min !== newNextMin;
      var hasMaxChange = max !== newNextMax;

      if ((hasMinChange || hasMaxChange) && isMinValid && isMaxValid) {
        resolvedState = resolvedState.removeNumericRefinement(attribute);

        if (Object(isFiniteNumber["a" /* default */])(newNextMin)) {
          resolvedState = resolvedState.addNumericRefinement(attribute, '>=', newNextMin);
        }

        if (Object(isFiniteNumber["a" /* default */])(newNextMax)) {
          resolvedState = resolvedState.addNumericRefinement(attribute, '<=', newNextMax);
        }

        return resolvedState;
      }

      return null;
    };

    var sendEventWithRefinedState = function sendEventWithRefinedState(refinedState, instantSearchInstance, helper) {
      var eventName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Filter Applied';
      var filters = Object(convertNumericRefinementsToFilters["a" /* convertNumericRefinementsToFilters */])(refinedState, attribute);

      if (filters && filters.length > 0) {
        instantSearchInstance.sendEventToInsights({
          insightsMethod: 'clickedFilters',
          widgetType: connectRange_$$type,
          eventType: 'click',
          payload: {
            eventName: eventName,
            index: helper.getIndex(),
            filters: filters
          }
        });
      }
    };

    var createSendEvent = function createSendEvent(instantSearchInstance, helper, currentRange) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1) {
          instantSearchInstance.sendEventToInsights(args[0]);
          return;
        }

        var eventType = args[0],
            facetValue = args[1],
            eventName = args[2];

        if (eventType !== 'click') {
          return;
        }

        var _facetValue = connectRange_slicedToArray(facetValue, 2),
            nextMin = _facetValue[0],
            nextMax = _facetValue[1];

        var refinedState = getRefinedState(helper, currentRange, nextMin, nextMax);
        sendEventWithRefinedState(refinedState, instantSearchInstance, helper, eventName);
      };
    };

    function _getCurrentRange(stats) {
      var min;

      if (Object(isFiniteNumber["a" /* default */])(minBound)) {
        min = minBound;
      } else if (Object(isFiniteNumber["a" /* default */])(stats.min)) {
        min = stats.min;
      } else {
        min = 0;
      }

      var max;

      if (Object(isFiniteNumber["a" /* default */])(maxBound)) {
        max = maxBound;
      } else if (Object(isFiniteNumber["a" /* default */])(stats.max)) {
        max = stats.max;
      } else {
        max = 0;
      }

      return toPrecision({
        min: min,
        max: max,
        precision: precision
      });
    }

    function _getCurrentRefinement(helper) {
      var _ref7 = helper.getNumericRefinement(attribute, '>=') || [],
          _ref8 = connectRange_slicedToArray(_ref7, 1),
          minValue = _ref8[0];

      var _ref9 = helper.getNumericRefinement(attribute, '<=') || [],
          _ref10 = connectRange_slicedToArray(_ref9, 1),
          maxValue = _ref10[0];

      var min = Object(isFiniteNumber["a" /* default */])(minValue) ? minValue : -Infinity;
      var max = Object(isFiniteNumber["a" /* default */])(maxValue) ? maxValue : Infinity;
      return [min, max];
    }

    function _refine(instantSearchInstance, helper, currentRange) {
      return function () {
        var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [undefined, undefined],
            _ref12 = connectRange_slicedToArray(_ref11, 2),
            nextMin = _ref12[0],
            nextMax = _ref12[1];

        var refinedState = getRefinedState(helper, currentRange, nextMin, nextMax);

        if (refinedState) {
          sendEventWithRefinedState(refinedState, instantSearchInstance, helper);
          helper.setState(refinedState).search();
        }
      };
    }

    return {
      $$type: connectRange_$$type,
      init: function init(initOptions) {
        renderFn(connectRange_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        renderFn(connectRange_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: renderOptions.instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectRange_objectSpread({}, renderState, {
          range: connectRange_objectSpread({}, renderState.range, connectRange_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref13) {
        var results = _ref13.results,
            helper = _ref13.helper,
            instantSearchInstance = _ref13.instantSearchInstance;
        var facetsFromResults = results && results.disjunctiveFacets || [];
        var facet = Object(find["a" /* default */])(facetsFromResults, function (facetResult) {
          return facetResult.name === attribute;
        });
        var stats = facet && facet.stats || {
          min: undefined,
          max: undefined
        };

        var currentRange = _getCurrentRange(stats);

        var start = _getCurrentRefinement(helper);

        var refine;

        if (!results) {
          // On first render pass an empty range
          // to be able to bypass the validation
          // related to it
          refine = _refine(instantSearchInstance, helper, {
            min: undefined,
            max: undefined
          });
        } else {
          refine = _refine(instantSearchInstance, helper, currentRange);
        }

        return {
          refine: refine,
          format: rangeFormatter,
          range: currentRange,
          sendEvent: createSendEvent(instantSearchInstance, helper, currentRange),
          widgetParams: connectRange_objectSpread({}, widgetParams, {
            precision: precision
          }),
          start: start
        };
      },
      dispose: function dispose(_ref14) {
        var state = _ref14.state;
        unmountFn();
        return state.removeDisjunctiveFacet(attribute).removeNumericRefinement(attribute);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref15) {
        var searchParameters = _ref15.searchParameters;

        var _searchParameters$get = searchParameters.getNumericRefinements(attribute),
            _searchParameters$get2 = _searchParameters$get['>='],
            min = _searchParameters$get2 === void 0 ? [] : _searchParameters$get2,
            _searchParameters$get3 = _searchParameters$get['<='],
            max = _searchParameters$get3 === void 0 ? [] : _searchParameters$get3;

        if (min.length === 0 && max.length === 0) {
          return uiState;
        }

        return connectRange_objectSpread({}, uiState, {
          range: connectRange_objectSpread({}, uiState.range, connectRange_defineProperty({}, attribute, "".concat(min, ":").concat(max)))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref16) {
        var uiState = _ref16.uiState;
        var widgetSearchParameters = searchParameters.addDisjunctiveFacet(attribute).setQueryParameters({
          numericRefinements: connectRange_objectSpread({}, searchParameters.numericRefinements, connectRange_defineProperty({}, attribute, {}))
        });

        if (Object(isFiniteNumber["a" /* default */])(minBound)) {
          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '>=', minBound);
        }

        if (Object(isFiniteNumber["a" /* default */])(maxBound)) {
          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '<=', maxBound);
        }

        var value = uiState.range && uiState.range[attribute];

        if (!value || value.indexOf(':') === -1) {
          return widgetSearchParameters;
        }

        var _value$split$map = value.split(':').map(parseFloat),
            _value$split$map2 = connectRange_slicedToArray(_value$split$map, 2),
            lowerBound = _value$split$map2[0],
            upperBound = _value$split$map2[1];

        if (Object(isFiniteNumber["a" /* default */])(lowerBound)) {
          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '>=', lowerBound);
        }

        if (Object(isFiniteNumber["a" /* default */])(upperBound)) {
          widgetSearchParameters = widgetSearchParameters.addNumericRefinement(attribute, '<=', upperBound);
        }

        return widgetSearchParameters;
      }
    };
  };
};

/* harmony default export */ var range_connectRange = (connectRange_connectRange);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/refinement-list/connectRefinementList.js
function connectRefinementList_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectRefinementList_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectRefinementList_ownKeys(Object(source), true).forEach(function (key) {
        connectRefinementList_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectRefinementList_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectRefinementList_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectRefinementList_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = connectRefinementList_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function connectRefinementList_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}



var connectRefinementList_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'refinement-list',
  connector: true
});
/**
 * @typedef {Object} RefinementListItem
 * @property {string} value The value of the refinement list item.
 * @property {string} label Human-readable value of the refinement list item.
 * @property {number} count Number of matched results after refinement is applied.
 * @property {boolean} isRefined Indicates if the list item is refined.
 */

/**
 * @typedef {Object} CustomRefinementListWidgetOptions
 * @property {string} attribute The name of the attribute in the records.
 * @property {"and"|"or"} [operator = 'or'] How the filters are combined together.
 * @property {number} [limit = 10] The max number of items to display when
 * `showMoreLimit` is not set or if the widget is showing less value.
 * @property {boolean} [showMore = false] Whether to display a button that expands the number of items.
 * @property {number} [showMoreLimit = 20] The max number of items to display if the widget
 * is showing more items.
 * @property {string[]|function} [sortBy = ['isRefined', 'count:desc', 'name:asc']] How to sort refinements. Possible values: `count|isRefined|name:asc|name:desc`.
 * @property {boolean} [escapeFacetValues = true] Escapes the content of the facet values.
 * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.
 */

/**
 * @typedef {Object} RefinementListRenderingOptions
 * @property {RefinementListItem[]} items The list of filtering values returned from Algolia API.
 * @property {function(item.value): string} createURL Creates the next state url for a selected refinement.
 * @property {function(item.value)} refine Action to apply selected refinements.
 * @property {function} searchForItems Searches for values inside the list.
 * @property {boolean} isFromSearch `true` if the values are from an index search.
 * @property {boolean} canRefine `true` if a refinement can be applied.
 * @property {boolean} canToggleShowMore `true` if the toggleShowMore button can be activated (enough items to display more or
 * already displaying more than `limit` items)
 * @property {Object} widgetParams All original `CustomRefinementListWidgetOptions` forwarded to the `renderFn`.
 * @property {boolean} isShowingMore True if the menu is displaying all the menu items.
 * @property {function} toggleShowMore Toggles the number of values displayed between `limit` and `showMoreLimit`.
 */

/**
 * **RefinementList** connector provides the logic to build a custom widget that will let the
 * user filter the results based on the values of a specific facet.
 *
 * This connector provides a `toggleShowMore()` function to display more or less items and a `refine()`
 * function to select an item.
 * @type {Connector}
 * @param {function(RefinementListRenderingOptions, boolean)} renderFn Rendering function for the custom **RefinementList** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomRefinementListWidgetOptions)} Re-usable widget factory for a custom **RefinementList** widget.
 * @example
 * // custom `renderFn` to render the custom RefinementList widget
 * function renderFn(RefinementListRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) {
 *     RefinementListRenderingOptions.widgetParams.containerNode
 *       .html('<ul></ul>')
 *   }
 *
 *     RefinementListRenderingOptions.widgetParams.containerNode
 *       .find('li[data-refine-value]')
 *       .each(function() { $(this).off('click'); });
 *
 *   if (RefinementListRenderingOptions.canRefine) {
 *     var list = RefinementListRenderingOptions.items.map(function(item) {
 *       return `
 *         <li data-refine-value="${item.value}">
 *           <input type="checkbox" value="${item.value}" ${item.isRefined ? 'checked' : ''} />
 *           <a href="${RefinementListRenderingOptions.createURL(item.value)}">
 *             ${item.label} (${item.count})
 *           </a>
 *         </li>
 *       `;
 *     });
 *
 *     RefinementListRenderingOptions.widgetParams.containerNode.find('ul').html(list);
 *     RefinementListRenderingOptions.widgetParams.containerNode
 *       .find('li[data-refine-value]')
 *       .each(function() {
 *         $(this).on('click', function(event) {
 *           event.stopPropagation();
 *           event.preventDefault();
 *
 *           RefinementListRenderingOptions.refine($(this).data('refine-value'));
 *         });
 *       });
 *   } else {
 *     RefinementListRenderingOptions.widgetParams.containerNode.find('ul').html('');
 *   }
 * }
 *
 * // connect `renderFn` to RefinementList logic
 * var customRefinementList = instantsearch.connectors.connectRefinementList(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customRefinementList({
 *     containerNode: $('#custom-refinement-list-container'),
 *     attribute: 'categories',
 *     limit: 10,
 *   })
 * ]);
 */

function connectRefinementList(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectRefinementList_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attribute = widgetParams.attribute,
        _widgetParams$operato = widgetParams.operator,
        operator = _widgetParams$operato === void 0 ? 'or' : _widgetParams$operato,
        _widgetParams$limit = widgetParams.limit,
        limit = _widgetParams$limit === void 0 ? 10 : _widgetParams$limit,
        _widgetParams$showMor = widgetParams.showMore,
        showMore = _widgetParams$showMor === void 0 ? false : _widgetParams$showMor,
        _widgetParams$showMor2 = widgetParams.showMoreLimit,
        showMoreLimit = _widgetParams$showMor2 === void 0 ? 20 : _widgetParams$showMor2,
        _widgetParams$sortBy = widgetParams.sortBy,
        sortBy = _widgetParams$sortBy === void 0 ? ['isRefined', 'count:desc', 'name:asc'] : _widgetParams$sortBy,
        _widgetParams$escapeF = widgetParams.escapeFacetValues,
        escapeFacetValues = _widgetParams$escapeF === void 0 ? true : _widgetParams$escapeF,
        _widgetParams$transfo = widgetParams.transformItems,
        transformItems = _widgetParams$transfo === void 0 ? function (items) {
      return items;
    } : _widgetParams$transfo;

    if (!attribute) {
      throw new Error(connectRefinementList_withUsage('The `attribute` option is required.'));
    }

    if (!/^(and|or)$/.test(operator)) {
      throw new Error(connectRefinementList_withUsage("The `operator` must one of: `\"and\"`, `\"or\"` (got \"".concat(operator, "\").")));
    }

    if (showMore === true && showMoreLimit <= limit) {
      throw new Error(connectRefinementList_withUsage('`showMoreLimit` should be greater than `limit`.'));
    }

    var formatItems = function formatItems(_ref) {
      var label = _ref.name,
          item = connectRefinementList_objectWithoutProperties(_ref, ["name"]);

      return connectRefinementList_objectSpread({}, item, {
        label: label,
        value: label,
        highlighted: label
      });
    };

    var _getLimit = function getLimit(isShowingMore) {
      return isShowingMore ? showMoreLimit : limit;
    };

    var lastResultsFromMainSearch;
    var lastItemsFromMainSearch = [];
    var hasExhaustiveItems = true;
    var searchForFacetValues;
    var triggerRefine;
    var sendEvent;
    var toggleShowMore;
    /* eslint-disable max-params */

    var createSearchForFacetValues = function createSearchForFacetValues(helper) {
      var _this = this;

      return function (renderOptions) {
        return function (query) {
          var instantSearchInstance = renderOptions.instantSearchInstance;

          if (query === '' && lastItemsFromMainSearch) {
            // render with previous data from the helper.
            renderFn(connectRefinementList_objectSpread({}, _this.getWidgetRenderState(connectRefinementList_objectSpread({}, renderOptions, {
              results: lastResultsFromMainSearch
            })), {
              instantSearchInstance: instantSearchInstance
            }));
          } else {
            var tags = {
              highlightPreTag: escapeFacetValues ? escape_highlight["a" /* TAG_PLACEHOLDER */].highlightPreTag : escape_highlight["b" /* TAG_REPLACEMENT */].highlightPreTag,
              highlightPostTag: escapeFacetValues ? escape_highlight["a" /* TAG_PLACEHOLDER */].highlightPostTag : escape_highlight["b" /* TAG_REPLACEMENT */].highlightPostTag
            };
            helper.searchForFacetValues(attribute, query, // We cap the `maxFacetHits` value to 100 because the Algolia API
            // doesn't support a greater number.
            // See https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits/
            Math.min(_getLimit(_this.isShowingMore), 100), tags).then(function (results) {
              var facetValues = escapeFacetValues ? Object(escape_highlight["d" /* escapeFacets */])(results.facetHits) : results.facetHits;
              var normalizedFacetValues = transformItems(facetValues.map(function (_ref2) {
                var value = _ref2.value,
                    item = connectRefinementList_objectWithoutProperties(_ref2, ["value"]);

                return connectRefinementList_objectSpread({}, item, {
                  value: value,
                  label: value
                });
              }));
              var canToggleShowMore = _this.isShowingMore && lastItemsFromMainSearch.length > limit;
              renderFn(connectRefinementList_objectSpread({}, _this.getWidgetRenderState(connectRefinementList_objectSpread({}, renderOptions, {
                results: lastResultsFromMainSearch
              })), {
                items: normalizedFacetValues,
                canToggleShowMore: canToggleShowMore,
                canRefine: true,
                instantSearchInstance: instantSearchInstance,
                isFromSearch: true
              }));
            });
          }
        };
      };
    };
    /* eslint-enable max-params */


    return {
      $$type: 'ais.refinementList',
      isShowingMore: false,
      // Provide the same function to the `renderFn` so that way the user
      // has to only bind it once when `isFirstRendering` for instance
      toggleShowMore: function toggleShowMore() {},
      cachedToggleShowMore: function cachedToggleShowMore() {
        toggleShowMore();
      },
      createToggleShowMore: function createToggleShowMore(renderOptions) {
        var _this2 = this;

        return function () {
          _this2.isShowingMore = !_this2.isShowingMore;

          _this2.render(renderOptions);
        };
      },
      getLimit: function getLimit() {
        return _getLimit(this.isShowingMore);
      },
      init: function init(initOptions) {
        renderFn(connectRefinementList_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        renderFn(connectRefinementList_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: renderOptions.instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectRefinementList_objectSpread({}, renderState, {
          refinementList: connectRefinementList_objectSpread({}, renderState.refinementList, connectRefinementList_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(renderOptions) {
        var results = renderOptions.results,
            state = renderOptions.state,
            createURL = renderOptions.createURL,
            instantSearchInstance = renderOptions.instantSearchInstance,
            _renderOptions$isFrom = renderOptions.isFromSearch,
            isFromSearch = _renderOptions$isFrom === void 0 ? false : _renderOptions$isFrom,
            helper = renderOptions.helper;
        var items = [];
        var facetValues;

        if (!sendEvent || !triggerRefine || !searchForFacetValues) {
          sendEvent = Object(createSendEventForFacet["a" /* createSendEventForFacet */])({
            instantSearchInstance: instantSearchInstance,
            helper: helper,
            attribute: attribute,
            widgetType: this.$$type
          });

          triggerRefine = function triggerRefine(facetValue) {
            sendEvent('click', facetValue);
            helper.toggleRefinement(attribute, facetValue).search();
          };

          searchForFacetValues = createSearchForFacetValues.call(this, helper);
        }

        if (results) {
          if (!isFromSearch) {
            facetValues = results.getFacetValues(attribute, {
              sortBy: sortBy
            }) || [];
            items = transformItems(facetValues.slice(0, this.getLimit()).map(formatItems));
          } else {
            facetValues = escapeFacetValues ? Object(escape_highlight["d" /* escapeFacets */])(results.facetHits) : results.facetHits;
            items = transformItems(facetValues.map(function (_ref3) {
              var value = _ref3.value,
                  item = connectRefinementList_objectWithoutProperties(_ref3, ["value"]);

              return connectRefinementList_objectSpread({}, item, {
                value: value,
                label: value
              });
            }));
          }

          var maxValuesPerFacetConfig = state.maxValuesPerFacet;
          var currentLimit = this.getLimit(); // If the limit is the max number of facet retrieved it is impossible to know
          // if the facets are exhaustive. The only moment we are sure it is exhaustive
          // is when it is strictly under the number requested unless we know that another
          // widget has requested more values (maxValuesPerFacet > getLimit()).
          // Because this is used for making the search of facets unable or not, it is important
          // to be conservative here.

          hasExhaustiveItems = maxValuesPerFacetConfig > currentLimit ? facetValues.length <= currentLimit : facetValues.length < currentLimit;
          lastResultsFromMainSearch = results;
          lastItemsFromMainSearch = items;
          toggleShowMore = this.createToggleShowMore(renderOptions);
        } // Compute a specific createURL method able to link to any facet value state change


        var _createURL = function _createURL(facetValue) {
          return createURL(state.toggleRefinement(attribute, facetValue));
        }; // Do not mistake searchForFacetValues and searchFacetValues which is the actual search
        // function


        var searchFacetValues = searchForFacetValues && searchForFacetValues(renderOptions);
        var canShowLess = this.isShowingMore && lastItemsFromMainSearch.length > limit;
        var canShowMore = showMore && !isFromSearch && !hasExhaustiveItems;
        var canToggleShowMore = canShowLess || canShowMore;
        return {
          createURL: _createURL,
          items: items,
          refine: triggerRefine,
          searchForItems: searchFacetValues,
          isFromSearch: isFromSearch,
          canRefine: isFromSearch || items.length > 0,
          widgetParams: widgetParams,
          isShowingMore: this.isShowingMore,
          canToggleShowMore: canToggleShowMore,
          toggleShowMore: this.cachedToggleShowMore,
          sendEvent: sendEvent,
          hasExhaustiveItems: hasExhaustiveItems
        };
      },
      dispose: function dispose(_ref4) {
        var state = _ref4.state;
        unmountFn();
        var withoutMaxValuesPerFacet = state.setQueryParameter('maxValuesPerFacet', undefined);

        if (operator === 'and') {
          return withoutMaxValuesPerFacet.removeFacet(attribute);
        }

        return withoutMaxValuesPerFacet.removeDisjunctiveFacet(attribute);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {
        var searchParameters = _ref5.searchParameters;
        var values = operator === 'or' ? searchParameters.getDisjunctiveRefinements(attribute) : searchParameters.getConjunctiveRefinements(attribute);

        if (!values.length) {
          return uiState;
        }

        return connectRefinementList_objectSpread({}, uiState, {
          refinementList: connectRefinementList_objectSpread({}, uiState.refinementList, connectRefinementList_defineProperty({}, attribute, values))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
        var uiState = _ref6.uiState;
        var isDisjunctive = operator === 'or';
        var values = uiState.refinementList && uiState.refinementList[attribute];
        var withoutRefinements = searchParameters.clearRefinements(attribute);
        var withFacetConfiguration = isDisjunctive ? withoutRefinements.addDisjunctiveFacet(attribute) : withoutRefinements.addFacet(attribute);
        var currentMaxValuesPerFacet = withFacetConfiguration.maxValuesPerFacet || 0;
        var nextMaxValuesPerFacet = Math.max(currentMaxValuesPerFacet, showMore ? showMoreLimit : limit);
        var withMaxValuesPerFacet = withFacetConfiguration.setQueryParameter('maxValuesPerFacet', nextMaxValuesPerFacet);

        if (!values) {
          var key = isDisjunctive ? 'disjunctiveFacetsRefinements' : 'facetsRefinements';
          return withMaxValuesPerFacet.setQueryParameters(connectRefinementList_defineProperty({}, key, connectRefinementList_objectSpread({}, withMaxValuesPerFacet[key], connectRefinementList_defineProperty({}, attribute, []))));
        }

        return values.reduce(function (parameters, value) {
          return isDisjunctive ? parameters.addDisjunctiveFacetRefinement(attribute, value) : parameters.addFacetRefinement(attribute, value);
        }, withMaxValuesPerFacet);
      }
    };
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/search-box/connectSearchBox.js
function connectSearchBox_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectSearchBox_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectSearchBox_ownKeys(Object(source), true).forEach(function (key) {
        connectSearchBox_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectSearchBox_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectSearchBox_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectSearchBox_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'search-box',
  connector: true
});
/**
 * @typedef {Object} CustomSearchBoxWidgetOptions
 * @property {function(string, function(string))} [queryHook = undefined] A function that will be called every time
 * a new value for the query is set. The first parameter is the query and the second is a
 * function to actually trigger the search. The function takes the query as the parameter.
 *
 * This queryHook can be used to debounce the number of searches done from the searchBox.
 */

/**
 * @typedef {Object} SearchBoxRenderingOptions
 * @property {string} query The query from the last search.
 * @property {function(string)} refine Sets a new query and searches.
 * @property {function()} clear Remove the query and perform search.
 * @property {Object} widgetParams All original `CustomSearchBoxWidgetOptions` forwarded to the `renderFn`.
 * @property {boolean} isSearchStalled `true` if the search results takes more than a certain time to come back
 * from Algolia servers. This can be configured on the InstantSearch constructor with the attribute
 * `stalledSearchDelay` which is 200ms, by default.
 */

/**
 * **SearchBox** connector provides the logic to build a widget that will let the user search for a query.
 *
 * The connector provides to the rendering: `refine()` to set the query. The behaviour of this function
 * may be impacted by the `queryHook` widget parameter.
 * @type {Connector}
 * @param {function(SearchBoxRenderingOptions, boolean)} renderFn Rendering function for the custom **SearchBox** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomSearchBoxWidgetOptions)} Re-usable widget factory for a custom **SearchBox** widget.
 * @example
 * // custom `renderFn` to render the custom SearchBox widget
 * function renderFn(SearchBoxRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) {
 *     SearchBoxRenderingOptions.widgetParams.containerNode.html('<input type="text" />');
 *     SearchBoxRenderingOptions.widgetParams.containerNode
 *       .find('input')
 *       .on('keyup', function() {
 *         SearchBoxRenderingOptions.refine($(this).val());
 *       });
 *     SearchBoxRenderingOptions.widgetParams.containerNode
 *       .find('input')
 *       .val(SearchBoxRenderingOptions.query);
 *   }
 * }
 *
 * // connect `renderFn` to SearchBox logic
 * var customSearchBox = instantsearch.connectors.connectSearchBox(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customSearchBox({
 *     containerNode: $('#custom-searchbox'),
 *   })
 * ]);
 */

function connectSearchBox(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectSearchBox_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var queryHook = widgetParams.queryHook;

    function clear(helper) {
      return function () {
        helper.setQuery('').search();
      };
    }

    var _clear = function _clear() {};

    function _cachedClear() {
      _clear();
    }

    return {
      $$type: 'ais.searchBox',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectSearchBox_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectSearchBox_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref) {
        var state = _ref.state;
        unmountFn();
        return state.setQueryParameter('query', undefined);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectSearchBox_objectSpread({}, renderState, {
          searchBox: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var helper = _ref2.helper,
            searchMetadata = _ref2.searchMetadata;

        if (!this._refine) {
          var setQueryAndSearch = function setQueryAndSearch(query) {
            if (query !== helper.state.query) {
              helper.setQuery(query).search();
            }
          };

          this._refine = function (query) {
            if (queryHook) {
              queryHook(query, setQueryAndSearch);
              return;
            }

            setQueryAndSearch(query);
          };
        }

        _clear = clear(helper);
        return {
          query: helper.state.query || '',
          refine: this._refine,
          clear: _cachedClear,
          widgetParams: widgetParams,
          isSearchStalled: searchMetadata.isSearchStalled
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref3) {
        var searchParameters = _ref3.searchParameters;
        var query = searchParameters.query || '';

        if (query === '' || uiState && uiState.query === query) {
          return uiState;
        }

        return connectSearchBox_objectSpread({}, uiState, {
          query: query
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref4) {
        var uiState = _ref4.uiState;
        return searchParameters.setQueryParameter('query', uiState.query || '');
      }
    };
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/sort-by/connectSortBy.js
function connectSortBy_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectSortBy_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectSortBy_ownKeys(Object(source), true).forEach(function (key) {
        connectSortBy_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectSortBy_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectSortBy_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectSortBy_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'sort-by',
  connector: true
});
/**
 * @typedef {Object} SortByItem
 * @property {string} value The name of the index to target.
 * @property {string} label The label of the index to display.
 */

/**
 * @typedef {Object} CustomSortByWidgetOptions
 * @property {SortByItem[]} items Array of objects defining the different indices to choose from.
 * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.
 */

/**
 * @typedef {Object} SortByRenderingOptions
 * @property {string} currentRefinement The currently selected index.
 * @property {SortByItem[]} options All the available indices
 * @property {function(string)} refine Switches indices and triggers a new search.
 * @property {boolean} hasNoResults `true` if the last search contains no result.
 * @property {Object} widgetParams All original `CustomSortByWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * The **SortBy** connector provides the logic to build a custom widget that will display a
 * list of indices. With Algolia, this is most commonly used for changing ranking strategy. This allows
 * a user to change how the hits are being sorted.
 *
 * This connector provides the `refine` function that allows to switch indices.
 * The connector provides to the rendering: `refine()` to switch the current index and
 * `options` that are the values that can be selected. `refine` should be used
 * with `options.value`.
 * @type {Connector}
 * @param {function(SortByRenderingOptions, boolean)} renderFn Rendering function for the custom **SortBy** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomSortByWidgetOptions)} Re-usable widget factory for a custom **SortBy** widget.
 * @example
 * // custom `renderFn` to render the custom SortBy widget
 * function renderFn(SortByRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) {
 *     SortByRenderingOptions.widgetParams.containerNode.html('<select></select>');
 *     SortByRenderingOptions.widgetParams.containerNode
 *       .find('select')
 *       .on('change', function(event) {
 *         SortByRenderingOptions.refine(event.target.value);
 *       });
 *   }
 *
 *   var optionsHTML = SortByRenderingOptions.options.map(function(option) {
 *     return `
 *       <option
 *         value="${option.value}"
 *         ${SortByRenderingOptions.currentRefinement === option.value ? 'selected' : ''}
 *       >
 *         ${option.label}
 *       </option>
 *     `;
 *   });
 *
 *   SortByRenderingOptions.widgetParams.containerNode
 *     .find('select')
 *     .html(optionsHTML);
 * }
 *
 * // connect `renderFn` to SortBy logic
 * var customSortBy = instantsearch.connectors.connectSortBy(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customSortBy({
 *     containerNode: $('#custom-sort-by-container'),
 *     items: [
 *       { value: 'instant_search', label: 'Most relevant' },
 *       { value: 'instant_search_price_asc', label: 'Lowest price' },
 *       { value: 'instant_search_price_desc', label: 'Highest price' },
 *     ],
 *   })
 * ]);
 */

function connectSortBy(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectSortBy_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var items = widgetParams.items,
        _widgetParams$transfo = widgetParams.transformItems,
        transformItems = _widgetParams$transfo === void 0 ? function (x) {
      return x;
    } : _widgetParams$transfo;

    if (!Array.isArray(items)) {
      throw new Error(connectSortBy_withUsage('The `items` option expects an array of objects.'));
    }

    return {
      $$type: 'ais.sortBy',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        var widgetRenderState = this.getWidgetRenderState(initOptions);
        var currentIndex = widgetRenderState.currentRefinement;
        var isCurrentIndexInItems = Object(find["a" /* default */])(items, function (item) {
          return item.value === currentIndex;
        });
         false ? undefined : void 0;
        renderFn(connectSortBy_objectSpread({}, widgetRenderState, {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectSortBy_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref) {
        var state = _ref.state;
        unmountFn();
        return state.setIndex(this.initialIndex);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectSortBy_objectSpread({}, renderState, {
          sortBy: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var results = _ref2.results,
            helper = _ref2.helper,
            parent = _ref2.parent;

        if (!this.initialIndex) {
          this.initialIndex = parent.getIndexName();
        }

        if (!this.setIndex) {
          this.setIndex = function (indexName) {
            helper.setIndex(indexName).search();
          };
        }

        return {
          currentRefinement: helper.state.index,
          options: transformItems(items),
          refine: this.setIndex,
          hasNoResults: results ? results.nbHits === 0 : true,
          widgetParams: widgetParams
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref3) {
        var searchParameters = _ref3.searchParameters;
        var currentIndex = searchParameters.index;
        var isInitialIndex = currentIndex === this.initialIndex;

        if (isInitialIndex) {
          return uiState;
        }

        return connectSortBy_objectSpread({}, uiState, {
          sortBy: currentIndex
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref4) {
        var uiState = _ref4.uiState;
        return searchParameters.setQueryParameter('index', uiState.sortBy || this.initialIndex || searchParameters.index);
      }
    };
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/rating-menu/connectRatingMenu.js
function connectRatingMenu_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectRatingMenu_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectRatingMenu_ownKeys(Object(source), true).forEach(function (key) {
        connectRatingMenu_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectRatingMenu_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectRatingMenu_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectRatingMenu_toConsumableArray(arr) {
  return connectRatingMenu_arrayWithoutHoles(arr) || connectRatingMenu_iterableToArray(arr) || connectRatingMenu_nonIterableSpread();
}

function connectRatingMenu_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectRatingMenu_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectRatingMenu_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}


var connectRatingMenu_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'rating-menu',
  connector: true
});
var connectRatingMenu_$$type = 'ais.ratingMenu';

var connectRatingMenu_createSendEvent = function createSendEvent(_ref) {
  var instantSearchInstance = _ref.instantSearchInstance,
      helper = _ref.helper,
      getRefinedStar = _ref.getRefinedStar,
      attribute = _ref.attribute;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1) {
      instantSearchInstance.sendEventToInsights(args[0]);
      return;
    }

    var eventType = args[0],
        facetValue = args[1],
        _args$ = args[2],
        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;

    if (eventType !== 'click') {
      return;
    }

    var isRefined = getRefinedStar() === Number(facetValue);

    if (!isRefined) {
      instantSearchInstance.sendEventToInsights({
        insightsMethod: 'clickedFilters',
        widgetType: connectRatingMenu_$$type,
        eventType: eventType,
        payload: {
          eventName: eventName,
          index: helper.getIndex(),
          filters: ["".concat(attribute, ">=").concat(facetValue)]
        }
      });
    }
  };
};
/**
 * @typedef {Object} StarRatingItems
 * @property {string} name Name corresponding to the number of stars.
 * @property {string} value Number of stars as string.
 * @property {number} count Count of matched results corresponding to the number of stars.
 * @property {boolean[]} stars Array of length of maximum rating value with stars to display or not.
 * @property {boolean} isRefined Indicates if star rating refinement is applied.
 */

/**
 * @typedef {Object} CustomStarRatingWidgetOptions
 * @property {string} attribute Name of the attribute for faceting (eg. "free_shipping").
 * @property {number} [max = 5] The maximum rating value.
 */

/**
 * @typedef {Object} StarRatingRenderingOptions
 * @property {StarRatingItems[]} items Possible star ratings the user can apply.
 * @property {function(string): string} createURL Creates an URL for the next
 * state (takes the item value as parameter). Takes the value of an item as parameter.
 * @property {function(string)} refine Selects a rating to filter the results
 * (takes the filter value as parameter). Takes the value of an item as parameter.
 * @property {boolean} hasNoResults `true` if the last search contains no result.
 * @property {Object} widgetParams All original `CustomStarRatingWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * **StarRating** connector provides the logic to build a custom widget that will let
 * the user refine search results based on ratings.
 *
 * The connector provides to the rendering: `refine()` to select a value and
 * `items` that are the values that can be selected. `refine` should be used
 * with `items.value`.
 * @type {Connector}
 * @param {function(StarRatingRenderingOptions, boolean)} renderFn Rendering function for the custom **StarRating** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomStarRatingWidgetOptions)} Re-usable widget factory for a custom **StarRating** widget.
 * @example
 * // custom `renderFn` to render the custom StarRating widget
 * function renderFn(StarRatingRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) {
 *     StarRatingRenderingOptions.widgetParams.containerNode.html('<ul></ul>');
 *   }
 *
 *   StarRatingRenderingOptions.widgetParams.containerNode
 *     .find('li[data-refine-value]')
 *     .each(function() { $(this).off('click'); });
 *
 *   var listHTML = StarRatingRenderingOptions.items.map(function(item) {
 *     return '<li data-refine-value="' + item.value + '">' +
 *       '<a href="' + StarRatingRenderingOptions.createURL(item.value) + '">' +
 *       item.stars.map(function(star) { return star === false ? '☆' : '★'; }).join(' ') +
 *       '& up (' + item.count + ')' +
 *       '</a></li>';
 *   });
 *
 *   StarRatingRenderingOptions.widgetParams.containerNode
 *     .find('ul')
 *     .html(listHTML);
 *
 *   StarRatingRenderingOptions.widgetParams.containerNode
 *     .find('li[data-refine-value]')
 *     .each(function() {
 *       $(this).on('click', function(event) {
 *         event.preventDefault();
 *         event.stopPropagation();
 *
 *         StarRatingRenderingOptions.refine($(this).data('refine-value'));
 *       });
 *     });
 * }
 *
 * // connect `renderFn` to StarRating logic
 * var customStarRating = instantsearch.connectors.connectRatingMenu(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customStarRating({
 *     containerNode: $('#custom-rating-menu-container'),
 *     attribute: 'rating',
 *     max: 5,
 *   })
 * ]);
 */


function connectRatingMenu(renderFn) {
  var _this = this;

  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectRatingMenu_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attribute = widgetParams.attribute,
        _widgetParams$max = widgetParams.max,
        max = _widgetParams$max === void 0 ? 5 : _widgetParams$max;
    var sendEvent;

    if (!attribute) {
      throw new Error(connectRatingMenu_withUsage('The `attribute` option is required.'));
    }

    var _getRefinedStar = function getRefinedStar(state) {
      var refinements = state.getDisjunctiveRefinements(attribute);

      if (!refinements.length) {
        return undefined;
      }

      return Math.min.apply(Math, connectRatingMenu_toConsumableArray(refinements.map(Number)));
    };

    var toggleRefinement = function toggleRefinement(helper, facetValue) {
      sendEvent('click', facetValue);
      var isRefined = _getRefinedStar(helper.state) === Number(facetValue);
      helper.removeDisjunctiveFacetRefinement(attribute);

      if (!isRefined) {
        for (var val = Number(facetValue); val <= max; ++val) {
          helper.addDisjunctiveFacetRefinement(attribute, val);
        }
      }

      helper.search();
    };

    var connectorState = {
      toggleRefinementFactory: function toggleRefinementFactory(helper) {
        return toggleRefinement.bind(_this, helper);
      },
      createURLFactory: function createURLFactory(_ref2) {
        var state = _ref2.state,
            createURL = _ref2.createURL;
        return function (value) {
          return createURL(state.toggleRefinement(attribute, value));
        };
      }
    };
    return {
      $$type: connectRatingMenu_$$type,
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectRatingMenu_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectRatingMenu_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectRatingMenu_objectSpread({}, renderState, {
          ratingMenu: connectRatingMenu_objectSpread({}, renderState.ratingMenu, connectRatingMenu_defineProperty({}, attribute, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref3) {
        var helper = _ref3.helper,
            results = _ref3.results,
            state = _ref3.state,
            instantSearchInstance = _ref3.instantSearchInstance,
            createURL = _ref3.createURL;
        var facetValues = [];

        if (!sendEvent) {
          sendEvent = connectRatingMenu_createSendEvent({
            instantSearchInstance: instantSearchInstance,
            helper: helper,
            getRefinedStar: function getRefinedStar() {
              return _getRefinedStar(helper.state);
            },
            attribute: attribute
          });
        }

        if (results) {
          var allValues = {};

          for (var v = max; v >= 0; --v) {
            allValues[v] = 0;
          }

          (results.getFacetValues(attribute) || []).forEach(function (facet) {
            var val = Math.round(facet.name);

            if (!val || val > max) {
              return;
            }

            for (var _v = val; _v >= 1; --_v) {
              allValues[_v] += facet.count;
            }
          });

          var refinedStar = _getRefinedStar(state);

          for (var star = max - 1; star >= 1; --star) {
            var count = allValues[star];

            if (refinedStar && star !== refinedStar && count === 0) {
              // skip count==0 when at least 1 refinement is enabled
              // eslint-disable-next-line no-continue
              continue;
            }

            var stars = [];

            for (var i = 1; i <= max; ++i) {
              stars.push(i <= star);
            }

            facetValues.push({
              stars: stars,
              name: String(star),
              value: String(star),
              count: count,
              isRefined: refinedStar === star
            });
          }
        }

        return {
          items: facetValues,
          hasNoResults: results ? results.nbHits === 0 : true,
          refine: connectorState.toggleRefinementFactory(helper),
          sendEvent: sendEvent,
          createURL: connectorState.createURLFactory({
            state: state,
            createURL: createURL
          }),
          widgetParams: widgetParams
        };
      },
      dispose: function dispose(_ref4) {
        var state = _ref4.state;
        unmountFn();
        return state.removeDisjunctiveFacet(attribute);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {
        var searchParameters = _ref5.searchParameters;

        var value = _getRefinedStar(searchParameters);

        if (typeof value !== 'number') {
          return uiState;
        }

        return connectRatingMenu_objectSpread({}, uiState, {
          ratingMenu: connectRatingMenu_objectSpread({}, uiState.ratingMenu, connectRatingMenu_defineProperty({}, attribute, value))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
        var uiState = _ref6.uiState;
        var value = uiState.ratingMenu && uiState.ratingMenu[attribute];
        var withoutRefinements = searchParameters.clearRefinements(attribute);
        var withDisjunctiveFacet = withoutRefinements.addDisjunctiveFacet(attribute);

        if (!value) {
          return withDisjunctiveFacet.setQueryParameters({
            disjunctiveFacetsRefinements: connectRatingMenu_objectSpread({}, withDisjunctiveFacet.disjunctiveFacetsRefinements, connectRatingMenu_defineProperty({}, attribute, []))
          });
        }

        return Object(range["a" /* default */])({
          start: Number(value),
          end: max + 1
        }).reduce(function (parameters, number) {
          return parameters.addDisjunctiveFacetRefinement(attribute, number);
        }, withDisjunctiveFacet);
      }
    };
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/stats/connectStats.js
function connectStats_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectStats_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectStats_ownKeys(Object(source), true).forEach(function (key) {
        connectStats_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectStats_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectStats_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectStats_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'stats',
  connector: true
});
/**
 * @typedef {Object} StatsRenderingOptions
 * @property {number} hitsPerPage The maximum number of hits per page returned by Algolia.
 * @property {number} nbHits The number of hits in the result set.
 * @property {number} nbPages The number of pages computed for the result set.
 * @property {number} page The current page.
 * @property {number} processingTimeMS The time taken to compute the results inside the Algolia engine.
 * @property {string} query The query used for the current search.
 * @property {object} widgetParams All original `CustomStatsWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * @typedef {Object} CustomStatsWidgetOptions
 */

/**
 * **Stats** connector provides the logic to build a custom widget that will displays
 * search statistics (hits number and processing time).
 *
 * @type {Connector}
 * @param {function(StatsRenderingOptions, boolean)} renderFn Rendering function for the custom **Stats** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomStatsWidgetOptions)} Re-usable widget factory for a custom **Stats** widget.
 * @example
 * // custom `renderFn` to render the custom Stats widget
 * function renderFn(StatsRenderingOptions, isFirstRendering) {
 *   if (isFirstRendering) return;
 *
 *   StatsRenderingOptions.widgetParams.containerNode
 *     .html(StatsRenderingOptions.nbHits + ' results found in ' + StatsRenderingOptions.processingTimeMS);
 * }
 *
 * // connect `renderFn` to Stats logic
 * var customStatsWidget = instantsearch.connectors.connectStats(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customStatsWidget({
 *     containerNode: $('#custom-stats-container'),
 *   })
 * ]);
 */

function connectStats(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectStats_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      $$type: 'ais.stats',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectStats_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectStats_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose() {
        unmountFn();
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectStats_objectSpread({}, renderState, {
          stats: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref) {
        var results = _ref.results,
            helper = _ref.helper;

        if (!results) {
          return {
            hitsPerPage: helper.state.hitsPerPage,
            nbHits: 0,
            nbPages: 0,
            page: helper.state.page || 0,
            processingTimeMS: -1,
            query: helper.state.query || '',
            widgetParams: widgetParams
          };
        }

        return {
          hitsPerPage: results.hitsPerPage,
          nbHits: results.nbHits,
          nbPages: results.nbPages,
          page: results.page,
          processingTimeMS: results.processingTimeMS,
          query: results.query,
          widgetParams: widgetParams
        };
      }
    };
  };
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/toArray.js
var toArray = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/escapeRefinement.js
var escapeRefinement = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/unescapeRefinement.js
var unescapeRefinement = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/toggle-refinement/connectToggleRefinement.js
function connectToggleRefinement_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectToggleRefinement_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectToggleRefinement_ownKeys(Object(source), true).forEach(function (key) {
        connectToggleRefinement_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectToggleRefinement_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectToggleRefinement_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectToggleRefinement_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'toggle-refinement',
  connector: true
});
var connectToggleRefinement_$$type = 'ais.toggleRefinement';

var connectToggleRefinement_createSendEvent = function createSendEvent(_ref) {
  var instantSearchInstance = _ref.instantSearchInstance,
      attribute = _ref.attribute,
      on = _ref.on,
      helper = _ref.helper;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1) {
      instantSearchInstance.sendEventToInsights(args[0]);
      return;
    }

    var eventType = args[0],
        isRefined = args[1],
        _args$ = args[2],
        eventName = _args$ === void 0 ? 'Filter Applied' : _args$;

    if (eventType !== 'click' || on === undefined) {
      return;
    } // Checking


    if (!isRefined) {
      instantSearchInstance.sendEventToInsights({
        insightsMethod: 'clickedFilters',
        widgetType: connectToggleRefinement_$$type,
        eventType: eventType,
        payload: {
          eventName: eventName,
          index: helper.getIndex(),
          filters: on.map(function (value) {
            return "".concat(attribute, ":").concat(JSON.stringify(value));
          })
        }
      });
    }
  };
};
/**
 * @typedef {Object} ToggleValue
 * @property {boolean} isRefined `true` if the toggle is on.
 * @property {number} count Number of results matched after applying the toggle refinement.
 * @property {Object} onFacetValue Value of the toggle when it's on.
 * @property {Object} offFacetValue Value of the toggle when it's off.
 */

/**
 * @typedef {Object} CustomToggleWidgetOptions
 * @property {string} attribute Name of the attribute for faceting (eg. "free_shipping").
 * @property {Object} [on = true] Value to filter on when toggled.
 * @property {Object} [off] Value to filter on when not toggled.
 */

/**
 * @typedef {Object} ToggleRenderingOptions
 * @property {ToggleValue} value The current toggle value.
 * @property {function():string} createURL Creates an URL for the next state.
 * @property {function(value)} refine Updates to the next state by applying the toggle refinement.
 * @property {Object} widgetParams All original `CustomToggleWidgetOptions` forwarded to the `renderFn`.
 */

/**
 * **Toggle** connector provides the logic to build a custom widget that will provide
 * an on/off filtering feature based on an attribute value or values.
 *
 * Two modes are implemented in the custom widget:
 *  - with or without the value filtered
 *  - switch between two values.
 *
 * @type {Connector}
 * @param {function(ToggleRenderingOptions, boolean)} renderFn Rendering function for the custom **Toggle** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomToggleWidgetOptions)} Re-usable widget factory for a custom **Toggle** widget.
 * @example
 * // custom `renderFn` to render the custom ClearAll widget
 * function renderFn(ToggleRenderingOptions, isFirstRendering) {
 *   ToggleRenderingOptions.widgetParams.containerNode
 *     .find('a')
 *     .off('click');
 *
 *   var buttonHTML = `
 *     <a href="${ToggleRenderingOptions.createURL()}">
 *       <input
 *         type="checkbox"
 *         value="${ToggleRenderingOptions.value.name}"
 *         ${ToggleRenderingOptions.value.isRefined ? 'checked' : ''}
 *       />
 *       ${ToggleRenderingOptions.value.name} (${ToggleRenderingOptions.value.count})
 *     </a>
 *   `;
 *
 *   ToggleRenderingOptions.widgetParams.containerNode.html(buttonHTML);
 *   ToggleRenderingOptions.widgetParams.containerNode
 *     .find('a')
 *     .on('click', function(event) {
 *       event.preventDefault();
 *       event.stopPropagation();
 *
 *       ToggleRenderingOptions.refine(ToggleRenderingOptions.value);
 *     });
 * }
 *
 * // connect `renderFn` to Toggle logic
 * var customToggle = instantsearch.connectors.connectToggleRefinement(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customToggle({
 *     containerNode: $('#custom-toggle-container'),
 *     attribute: 'free_shipping',
 *   })
 * ]);
 */


function connectToggleRefinement(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectToggleRefinement_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attribute = widgetParams.attribute,
        _widgetParams$on = widgetParams.on,
        userOn = _widgetParams$on === void 0 ? true : _widgetParams$on,
        userOff = widgetParams.off;

    if (!attribute) {
      throw new Error(connectToggleRefinement_withUsage('The `attribute` option is required.'));
    }

    var hasAnOffValue = userOff !== undefined;
    var hasAnOnValue = userOn !== undefined;
    var on = hasAnOnValue ? Object(toArray["a" /* default */])(userOn).map(escapeRefinement["a" /* default */]) : undefined;
    var off = hasAnOffValue ? Object(toArray["a" /* default */])(userOff).map(escapeRefinement["a" /* default */]) : undefined;
    var sendEvent;

    var toggleRefinementFactory = function toggleRefinementFactory(helper) {
      return function () {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            isRefined = _ref2.isRefined; // Checking


        if (!isRefined) {
          sendEvent('click', isRefined);

          if (hasAnOffValue) {
            off.forEach(function (v) {
              return helper.removeDisjunctiveFacetRefinement(attribute, v);
            });
          }

          on.forEach(function (v) {
            return helper.addDisjunctiveFacetRefinement(attribute, v);
          });
        } else {
          // Unchecking
          on.forEach(function (v) {
            return helper.removeDisjunctiveFacetRefinement(attribute, v);
          });

          if (hasAnOffValue) {
            off.forEach(function (v) {
              return helper.addDisjunctiveFacetRefinement(attribute, v);
            });
          }
        }

        helper.search();
      };
    };

    var connectorState = {
      createURLFactory: function createURLFactory(isRefined, _ref3) {
        var state = _ref3.state,
            createURL = _ref3.createURL;
        return function () {
          var valuesToRemove = isRefined ? on : off;

          if (valuesToRemove) {
            valuesToRemove.forEach(function (v) {
              state.removeDisjunctiveFacetRefinement(attribute, v);
            });
          }

          var valuesToAdd = isRefined ? off : on;

          if (valuesToAdd) {
            valuesToAdd.forEach(function (v) {
              state.addDisjunctiveFacetRefinement(attribute, v);
            });
          }

          return createURL(state);
        };
      }
    };
    return {
      $$type: connectToggleRefinement_$$type,
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectToggleRefinement_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectToggleRefinement_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref4) {
        var state = _ref4.state;
        unmountFn();
        return state.removeDisjunctiveFacet(attribute);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectToggleRefinement_objectSpread({}, renderState, {
          toggleRefinement: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref5) {
        var state = _ref5.state,
            helper = _ref5.helper,
            results = _ref5.results,
            createURL = _ref5.createURL,
            instantSearchInstance = _ref5.instantSearchInstance;
        var isRefined = results ? on === null || on === void 0 ? void 0 : on.every(function (v) {
          return helper.state.isDisjunctiveFacetRefined(attribute, v);
        }) : on === null || on === void 0 ? void 0 : on.every(function (v) {
          return state.isDisjunctiveFacetRefined(attribute, v);
        });
        var onFacetValue = {
          isRefined: isRefined,
          count: 0
        };
        var offFacetValue = {
          isRefined: hasAnOffValue && !isRefined,
          count: 0
        };

        if (results) {
          var offValue = Object(toArray["a" /* default */])(off || false);
          var allFacetValues = results.getFacetValues(attribute) || [];
          var onData = on === null || on === void 0 ? void 0 : on.map(function (v) {
            return Object(find["a" /* default */])(allFacetValues, function (_ref6) {
              var name = _ref6.name;
              return name === Object(unescapeRefinement["a" /* default */])(v);
            });
          }).filter(function (v) {
            return v !== undefined;
          });
          var offData = hasAnOffValue ? offValue.map(function (v) {
            return Object(find["a" /* default */])(allFacetValues, function (_ref7) {
              var name = _ref7.name;
              return name === Object(unescapeRefinement["a" /* default */])(v);
            });
          }).filter(function (v) {
            return v !== undefined;
          }) : [];
          onFacetValue = {
            isRefined: onData.length ? onData.every(function (v) {
              return v.isRefined;
            }) : false,
            count: onData.reduce(function (acc, v) {
              return acc + v.count;
            }, 0) || null
          };
          offFacetValue = {
            isRefined: offData.length ? offData.every(function (v) {
              return v.isRefined;
            }) : false,
            count: offData.reduce(function (acc, v) {
              return acc + v.count;
            }, 0) || allFacetValues.reduce(function (total, _ref8) {
              var count = _ref8.count;
              return total + count;
            }, 0)
          };
        } else if (hasAnOffValue && !isRefined) {
          if (off) {
            off.forEach(function (v) {
              return helper.addDisjunctiveFacetRefinement(attribute, v);
            });
          }

          helper.setPage(helper.state.page);
        }

        if (!sendEvent) {
          sendEvent = connectToggleRefinement_createSendEvent({
            instantSearchInstance: instantSearchInstance,
            attribute: attribute,
            on: on,
            helper: helper
          });
        }

        var nextRefinement = isRefined ? offFacetValue : onFacetValue;
        return {
          value: {
            name: attribute,
            isRefined: isRefined,
            count: results ? nextRefinement.count : null,
            onFacetValue: onFacetValue,
            offFacetValue: offFacetValue
          },
          state: state,
          createURL: connectorState.createURLFactory(isRefined, {
            state: state,
            createURL: createURL
          }),
          sendEvent: sendEvent,
          refine: toggleRefinementFactory(helper),
          widgetParams: widgetParams
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref9) {
        var searchParameters = _ref9.searchParameters;
        var isRefined = on && on.every(function (v) {
          return searchParameters.isDisjunctiveFacetRefined(attribute, v);
        });

        if (!isRefined) {
          return uiState;
        }

        return connectToggleRefinement_objectSpread({}, uiState, {
          toggle: connectToggleRefinement_objectSpread({}, uiState.toggle, connectToggleRefinement_defineProperty({}, attribute, isRefined))
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref10) {
        var uiState = _ref10.uiState;
        var withFacetConfiguration = searchParameters.clearRefinements(attribute).addDisjunctiveFacet(attribute);
        var isRefined = Boolean(uiState.toggle && uiState.toggle[attribute]);

        if (isRefined) {
          if (on) {
            on.forEach(function (v) {
              withFacetConfiguration = withFacetConfiguration.addDisjunctiveFacetRefinement(attribute, v);
            });
          }

          return withFacetConfiguration;
        } // It's not refined with an `off` value


        if (hasAnOffValue) {
          if (off) {
            off.forEach(function (v) {
              withFacetConfiguration = withFacetConfiguration.addDisjunctiveFacetRefinement(attribute, v);
            });
          }

          return withFacetConfiguration;
        } // It's not refined without an `off` value


        return withFacetConfiguration.setQueryParameters({
          disjunctiveFacetsRefinements: connectToggleRefinement_objectSpread({}, searchParameters.disjunctiveFacetsRefinements, connectToggleRefinement_defineProperty({}, attribute, []))
        });
      }
    };
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/breadcrumb/connectBreadcrumb.js
function connectBreadcrumb_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectBreadcrumb_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectBreadcrumb_ownKeys(Object(source), true).forEach(function (key) {
        connectBreadcrumb_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectBreadcrumb_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectBreadcrumb_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectBreadcrumb_slicedToArray(arr, i) {
  return connectBreadcrumb_arrayWithHoles(arr) || connectBreadcrumb_iterableToArrayLimit(arr, i) || connectBreadcrumb_nonIterableRest();
}

function connectBreadcrumb_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function connectBreadcrumb_iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function connectBreadcrumb_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}


var connectBreadcrumb_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'breadcrumb',
  connector: true
});

var connectBreadcrumb_connectBreadcrumb = function connectBreadcrumb(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectBreadcrumb_withUsage());
  var connectorState = {};
  return function (widgetParams) {
    var _ref = widgetParams || {},
        attributes = _ref.attributes,
        _ref$separator = _ref.separator,
        separator = _ref$separator === void 0 ? ' > ' : _ref$separator,
        _ref$rootPath = _ref.rootPath,
        rootPath = _ref$rootPath === void 0 ? null : _ref$rootPath,
        _ref$transformItems = _ref.transformItems,
        transformItems = _ref$transformItems === void 0 ? function (items) {
      return items;
    } : _ref$transformItems;

    if (!attributes || !Array.isArray(attributes) || attributes.length === 0) {
      throw new Error(connectBreadcrumb_withUsage('The `attributes` option expects an array of strings.'));
    }

    var _attributes = connectBreadcrumb_slicedToArray(attributes, 1),
        hierarchicalFacetName = _attributes[0];

    return {
      $$type: 'ais.breadcrumb',
      init: function init(initOptions) {
        renderFn(connectBreadcrumb_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: initOptions.instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        renderFn(connectBreadcrumb_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: renderOptions.instantSearchInstance
        }), false);
      },
      dispose: function dispose() {
        unmountFn();
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectBreadcrumb_objectSpread({}, renderState, {
          breadcrumb: connectBreadcrumb_objectSpread({}, renderState.breadcrumb, connectBreadcrumb_defineProperty({}, hierarchicalFacetName, this.getWidgetRenderState(renderOptions)))
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var helper = _ref2.helper,
            createURL = _ref2.createURL,
            results = _ref2.results,
            state = _ref2.state;

        function getItems() {
          if (!results) {
            return [];
          }

          var _state$hierarchicalFa = connectBreadcrumb_slicedToArray(state.hierarchicalFacets, 1),
              facetName = _state$hierarchicalFa[0].name;

          var facetValues = results.getFacetValues(facetName, {});
          var data = Array.isArray(facetValues.data) ? facetValues.data : [];
          var items = transformItems(shiftItemsValues(connectBreadcrumb_prepareItems(data)));
          return items;
        }

        var items = getItems();

        if (!connectorState.createURL) {
          connectorState.createURL = function (facetValue) {
            if (!facetValue) {
              var breadcrumb = helper.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);

              if (breadcrumb.length > 0) {
                return createURL(helper.state.toggleFacetRefinement(hierarchicalFacetName, breadcrumb[0]));
              }
            }

            return createURL(helper.state.toggleFacetRefinement(hierarchicalFacetName, facetValue));
          };
        }

        if (!connectorState.refine) {
          connectorState.refine = function (facetValue) {
            if (!facetValue) {
              var breadcrumb = helper.getHierarchicalFacetBreadcrumb(hierarchicalFacetName);

              if (breadcrumb.length > 0) {
                helper.toggleRefinement(hierarchicalFacetName, breadcrumb[0]).search();
              }
            } else {
              helper.toggleRefinement(hierarchicalFacetName, facetValue).search();
            }
          };
        }

        return {
          canRefine: items.length > 0,
          createURL: connectorState.createURL,
          items: items,
          refine: connectorState.refine,
          widgetParams: widgetParams
        };
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters) {
        if (searchParameters.isHierarchicalFacet(hierarchicalFacetName)) {
          var facet = searchParameters.getHierarchicalFacetByName(hierarchicalFacetName);
           false ? undefined : void 0;
          return searchParameters;
        }

        return searchParameters.addHierarchicalFacet({
          name: hierarchicalFacetName,
          attributes: attributes,
          separator: separator,
          rootPath: rootPath
        });
      }
    };
  };
};

function connectBreadcrumb_prepareItems(data) {
  return data.reduce(function (result, currentItem) {
    if (currentItem.isRefined) {
      result.push({
        label: currentItem.name,
        value: currentItem.path
      });

      if (Array.isArray(currentItem.data)) {
        result = result.concat(connectBreadcrumb_prepareItems(currentItem.data));
      }
    }

    return result;
  }, []);
}

function shiftItemsValues(array) {
  return array.map(function (x, idx) {
    return {
      label: x.label,
      value: idx + 1 === array.length ? null : array[idx + 1].value
    };
  });
}

/* harmony default export */ var breadcrumb_connectBreadcrumb = (connectBreadcrumb_connectBreadcrumb);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/geo-search.js
var geo_search = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js
function connectGeoSearch_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectGeoSearch_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectGeoSearch_ownKeys(Object(source), true).forEach(function (key) {
        connectGeoSearch_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectGeoSearch_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectGeoSearch_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectGeoSearch_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'geo-search',
  connector: true
});
var connectGeoSearch_$$type = 'ais.geoSearch';
/**
 * @typedef {Object} LatLng
 * @property {number} lat The latitude in degrees.
 * @property {number} lng The longitude in degrees.
 */

/**
 * @typedef {Object} Bounds
 * @property {LatLng} northEast The top right corner of the map view.
 * @property {LatLng} southWest The bottom left corner of the map view.
 */

/**
 * @typedef {Object} CustomGeoSearchWidgetOptions
 * @property {boolean} [enableRefineOnMapMove=true] If true, refine will be triggered as you move the map.
 * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.
 */

/**
 * @typedef {Object} GeoSearchRenderingOptions
 * @property {Object[]} items The matched hits from Algolia API.
 * @property {LatLng} position The current position of the search.
 * @property {Bounds} currentRefinement The current bounding box of the search.
 * @property {function(Bounds)} refine Sets a bounding box to filter the results from the given map bounds.
 * @property {function()} clearMapRefinement Reset the current bounding box refinement.
 * @property {function(): boolean} isRefinedWithMap Return true if the current refinement is set with the map bounds.
 * @property {function()} toggleRefineOnMapMove Toggle the fact that the user is able to refine on map move.
 * @property {function(): boolean} isRefineOnMapMove Return true if the user is able to refine on map move.
 * @property {function()} setMapMoveSinceLastRefine Set the fact that the map has moved since the last refinement, should be call on each map move. The call to the function triggers a new rendering only when the value change.
 * @property {function(): boolean} hasMapMoveSinceLastRefine Return true if the map has move since the last refinement.
 * @property {Object} widgetParams All original `CustomGeoSearchWidgetOptions` forwarded to the `renderFn`.
 * @property {LatLng} [position] The current position of the search.
 */

/**
 * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).
 *
 * @requirements
 *
 * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.
 *
 * Currently, the feature is not compatible with multiple values in the _geoloc attribute.
 *
 * @param {function(GeoSearchRenderingOptions, boolean)} renderFn Rendering function for the custom **GeoSearch** widget.
 * @param {function} unmountFn Unmount function called when the widget is disposed.
 * @return {function(CustomGeoSearchWidgetOptions)} Re-usable widget factory for a custom **GeoSearch** widget.
 * @staticExample
 * // This example use Leaflet for the rendering, be sure to have the library correctly setup
 * // before trying the demo. You can find more details in their documentation (link below).
 * // We choose Leaflet for the example but you can use any libraries that you want.
 * // See: http://leafletjs.com/examples/quick-start
 *
 * let map = null;
 * let markers = [];
 *
 * // custom `renderFn` to render the custom GeoSearch widget
 * function renderFn(GeoSearchRenderingOptions, isFirstRendering) {
 *   const { items, widgetParams } = GeoSearchRenderingOptions;
 *
 *   if (isFirstRendering) {
 *     map = L.map(widgetParams.container);
 *
 *     L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
 *       attribution:
 *         '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
 *     }).addTo(map);
 *   }
 *
 *   markers.forEach(marker => marker.remove());
 *
 *   markers = items.map(({ _geoloc }) =>
 *     L.marker([_geoloc.lat, _geoloc.lng]).addTo(map)
 *   );
 *
 *   if (markers.length) {
 *     map.fitBounds(L.featureGroup(markers).getBounds());
 *   }
 * }
 *
 * // connect `renderFn` to GeoSearch logic
 * const customGeoSearch = instantsearch.connectors.connectGeoSearch(renderFn);
 *
 * // mount widget on the page
 * search.addWidgets([
 *   customGeoSearch({
 *     container: document.getElementById('custom-geo-search'),
 *   })
 * ]);
 */

var connectGeoSearch_connectGeoSearch = function connectGeoSearch(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectGeoSearch_withUsage());
  return function () {
    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _widgetParams$enableR = widgetParams.enableRefineOnMapMove,
        enableRefineOnMapMove = _widgetParams$enableR === void 0 ? true : _widgetParams$enableR,
        _widgetParams$transfo = widgetParams.transformItems,
        transformItems = _widgetParams$transfo === void 0 ? function (items) {
      return items;
    } : _widgetParams$transfo;
    var widgetState = {
      isRefineOnMapMove: enableRefineOnMapMove,
      // @MAJOR hasMapMoveSinceLastRefine -> hasMapMovedSinceLastRefine
      hasMapMoveSinceLastRefine: false,
      lastRefinePosition: '',
      lastRefineBoundingBox: '',
      internalToggleRefineOnMapMove: noop["a" /* default */],
      internalSetMapMoveSinceLastRefine: noop["a" /* default */]
    };

    var getPositionFromState = function getPositionFromState(state) {
      return state.aroundLatLng && Object(geo_search["a" /* aroundLatLngToPosition */])(state.aroundLatLng);
    };

    var getCurrentRefinementFromState = function getCurrentRefinementFromState(state) {
      return state.insideBoundingBox && Object(geo_search["b" /* insideBoundingBoxToBoundingBox */])(state.insideBoundingBox);
    };

    var refine = function refine(helper) {
      return function (_ref) {
        var ne = _ref.northEast,
            sw = _ref.southWest;
        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();
        helper.setQueryParameter('insideBoundingBox', boundingBox).search();
        widgetState.hasMapMoveSinceLastRefine = false;
        widgetState.lastRefineBoundingBox = boundingBox;
      };
    };

    var clearMapRefinement = function clearMapRefinement(helper) {
      return function () {
        helper.setQueryParameter('insideBoundingBox', undefined).search();
      };
    };

    var isRefinedWithMap = function isRefinedWithMap(state) {
      return function () {
        return Boolean(state.insideBoundingBox);
      };
    };

    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {
      return widgetState.internalToggleRefineOnMapMove();
    };

    var createInternalToggleRefinementOnMapMove = function createInternalToggleRefinementOnMapMove(render, args) {
      return function () {
        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;
        render(args);
      };
    };

    var isRefineOnMapMove = function isRefineOnMapMove() {
      return widgetState.isRefineOnMapMove;
    };

    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {
      return widgetState.internalSetMapMoveSinceLastRefine();
    };

    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(render, args) {
      return function () {
        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;
        widgetState.hasMapMoveSinceLastRefine = true;

        if (shouldTriggerRender) {
          render(args);
        }
      };
    };

    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {
      return widgetState.hasMapMoveSinceLastRefine;
    };

    var sendEvent;
    return {
      $$type: connectGeoSearch_$$type,
      init: function init(initArgs) {
        var instantSearchInstance = initArgs.instantSearchInstance;
        var isFirstRendering = true;
        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(noop["a" /* default */], initArgs);
        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(noop["a" /* default */], initArgs);
        renderFn(connectGeoSearch_objectSpread({}, this.getWidgetRenderState(initArgs), {
          instantSearchInstance: instantSearchInstance
        }), isFirstRendering);
      },
      render: function render(renderArgs) {
        var helper = renderArgs.helper,
            instantSearchInstance = renderArgs.instantSearchInstance;
        var isFirstRendering = false; // We don't use the state provided by the render function because we need
        // to be sure that the state is the latest one for the following condition

        var state = helper.state;
        var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;
        var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;

        if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {
          widgetState.hasMapMoveSinceLastRefine = false;
        }

        widgetState.lastRefinePosition = state.aroundLatLng || '';
        widgetState.lastRefineBoundingBox = state.insideBoundingBox || '';
        widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementOnMapMove(this.render.bind(this), renderArgs);
        widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(this.render.bind(this), renderArgs);
        var widgetRenderState = this.getWidgetRenderState(renderArgs);
        sendEvent('view', widgetRenderState.items);
        renderFn(connectGeoSearch_objectSpread({}, widgetRenderState, {
          instantSearchInstance: instantSearchInstance
        }), isFirstRendering);
      },
      getWidgetRenderState: function getWidgetRenderState(renderOptions) {
        var helper = renderOptions.helper,
            results = renderOptions.results,
            instantSearchInstance = renderOptions.instantSearchInstance;
        var state = helper.state;
        var items = results ? transformItems(results.hits.filter(function (hit) {
          return hit._geoloc;
        })) : [];

        if (!sendEvent) {
          sendEvent = Object(createSendEventForHits["b" /* createSendEventForHits */])({
            instantSearchInstance: instantSearchInstance,
            index: helper.getIndex(),
            widgetType: connectGeoSearch_$$type
          });
        }

        return {
          items: items,
          position: getPositionFromState(state),
          currentRefinement: getCurrentRefinementFromState(state),
          refine: refine(helper),
          sendEvent: sendEvent,
          clearMapRefinement: clearMapRefinement(helper),
          isRefinedWithMap: isRefinedWithMap(state),
          toggleRefineOnMapMove: toggleRefineOnMapMove,
          isRefineOnMapMove: isRefineOnMapMove,
          setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,
          hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,
          widgetParams: widgetParams
        };
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectGeoSearch_objectSpread({}, renderState, {
          geoSearch: this.getWidgetRenderState(renderOptions)
        });
      },
      dispose: function dispose(_ref2) {
        var state = _ref2.state;
        unmountFn();
        return state.setQueryParameter('insideBoundingBox', undefined);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref3) {
        var searchParameters = _ref3.searchParameters;
        var boundingBox = searchParameters.insideBoundingBox;

        if (!boundingBox || uiState && uiState.geoSearch && uiState.geoSearch.boundingBox === boundingBox) {
          return uiState;
        }

        return connectGeoSearch_objectSpread({}, uiState, {
          geoSearch: {
            boundingBox: boundingBox
          }
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref4) {
        var uiState = _ref4.uiState;

        if (!uiState || !uiState.geoSearch) {
          return searchParameters.setQueryParameter('insideBoundingBox', undefined);
        }

        return searchParameters.setQueryParameter('insideBoundingBox', uiState.geoSearch.boundingBox);
      }
    };
  };
};

/* harmony default export */ var geo_search_connectGeoSearch = (connectGeoSearch_connectGeoSearch);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/powered-by/connectPoweredBy.js
function connectPoweredBy_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectPoweredBy_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectPoweredBy_ownKeys(Object(source), true).forEach(function (key) {
        connectPoweredBy_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectPoweredBy_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectPoweredBy_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


var connectPoweredBy_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'powered-by',
  connector: true
});
/**
 * **PoweredBy** connector provides the logic to build a custom widget that will displays
 * the logo to redirect to Algolia.
 */

var connectPoweredBy_connectPoweredBy = function connectPoweredBy(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectPoweredBy_withUsage());
  var defaultUrl = 'https://www.algolia.com/?' + 'utm_source=instantsearch.js&' + 'utm_medium=website&' + "utm_content=".concat(typeof window !== 'undefined' && window.location ? window.location.hostname : '', "&") + 'utm_campaign=poweredby';
  return function (widgetParams) {
    var _ref = widgetParams || {},
        _ref$url = _ref.url,
        url = _ref$url === void 0 ? defaultUrl : _ref$url;

    return {
      $$type: 'ais.poweredBy',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectPoweredBy_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectPoweredBy_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectPoweredBy_objectSpread({}, renderState, {
          poweredBy: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState() {
        return {
          url: url,
          widgetParams: widgetParams
        };
      },
      dispose: function dispose() {
        unmountFn();
      }
    };
  };
};

/* harmony default export */ var powered_by_connectPoweredBy = (connectPoweredBy_connectPoweredBy);
// EXTERNAL MODULE: external "algoliasearch-helper"
var external_algoliasearch_helper_ = __webpack_require__(4);
var external_algoliasearch_helper_default = /*#__PURE__*/__webpack_require__.n(external_algoliasearch_helper_);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isPlainObject.js
var isPlainObject = __webpack_require__(24);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js
function connectConfigure_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectConfigure_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectConfigure_ownKeys(Object(source), true).forEach(function (key) {
        connectConfigure_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectConfigure_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectConfigure_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



/**
 * Refine the given search parameters.
 */

var connectConfigure_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'configure',
  connector: true
});

function getInitialSearchParameters(state, widgetParams) {
  // We leverage the helper internals to remove the `widgetParams` from
  // the state. The function `setQueryParameters` omits the values that
  // are `undefined` on the next state.
  return state.setQueryParameters(Object.keys(widgetParams.searchParameters).reduce(function (acc, key) {
    return connectConfigure_objectSpread({}, acc, connectConfigure_defineProperty({}, key, undefined));
  }, {}));
}

var connectConfigure_connectConfigure = function connectConfigure() {
  var renderFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop["a" /* default */];
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  return function (widgetParams) {
    if (!widgetParams || !Object(isPlainObject["a" /* default */])(widgetParams.searchParameters)) {
      throw new Error(connectConfigure_withUsage('The `searchParameters` option expects an object.'));
    }

    var connectorState = {};

    function refine(helper) {
      return function (searchParameters) {
        // Merge new `searchParameters` with the ones set from other widgets
        var actualState = getInitialSearchParameters(helper.state, widgetParams);
        var nextSearchParameters = Object(mergeSearchParameters["a" /* default */])(actualState, new external_algoliasearch_helper_default.a.SearchParameters(searchParameters)); // Update original `widgetParams.searchParameters` to the new refined one

        widgetParams.searchParameters = searchParameters; // Trigger a search with the resolved search parameters

        helper.setState(nextSearchParameters).search();
      };
    }

    return {
      $$type: 'ais.configure',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectConfigure_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectConfigure_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      dispose: function dispose(_ref) {
        var state = _ref.state;
        unmountFn();
        return getInitialSearchParameters(state, widgetParams);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        var _renderState$configur;

        var widgetRenderState = this.getWidgetRenderState(renderOptions);
        return connectConfigure_objectSpread({}, renderState, {
          configure: connectConfigure_objectSpread({}, widgetRenderState, {
            widgetParams: connectConfigure_objectSpread({}, widgetRenderState.widgetParams, {
              searchParameters: Object(mergeSearchParameters["a" /* default */])(new external_algoliasearch_helper_default.a.SearchParameters((_renderState$configur = renderState.configure) === null || _renderState$configur === void 0 ? void 0 : _renderState$configur.widgetParams.searchParameters), new external_algoliasearch_helper_default.a.SearchParameters(widgetRenderState.widgetParams.searchParameters)).getQueryParams()
            })
          })
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref2) {
        var helper = _ref2.helper;

        if (!connectorState.refine) {
          connectorState.refine = refine(helper);
        }

        return {
          refine: connectorState.refine,
          widgetParams: widgetParams
        };
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(state, _ref3) {
        var uiState = _ref3.uiState;
        return Object(mergeSearchParameters["a" /* default */])(state, new external_algoliasearch_helper_default.a.SearchParameters(connectConfigure_objectSpread({}, uiState.configure, {}, widgetParams.searchParameters)));
      },
      getWidgetUiState: function getWidgetUiState(uiState) {
        return connectConfigure_objectSpread({}, uiState, {
          configure: connectConfigure_objectSpread({}, uiState.configure, {}, widgetParams.searchParameters)
        });
      }
    };
  };
};

/* harmony default export */ var configure_connectConfigure = (connectConfigure_connectConfigure);
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js
var getPropertyByPath = __webpack_require__(48);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/configure-related-items/connectConfigureRelatedItems.js
function connectConfigureRelatedItems_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectConfigureRelatedItems_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectConfigureRelatedItems_ownKeys(Object(source), true).forEach(function (key) {
        connectConfigureRelatedItems_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectConfigureRelatedItems_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectConfigureRelatedItems_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectConfigureRelatedItems_toConsumableArray(arr) {
  return connectConfigureRelatedItems_arrayWithoutHoles(arr) || connectConfigureRelatedItems_iterableToArray(arr) || connectConfigureRelatedItems_nonIterableSpread();
}

function connectConfigureRelatedItems_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectConfigureRelatedItems_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectConfigureRelatedItems_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}




var connectConfigureRelatedItems_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'configure-related-items',
  connector: true
});

function createOptionalFilter(_ref) {
  var attributeName = _ref.attributeName,
      attributeValue = _ref.attributeValue,
      attributeScore = _ref.attributeScore;
  return "".concat(attributeName, ":").concat(attributeValue, "<score=").concat(attributeScore || 1, ">");
}

var connectConfigureRelatedItems_connectConfigureRelatedItems = function connectConfigureRelatedItems(renderFn, unmountFn) {
  return function (widgetParams) {
    var _ref2 = widgetParams || {},
        hit = _ref2.hit,
        matchingPatterns = _ref2.matchingPatterns,
        _ref2$transformSearch = _ref2.transformSearchParameters,
        transformSearchParameters = _ref2$transformSearch === void 0 ? function (x) {
      return x;
    } : _ref2$transformSearch;

    if (!hit) {
      throw new Error(connectConfigureRelatedItems_withUsage('The `hit` option is required.'));
    }

    if (!matchingPatterns) {
      throw new Error(connectConfigureRelatedItems_withUsage('The `matchingPatterns` option is required.'));
    }

    var optionalFilters = Object.keys(matchingPatterns).reduce(function (acc, attributeName) {
      var attribute = matchingPatterns[attributeName];
      var attributeValue = Object(getPropertyByPath["a" /* default */])(hit, attributeName);
      var attributeScore = attribute.score;

      if (Array.isArray(attributeValue)) {
        return [].concat(connectConfigureRelatedItems_toConsumableArray(acc), [attributeValue.map(function (attributeSubValue) {
          return createOptionalFilter({
            attributeName: attributeName,
            attributeValue: attributeSubValue,
            attributeScore: attributeScore
          });
        })]);
      }

      if (typeof attributeValue === 'string') {
        return [].concat(connectConfigureRelatedItems_toConsumableArray(acc), [createOptionalFilter({
          attributeName: attributeName,
          attributeValue: attributeValue,
          attributeScore: attributeScore
        })]);
      }

       false ? undefined : void 0;
      return acc;
    }, []);

    var searchParameters = connectConfigureRelatedItems_objectSpread({}, transformSearchParameters(new external_algoliasearch_helper_default.a.SearchParameters({
      sumOrFiltersScores: true,
      facetFilters: ["objectID:-".concat(hit.objectID)],
      optionalFilters: optionalFilters
    })));

    var makeConfigure = configure_connectConfigure(renderFn, unmountFn);
    return connectConfigureRelatedItems_objectSpread({}, makeConfigure({
      searchParameters: searchParameters
    }), {
      $$type: 'ais.configureRelatedItems'
    });
  };
};

/* harmony default export */ var configure_related_items_connectConfigureRelatedItems = (connectConfigureRelatedItems_connectConfigureRelatedItems);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/autocomplete/connectAutocomplete.js
function connectAutocomplete_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectAutocomplete_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectAutocomplete_ownKeys(Object(source), true).forEach(function (key) {
        connectAutocomplete_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectAutocomplete_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectAutocomplete_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var connectAutocomplete_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'autocomplete',
  connector: true
});

var connectAutocomplete_connectAutocomplete = function connectAutocomplete(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectAutocomplete_withUsage());
  return function (widgetParams) {
    var _ref = widgetParams || {},
        _ref$escapeHTML = _ref.escapeHTML,
        escapeHTML = _ref$escapeHTML === void 0 ? true : _ref$escapeHTML;

     false ? undefined : void 0;
    var connectorState = {};
    return {
      $$type: 'ais.autocomplete',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectAutocomplete_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        var renderState = this.getWidgetRenderState(renderOptions);
        renderState.indices.forEach(function (_ref3) {
          var sendEvent = _ref3.sendEvent,
              hits = _ref3.hits;
          sendEvent('view', hits);
        });
        renderFn(connectAutocomplete_objectSpread({}, renderState, {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectAutocomplete_objectSpread({}, renderState, {
          autocomplete: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(_ref4) {
        var _this = this;

        var helper = _ref4.helper,
            scopedResults = _ref4.scopedResults,
            instantSearchInstance = _ref4.instantSearchInstance;

        if (!connectorState.refine) {
          connectorState.refine = function (query) {
            helper.setQuery(query).search();
          };
        }

        var indices = scopedResults.map(function (scopedResult) {
          // We need to escape the hits because highlighting
          // exposes HTML tags to the end-user.
          scopedResult.results.hits = escapeHTML ? Object(escape_highlight["c" /* default */])(scopedResult.results.hits) : scopedResult.results.hits;
          var sendEvent = Object(createSendEventForHits["b" /* createSendEventForHits */])({
            instantSearchInstance: instantSearchInstance,
            index: scopedResult.results.index,
            widgetType: _this.$$type
          });
          return {
            indexId: scopedResult.indexId,
            indexName: scopedResult.results.index,
            hits: scopedResult.results.hits,
            results: scopedResult.results,
            sendEvent: sendEvent
          };
        });
        return {
          currentRefinement: helper.state.query || '',
          indices: indices,
          refine: connectorState.refine,
          widgetParams: widgetParams
        };
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref5) {
        var searchParameters = _ref5.searchParameters;
        var query = searchParameters.query || '';

        if (query === '' || uiState && uiState.query === query) {
          return uiState;
        }

        return connectAutocomplete_objectSpread({}, uiState, {
          query: query
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref6) {
        var uiState = _ref6.uiState;
        var parameters = {
          query: uiState.query || ''
        };

        if (!escapeHTML) {
          return searchParameters.setQueryParameters(parameters);
        }

        return searchParameters.setQueryParameters(connectAutocomplete_objectSpread({}, parameters, {}, escape_highlight["a" /* TAG_PLACEHOLDER */]));
      },
      dispose: function dispose(_ref7) {
        var state = _ref7.state;
        unmountFn();
        var stateWithoutQuery = state.setQueryParameter('query', undefined);

        if (!escapeHTML) {
          return stateWithoutQuery;
        }

        return stateWithoutQuery.setQueryParameters(Object.keys(escape_highlight["a" /* TAG_PLACEHOLDER */]).reduce(function (acc, key) {
          return connectAutocomplete_objectSpread({}, acc, connectAutocomplete_defineProperty({}, key, undefined));
        }, {}));
      }
    };
  };
};

/* harmony default export */ var autocomplete_connectAutocomplete = (connectAutocomplete_connectAutocomplete);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/query-rules/connectQueryRules.js
function connectQueryRules_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectQueryRules_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectQueryRules_ownKeys(Object(source), true).forEach(function (key) {
        connectQueryRules_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectQueryRules_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectQueryRules_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function connectQueryRules_toConsumableArray(arr) {
  return connectQueryRules_arrayWithoutHoles(arr) || connectQueryRules_iterableToArray(arr) || connectQueryRules_nonIterableSpread();
}

function connectQueryRules_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function connectQueryRules_iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function connectQueryRules_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}


var connectQueryRules_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'query-rules',
  connector: true
});

function hasStateRefinements(state) {
  return [state.disjunctiveFacetsRefinements, state.facetsRefinements, state.hierarchicalFacetsRefinements, state.numericRefinements].some(function (refinement) {
    return Boolean(refinement && Object.keys(refinement).length > 0);
  });
} // A context rule must consist only of alphanumeric characters, hyphens, and underscores.
// See https://www.algolia.com/doc/guides/managing-results/refine-results/merchandising-and-promoting/in-depth/implementing-query-rules/#context


function escapeRuleContext(ruleName) {
  return ruleName.replace(/[^a-z0-9-_]+/gi, '_');
}

function getRuleContextsFromTrackedFilters(_ref) {
  var helper = _ref.helper,
      sharedHelperState = _ref.sharedHelperState,
      trackedFilters = _ref.trackedFilters;
  var ruleContexts = Object.keys(trackedFilters).reduce(function (facets, facetName) {
    var facetRefinements = Object(getRefinements["a" /* default */])( // An empty object is technically not a `SearchResults` but `getRefinements`
    // only accesses properties, meaning it will not throw with an empty object.
    helper.lastResults || {}, sharedHelperState).filter(function (refinement) {
      return refinement.attribute === facetName;
    }).map(function (refinement) {
      return refinement.numericValue || refinement.name;
    });
    var getTrackedFacetValues = trackedFilters[facetName];
    var trackedFacetValues = getTrackedFacetValues(facetRefinements);
    return [].concat(connectQueryRules_toConsumableArray(facets), connectQueryRules_toConsumableArray(facetRefinements.filter(function (facetRefinement) {
      return trackedFacetValues.includes(facetRefinement);
    }).map(function (facetValue) {
      return escapeRuleContext("ais-".concat(facetName, "-").concat(facetValue));
    })));
  }, []);
  return ruleContexts;
}

function applyRuleContexts(event) {
  var helper = this.helper,
      initialRuleContexts = this.initialRuleContexts,
      trackedFilters = this.trackedFilters,
      transformRuleContexts = this.transformRuleContexts;
  var sharedHelperState = event.state;
  var previousRuleContexts = sharedHelperState.ruleContexts || [];
  var newRuleContexts = getRuleContextsFromTrackedFilters({
    helper: helper,
    sharedHelperState: sharedHelperState,
    trackedFilters: trackedFilters
  });
  var nextRuleContexts = [].concat(connectQueryRules_toConsumableArray(initialRuleContexts), connectQueryRules_toConsumableArray(newRuleContexts));
   false ? undefined : void 0;
  var ruleContexts = transformRuleContexts(nextRuleContexts).slice(0, 10);

  if (!Object(isEqual["a" /* default */])(previousRuleContexts, ruleContexts)) {
    helper.overrideStateWithoutTriggeringChangeEvent(connectQueryRules_objectSpread({}, sharedHelperState, {
      ruleContexts: ruleContexts
    }));
  }
}

var connectQueryRules_connectQueryRules = function connectQueryRules(_render) {
  var unmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(_render, connectQueryRules_withUsage());
  return function (widgetParams) {
    var _ref2 = widgetParams || {},
        _ref2$trackedFilters = _ref2.trackedFilters,
        trackedFilters = _ref2$trackedFilters === void 0 ? {} : _ref2$trackedFilters,
        _ref2$transformRuleCo = _ref2.transformRuleContexts,
        transformRuleContexts = _ref2$transformRuleCo === void 0 ? function (rules) {
      return rules;
    } : _ref2$transformRuleCo,
        _ref2$transformItems = _ref2.transformItems,
        transformItems = _ref2$transformItems === void 0 ? function (items) {
      return items;
    } : _ref2$transformItems;

    Object.keys(trackedFilters).forEach(function (facetName) {
      if (typeof trackedFilters[facetName] !== 'function') {
        throw new Error(connectQueryRules_withUsage("'The \"".concat(facetName, "\" filter value in the `trackedFilters` option expects a function.")));
      }
    });
    var hasTrackedFilters = Object.keys(trackedFilters).length > 0; // We store the initial rule contexts applied before creating the widget
    // so that we do not override them with the rules created from `trackedFilters`.

    var initialRuleContexts = [];
    var onHelperChange;
    return {
      $$type: 'ais.queryRules',
      init: function init(initOptions) {
        var helper = initOptions.helper,
            state = initOptions.state,
            instantSearchInstance = initOptions.instantSearchInstance;
        initialRuleContexts = state.ruleContexts || [];
        onHelperChange = applyRuleContexts.bind({
          helper: helper,
          initialRuleContexts: initialRuleContexts,
          trackedFilters: trackedFilters,
          transformRuleContexts: transformRuleContexts
        });

        if (hasTrackedFilters) {
          // We need to apply the `ruleContexts` based on the `trackedFilters`
          // before the helper changes state in some cases:
          //   - Some filters are applied on the first load (e.g. using `configure`)
          //   - The `transformRuleContexts` option sets initial `ruleContexts`.
          if (hasStateRefinements(state) || Boolean(widgetParams.transformRuleContexts)) {
            onHelperChange({
              state: state
            });
          } // We track every change in the helper to override its state and add
          // any `ruleContexts` needed based on the `trackedFilters`.


          helper.on('change', onHelperChange);
        }

        _render(connectQueryRules_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;

        _render(connectQueryRules_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getWidgetRenderState: function getWidgetRenderState(_ref3) {
        var results = _ref3.results;

        var _ref4 = results || {},
            _ref4$userData = _ref4.userData,
            userData = _ref4$userData === void 0 ? [] : _ref4$userData;

        var items = transformItems(userData);
        return {
          items: items,
          widgetParams: widgetParams
        };
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectQueryRules_objectSpread({}, renderState, {
          queryRules: this.getWidgetRenderState(renderOptions)
        });
      },
      dispose: function dispose(_ref5) {
        var helper = _ref5.helper,
            state = _ref5.state;
        unmount();

        if (hasTrackedFilters) {
          helper.removeListener('change', onHelperChange);
          return state.setQueryParameter('ruleContexts', initialRuleContexts);
        }

        return state;
      }
    };
  };
};

/* harmony default export */ var query_rules_connectQueryRules = (connectQueryRules_connectQueryRules);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/voiceSearchHelper/index.js
function voiceSearchHelper_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function voiceSearchHelper_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      voiceSearchHelper_ownKeys(Object(source), true).forEach(function (key) {
        voiceSearchHelper_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      voiceSearchHelper_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function voiceSearchHelper_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var voiceSearchHelper_createVoiceSearchHelper = function createVoiceSearchHelper(_ref) {
  var searchAsYouSpeak = _ref.searchAsYouSpeak,
      language = _ref.language,
      onQueryChange = _ref.onQueryChange,
      onStateChange = _ref.onStateChange;
  var SpeechRecognitionAPI = window.webkitSpeechRecognition || window.SpeechRecognition;

  var getDefaultState = function getDefaultState(status) {
    return {
      status: status,
      transcript: '',
      isSpeechFinal: false,
      errorCode: undefined
    };
  };

  var state = getDefaultState('initial');
  var recognition;

  var isBrowserSupported = function isBrowserSupported() {
    return Boolean(SpeechRecognitionAPI);
  };

  var isListening = function isListening() {
    return state.status === 'askingPermission' || state.status === 'waiting' || state.status === 'recognizing';
  };

  var setState = function setState() {
    var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    state = voiceSearchHelper_objectSpread({}, state, {}, newState);
    onStateChange();
  };

  var getState = function getState() {
    return state;
  };

  var resetState = function resetState() {
    var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'initial';
    setState(getDefaultState(status));
  };

  var onStart = function onStart() {
    setState({
      status: 'waiting'
    });
  };

  var onError = function onError(event) {
    setState({
      status: 'error',
      errorCode: event.error
    });
  };

  var onResult = function onResult(event) {
    setState({
      status: 'recognizing',
      transcript: event.results[0] && event.results[0][0] && event.results[0][0].transcript || '',
      isSpeechFinal: event.results[0] && event.results[0].isFinal
    });

    if (searchAsYouSpeak && state.transcript) {
      onQueryChange(state.transcript);
    }
  };

  var onEnd = function onEnd() {
    if (!state.errorCode && state.transcript && !searchAsYouSpeak) {
      onQueryChange(state.transcript);
    }

    if (state.status !== 'error') {
      setState({
        status: 'finished'
      });
    }
  };

  var startListening = function startListening() {
    recognition = new SpeechRecognitionAPI();

    if (!recognition) {
      return;
    }

    resetState('askingPermission');
    recognition.interimResults = true;

    if (language) {
      recognition.lang = language;
    }

    recognition.addEventListener('start', onStart);
    recognition.addEventListener('error', onError);
    recognition.addEventListener('result', onResult);
    recognition.addEventListener('end', onEnd);
    recognition.start();
  };

  var dispose = function dispose() {
    if (!recognition) {
      return;
    }

    recognition.stop();
    recognition.removeEventListener('start', onStart);
    recognition.removeEventListener('error', onError);
    recognition.removeEventListener('result', onResult);
    recognition.removeEventListener('end', onEnd);
    recognition = undefined;
  };

  var stopListening = function stopListening() {
    dispose(); // Because `dispose` removes event listeners, `end` listener is not called.
    // So we're setting the `status` as `finished` here.
    // If we don't do it, it will be still `waiting` or `recognizing`.

    resetState('finished');
  };

  return {
    getState: getState,
    isBrowserSupported: isBrowserSupported,
    isListening: isListening,
    startListening: startListening,
    stopListening: stopListening,
    dispose: dispose
  };
};

/* harmony default export */ var voiceSearchHelper = (voiceSearchHelper_createVoiceSearchHelper);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/voice-search/connectVoiceSearch.js
function connectVoiceSearch_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function connectVoiceSearch_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      connectVoiceSearch_ownKeys(Object(source), true).forEach(function (key) {
        connectVoiceSearch_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      connectVoiceSearch_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function connectVoiceSearch_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var connectVoiceSearch_withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'voice-search',
  connector: true
});

var connectVoiceSearch_connectVoiceSearch = function connectVoiceSearch(renderFn) {
  var unmountFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop["a" /* default */];
  Object(checkRendering["a" /* default */])(renderFn, connectVoiceSearch_withUsage());
  return function (widgetParams) {
    var _widgetParams$searchA = widgetParams.searchAsYouSpeak,
        searchAsYouSpeak = _widgetParams$searchA === void 0 ? false : _widgetParams$searchA,
        language = widgetParams.language,
        additionalQueryParameters = widgetParams.additionalQueryParameters,
        _widgetParams$createV = widgetParams.createVoiceSearchHelper,
        createVoiceSearchHelper = _widgetParams$createV === void 0 ? voiceSearchHelper : _widgetParams$createV;
    return {
      $$type: 'ais.voiceSearch',
      init: function init(initOptions) {
        var instantSearchInstance = initOptions.instantSearchInstance;
        renderFn(connectVoiceSearch_objectSpread({}, this.getWidgetRenderState(initOptions), {
          instantSearchInstance: instantSearchInstance
        }), true);
      },
      render: function render(renderOptions) {
        var instantSearchInstance = renderOptions.instantSearchInstance;
        renderFn(connectVoiceSearch_objectSpread({}, this.getWidgetRenderState(renderOptions), {
          instantSearchInstance: instantSearchInstance
        }), false);
      },
      getRenderState: function getRenderState(renderState, renderOptions) {
        return connectVoiceSearch_objectSpread({}, renderState, {
          voiceSearch: this.getWidgetRenderState(renderOptions)
        });
      },
      getWidgetRenderState: function getWidgetRenderState(renderOptions) {
        var _this = this;

        var helper = renderOptions.helper,
            instantSearchInstance = renderOptions.instantSearchInstance;

        if (!this._refine) {
          this._refine = function (query) {
            if (query !== helper.state.query) {
              var queryLanguages = language ? [language.split('-')[0]] : undefined;
              helper.setQueryParameter('queryLanguages', queryLanguages);

              if (typeof additionalQueryParameters === 'function') {
                helper.setState(helper.state.setQueryParameters(connectVoiceSearch_objectSpread({
                  ignorePlurals: true,
                  removeStopWords: true,
                  // @ts-ignore (optionalWords only allows array, while string is also valid)
                  optionalWords: query
                }, additionalQueryParameters({
                  query: query
                }))));
              }

              helper.setQuery(query).search();
            }
          };
        }

        if (!this._voiceSearchHelper) {
          this._voiceSearchHelper = createVoiceSearchHelper({
            searchAsYouSpeak: searchAsYouSpeak,
            language: language,
            onQueryChange: function onQueryChange(query) {
              return _this._refine(query);
            },
            onStateChange: function onStateChange() {
              renderFn(connectVoiceSearch_objectSpread({}, _this.getWidgetRenderState(renderOptions), {
                instantSearchInstance: instantSearchInstance
              }), false);
            }
          });
        }

        var _voiceSearchHelper = this._voiceSearchHelper,
            isBrowserSupported = _voiceSearchHelper.isBrowserSupported,
            isListening = _voiceSearchHelper.isListening,
            startListening = _voiceSearchHelper.startListening,
            stopListening = _voiceSearchHelper.stopListening,
            getState = _voiceSearchHelper.getState;
        return {
          isBrowserSupported: isBrowserSupported(),
          isListening: isListening(),
          toggleListening: function toggleListening() {
            if (!isBrowserSupported()) {
              return;
            }

            if (isListening()) {
              stopListening();
            } else {
              startListening();
            }
          },
          voiceListeningState: getState(),
          widgetParams: widgetParams
        };
      },
      dispose: function dispose(_ref) {
        var state = _ref.state;

        this._voiceSearchHelper.dispose();

        unmountFn();
        var newState = state;

        if (typeof additionalQueryParameters === 'function') {
          var additional = additionalQueryParameters({
            query: ''
          });
          var toReset = additional ? Object.keys(additional).reduce(function (acc, current) {
            acc[current] = undefined;
            return acc;
          }, {}) : {};
          newState = state.setQueryParameters(connectVoiceSearch_objectSpread({
            // @ts-ignore (queryLanguages is not yet added to algoliasearch)
            queryLanguages: undefined,
            ignorePlurals: undefined,
            removeStopWords: undefined,
            optionalWords: undefined
          }, toReset));
        }

        return newState.setQueryParameter('query', undefined);
      },
      getWidgetUiState: function getWidgetUiState(uiState, _ref2) {
        var searchParameters = _ref2.searchParameters;
        var query = searchParameters.query || '';

        if (!query) {
          return uiState;
        }

        return connectVoiceSearch_objectSpread({}, uiState, {
          query: query
        });
      },
      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref3) {
        var uiState = _ref3.uiState;
        return searchParameters.setQueryParameter('query', uiState.query || '');
      }
    };
  };
};

/* harmony default export */ var voice_search_connectVoiceSearch = (connectVoiceSearch_connectVoiceSearch);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/connectors/index.js



























/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "querystring"
var external_querystring_ = __webpack_require__(53);

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(0);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// EXTERNAL MODULE: external "@nuxt/ufo"
var ufo_ = __webpack_require__(5);

// EXTERNAL MODULE: external "node-fetch"
var external_node_fetch_ = __webpack_require__(54);
var external_node_fetch_default = /*#__PURE__*/__webpack_require__.n(external_node_fetch_);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/middleware.js
const middleware = {};
/* harmony default export */ var nuxt_middleware = (middleware);
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/utils.js

 // window.{{globals.loadedCallback}} hook
// Useful for jsdom testing or plugins (https://github.com/tmpvar/jsdom#dealing-with-asynchronous-script-loading)

if (false) {}

function empty() {}
function globalHandleError(error) {
  if (external_vue_default.a.config.errorHandler) {
    external_vue_default.a.config.errorHandler(error);
  }
}
function interopDefault(promise) {
  return promise.then(m => m.default || m);
}
function hasFetch(vm) {
  return vm.$options && typeof vm.$options.fetch === 'function' && !vm.$options.fetch.length;
}
function purifyData(data) {
  if (true) {
    return data;
  }

  return Object.entries(data).filter(([key, value]) => {
    const valid = !(value instanceof Function) && !(value instanceof Promise);

    if (!valid) {
      console.warn(`${key} is not able to be stringified. This will break in a production environment.`);
    }

    return valid;
  }).reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});
}
function getChildrenComponentInstancesUsingFetch(vm, instances = []) {
  const children = vm.$children || [];

  for (const child of children) {
    if (child.$fetch) {
      instances.push(child);
      continue; // Don't get the children since it will reload the template
    }

    if (child.$children) {
      getChildrenComponentInstancesUsingFetch(child, instances);
    }
  }

  return instances;
}
function applyAsyncData(Component, asyncData) {
  if ( // For SSR, we once all this function without second param to just apply asyncData
  // Prevent doing this for each SSR request
  !asyncData && Component.options.__hasNuxtData) {
    return;
  }

  const ComponentData = Component.options._originDataFn || Component.options.data || function () {
    return {};
  };

  Component.options._originDataFn = ComponentData;

  Component.options.data = function () {
    const data = ComponentData.call(this, this);

    if (this.$ssrContext) {
      asyncData = this.$ssrContext.asyncData[Component.cid];
    }

    return { ...data,
      ...asyncData
    };
  };

  Component.options.__hasNuxtData = true;

  if (Component._Ctor && Component._Ctor.options) {
    Component._Ctor.options.data = Component.options.data;
  }
}
function sanitizeComponent(Component) {
  // If Component already sanitized
  if (Component.options && Component._Ctor === Component) {
    return Component;
  }

  if (!Component.options) {
    Component = external_vue_default.a.extend(Component); // fix issue #6

    Component._Ctor = Component;
  } else {
    Component._Ctor = Component;
    Component.extendOptions = Component.options;
  } // If no component name defined, set file path as name, (also fixes #5703)


  if (!Component.options.name && Component.options.__file) {
    Component.options.name = Component.options.__file;
  }

  return Component;
}
function getMatchedComponents(route, matches = false, prop = 'components') {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m[prop]).map(key => {
      matches && matches.push(index);
      return m[prop][key];
    });
  }));
}
function getMatchedComponentsInstances(route, matches = false) {
  return getMatchedComponents(route, matches, 'instances');
}
function flatMapComponents(route, fn) {
  return Array.prototype.concat.apply([], route.matched.map((m, index) => {
    return Object.keys(m.components).reduce((promises, key) => {
      if (m.components[key]) {
        promises.push(fn(m.components[key], m.instances[key], m, key, index));
      } else {
        delete m.components[key];
      }

      return promises;
    }, []);
  }));
}
function resolveRouteComponents(route, fn) {
  return Promise.all(flatMapComponents(route, async (Component, instance, match, key) => {
    // If component is a function, resolve it
    if (typeof Component === 'function' && !Component.options) {
      Component = await Component();
    }

    match.components[key] = Component = sanitizeComponent(Component);
    return typeof fn === 'function' ? fn(Component, instance, match, key) : Component;
  }));
}
async function getRouteData(route) {
  if (!route) {
    return;
  } // Make sure the components are resolved (code-splitting)


  await resolveRouteComponents(route); // Send back a copy of route with meta based on Component definition

  return { ...route,
    meta: getMatchedComponents(route).map((Component, index) => {
      return { ...Component.options.meta,
        ...(route.matched[index] || {}).meta
      };
    })
  };
}
async function setContext(app, context) {
  // If context not defined, create it
  if (!app.context) {
    app.context = {
      isStatic: true,
      isDev: false,
      isHMR: false,
      app,
      payload: context.payload,
      error: context.error,
      base: '/',
      env: {}
    }; // Only set once

    if (false) {}

    if (false) {}

    if (context.ssrContext) {
      app.context.ssrContext = context.ssrContext;
    }

    app.context.redirect = (status, path, query) => {
      if (!status) {
        return;
      }

      app.context._redirected = true; // if only 1 or 2 arguments: redirect('/') or redirect('/', { foo: 'bar' })

      let pathType = typeof path;

      if (typeof status !== 'number' && (pathType === 'undefined' || pathType === 'object')) {
        query = path || {};
        path = status;
        pathType = typeof path;
        status = 302;
      }

      if (pathType === 'object') {
        path = app.router.resolve(path).route.fullPath;
      } // "/absolute/route", "./relative/route" or "../relative/route"


      if (/(^[.]{1,2}\/)|(^\/(?!\/))/.test(path)) {
        app.context.next({
          path,
          query,
          status
        });
      } else {
        path = formatUrl(path, query);

        if (true) {
          app.context.next({
            path,
            status
          });
        }

        if (false) {}
      }
    };

    if (true) {
      app.context.beforeNuxtRender = fn => context.beforeRenderFns.push(fn);
    }

    if (false) {}
  } // Dynamic keys


  const [currentRouteData, fromRouteData] = await Promise.all([getRouteData(context.route), getRouteData(context.from)]);

  if (context.route) {
    app.context.route = currentRouteData;
  }

  if (context.from) {
    app.context.from = fromRouteData;
  }

  app.context.next = context.next;
  app.context._redirected = false;
  app.context._errored = false;
  app.context.isHMR = false;
  app.context.params = app.context.route.params || {};
  app.context.query = app.context.route.query || {};
}
function middlewareSeries(promises, appContext) {
  if (!promises.length || appContext._redirected || appContext._errored) {
    return Promise.resolve();
  }

  return promisify(promises[0], appContext).then(() => {
    return middlewareSeries(promises.slice(1), appContext);
  });
}
function promisify(fn, context) {
  let promise;

  if (fn.length === 2) {
    // fn(context, callback)
    promise = new Promise(resolve => {
      fn(context, function (err, data) {
        if (err) {
          context.error(err);
        }

        data = data || {};
        resolve(data);
      });
    });
  } else {
    promise = fn(context);
  }

  if (promise && promise instanceof Promise && typeof promise.then === 'function') {
    return promise;
  }

  return Promise.resolve(promise);
} // Imported from vue-router

function getLocation(base, mode) {
  if (mode === 'hash') {
    return window.location.hash.replace(/^#\//, '');
  }

  base = decodeURI(base).slice(0, -1); // consideration is base is normalized with trailing slash

  let path = decodeURI(window.location.pathname);

  if (base && path.startsWith(base)) {
    path = path.slice(base.length);
  }

  const fullPath = (path || '/') + window.location.search + window.location.hash;
  return Object(ufo_["normalizeURL"])(fullPath);
} // Imported from path-to-regexp

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */

function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function getQueryDiff(toQuery, fromQuery) {
  const diff = {};
  const queries = { ...toQuery,
    ...fromQuery
  };

  for (const k in queries) {
    if (String(toQuery[k]) !== String(fromQuery[k])) {
      diff[k] = true;
    }
  }

  return diff;
}
function normalizeError(err) {
  let message;

  if (!(err.message || typeof err === 'string')) {
    try {
      message = JSON.stringify(err, null, 2);
    } catch (e) {
      message = `[${err.constructor.name}]`;
    }
  } else {
    message = err.message || err;
  }

  return { ...err,
    message,
    statusCode: err.statusCode || err.status || err.response && err.response.status || 500
  };
}
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

const PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  const tokens = [];
  let key = 0;
  let index = 0;
  let path = '';
  const defaultDelimiter = options && options.delimiter || '/';
  let res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    const m = res[0];
    const escaped = res[1];
    const offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    const next = str[index];
    const prefix = res[2];
    const name = res[3];
    const capture = res[4];
    const group = res[5];
    const modifier = res[6];
    const asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    const partial = prefix != null && next != null && next !== prefix;
    const repeat = modifier === '+' || modifier === '*';
    const optional = modifier === '?' || modifier === '*';
    const delimiter = res[2] || defaultDelimiter;
    const pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: Boolean(asterisk),
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str, slashAllowed) {
  const re = slashAllowed ? /[?#]/g : /[/?#]/g;
  return encodeURI(str).replace(re, c => {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURIComponentPretty(str, true);
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$/()])/g, '\\$1');
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens, options) {
  // Compile all the tokens into regexps.
  const matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (let i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    let path = '';
    const data = obj || {};
    const options = opts || {};
    const encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      const value = data[token.name || 'pathMatch'];
      let segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (let j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options && options.sensitive ? '' : 'i';
}
/**
 * Format given url, append query to url query string
 *
 * @param  {string} url
 * @param  {string} query
 * @return {string}
 */


function formatUrl(url, query) {
  let protocol;
  const index = url.indexOf('://');

  if (index !== -1) {
    protocol = url.substring(0, index);
    url = url.substring(index + 3);
  } else if (url.startsWith('//')) {
    url = url.substring(2);
  }

  let parts = url.split('/');
  let result = (protocol ? protocol + '://' : '//') + parts.shift();
  let path = parts.join('/');

  if (path === '' && parts.length === 1) {
    result += '/';
  }

  let hash;
  parts = path.split('#');

  if (parts.length === 2) {
    [path, hash] = parts;
  }

  result += path ? '/' + path : '';

  if (query && JSON.stringify(query) !== '{}') {
    result += (url.split('?').length === 2 ? '&' : '?') + formatQuery(query);
  }

  result += hash ? '#' + hash : '';
  return result;
}
/**
 * Transform data object to query string
 *
 * @param  {object} query
 * @return {string}
 */


function formatQuery(query) {
  return Object.keys(query).sort().map(key => {
    const val = query[key];

    if (val == null) {
      return '';
    }

    if (Array.isArray(val)) {
      return val.slice().map(val2 => [key, '=', val2].join('')).join('&');
    }

    return key + '=' + val;
  }).filter(Boolean).join('&');
}

function addLifecycleHook(vm, hook, fn) {
  if (!vm.$options[hook]) {
    vm.$options[hook] = [];
  }

  if (!vm.$options[hook].includes(fn)) {
    vm.$options[hook].push(fn);
  }
}
function urlJoin() {
  return [].slice.call(arguments).join('/').replace(/\/+/g, '/').replace(':/', '://');
}
function stripTrailingSlash(path) {
  return path.replace(/\/+$/, '') || '/';
}
function isSamePath(p1, p2) {
  return stripTrailingSlash(p1) === stripTrailingSlash(p2);
}
function setScrollRestoration(newVal) {
  try {
    window.history.scrollRestoration = newVal;
  } catch (e) {}
}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/mixins/fetch.server.js



async function serverPrefetch() {
  if (!this._fetchOnServer) {
    return;
  } // Call and await on $fetch


  try {
    await this.$options.fetch.call(this);
  } catch (err) {
    if (false) {}

    this.$fetchState.error = normalizeError(err);
  }

  this.$fetchState.pending = false; // Define an ssrKey for hydration

  this._fetchKey = this.$ssrContext.nuxt.fetch.length; // Add data-fetch-key on parent element of Component

  const attrs = this.$vnode.data.attrs = this.$vnode.data.attrs || {};
  attrs['data-fetch-key'] = this._fetchKey; // Add to ssrContext for window.__NUXT__.fetch

  this.$ssrContext.nuxt.fetch.push(this.$fetchState.error ? {
    _error: this.$fetchState.error
  } : purifyData(this._data));
}

/* harmony default export */ var fetch_server = ({
  created() {
    if (!hasFetch(this)) {
      return;
    }

    if (typeof this.$options.fetchOnServer === 'function') {
      this._fetchOnServer = this.$options.fetchOnServer.call(this) !== false;
    } else {
      this._fetchOnServer = this.$options.fetchOnServer !== false;
    } // Added for remove vue undefined warning while ssr


    this.$fetch = () => {}; // issue #8043


    external_vue_default.a.util.defineReactive(this, '$fetchState', {
      pending: true,
      error: null,
      timestamp: Date.now()
    });
    addLifecycleHook(this, 'serverPrefetch', serverPrefetch);
  }

});
// EXTERNAL MODULE: external "vue-meta"
var external_vue_meta_ = __webpack_require__(55);
var external_vue_meta_default = /*#__PURE__*/__webpack_require__.n(external_vue_meta_);

// EXTERNAL MODULE: external "vue-client-only"
var external_vue_client_only_ = __webpack_require__(28);
var external_vue_client_only_default = /*#__PURE__*/__webpack_require__.n(external_vue_client_only_);

// EXTERNAL MODULE: external "vue-no-ssr"
var external_vue_no_ssr_ = __webpack_require__(20);
var external_vue_no_ssr_default = /*#__PURE__*/__webpack_require__.n(external_vue_no_ssr_);

// EXTERNAL MODULE: external "vue-router"
var external_vue_router_ = __webpack_require__(11);
var external_vue_router_default = /*#__PURE__*/__webpack_require__.n(external_vue_router_);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.scrollBehavior.js


if (false) {}

/* harmony default export */ var router_scrollBehavior = (function (to, from, savedPosition) {
  // If the returned position is falsy or an empty object, will retain current scroll position
  let position = false;
  const Pages = getMatchedComponents(to); // Scroll to the top of the page if...

  if ( // One of the children set `scrollToTop`
  Pages.some(Page => Page.options.scrollToTop) || // scrollToTop set in only page without children
  Pages.length < 2 && Pages.every(Page => Page.options.scrollToTop !== false)) {
    position = {
      x: 0,
      y: 0
    };
  } // savedPosition is only available for popstate navigations (back button)


  if (savedPosition) {
    position = savedPosition;
  }

  const nuxt = window.$nuxt;

  if ( // Route hash changes
  to.path === from.path && to.hash !== from.hash || // Initial load (vuejs/vue-router#3199)
  to === from) {
    nuxt.$nextTick(() => nuxt.$emit('triggerScroll'));
  }

  return new Promise(resolve => {
    // wait for the out transition to complete (if necessary)
    nuxt.$once('triggerScroll', () => {
      // coords will be used if no selector is provided,
      // or if the selector didn't match any element.
      if (to.hash) {
        let hash = to.hash; // CSS.escape() is not supported with IE and Edge.

        if (typeof window.CSS !== 'undefined' && typeof window.CSS.escape !== 'undefined') {
          hash = '#' + window.CSS.escape(hash.substr(1));
        }

        try {
          if (document.querySelector(hash)) {
            // scroll to anchor by returning the selector
            position = {
              selector: hash
            };
          }
        } catch (e) {
          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).');
        }
      }

      resolve(position);
    });
  });
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/router.js






const _27544c62 = () => interopDefault(__webpack_require__.e(/* import() | pages/index */ 4).then(__webpack_require__.bind(null, 91)));

const _259dab1a = () => interopDefault(__webpack_require__.e(/* import() | pages/_slug */ 3).then(__webpack_require__.bind(null, 92))); // TODO: remove in Nuxt 3


const emptyFn = () => {};

const originalPush = external_vue_router_default.a.prototype.push;

external_vue_router_default.a.prototype.push = function push(location, onComplete = emptyFn, onAbort) {
  return originalPush.call(this, location, onComplete, onAbort);
};

external_vue_default.a.use(external_vue_router_default.a);
const routerOptions = {
  mode: 'history',
  base: '/',
  linkActiveClass: 'nuxt-link-active',
  linkExactActiveClass: 'nuxt-link-exact-active',
  scrollBehavior: router_scrollBehavior,
  routes: [{
    path: "/",
    component: _27544c62,
    name: "index"
  }, {
    path: "/:slug",
    component: _259dab1a,
    name: "slug"
  }],
  fallback: false
};

function decodeObj(obj) {
  for (const key in obj) {
    if (typeof obj[key] === 'string') {
      obj[key] = Object(ufo_["decode"])(obj[key]);
    }
  }
}

function createRouter() {
  const router = new external_vue_router_default.a(routerOptions);
  const resolve = router.resolve.bind(router);

  router.resolve = (to, current, append) => {
    if (typeof to === 'string') {
      to = Object(ufo_["normalizeURL"])(to);
    }

    const r = resolve(to, current, append);

    if (r && r.resolved && r.resolved.query) {
      decodeObj(r.resolved.query);
    }

    return r;
  };

  return router;
}
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-child.js
/* harmony default export */ var nuxt_child = ({
  name: 'NuxtChild',
  functional: true,
  props: {
    nuxtChildKey: {
      type: String,
      default: ''
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    }
  },

  render(_, {
    parent,
    data,
    props
  }) {
    const h = parent.$createElement;
    data.nuxtChild = true;
    const _parent = parent;
    const transitions = parent.$nuxt.nuxt.transitions;
    const defaultTransition = parent.$nuxt.nuxt.defaultTransition;
    let depth = 0;

    while (parent) {
      if (parent.$vnode && parent.$vnode.data.nuxtChild) {
        depth++;
      }

      parent = parent.$parent;
    }

    data.nuxtChildDepth = depth;
    const transition = transitions[depth] || defaultTransition;
    const transitionProps = {};
    transitionsKeys.forEach(key => {
      if (typeof transition[key] !== 'undefined') {
        transitionProps[key] = transition[key];
      }
    });
    const listeners = {};
    listenersKeys.forEach(key => {
      if (typeof transition[key] === 'function') {
        listeners[key] = transition[key].bind(_parent);
      }
    });

    if (false) {} // make sure that leave is called asynchronous (fix #5703)


    if (transition.css === false) {
      const leave = listeners.leave; // only add leave listener when user didnt provide one
      // or when it misses the done argument

      if (!leave || leave.length < 2) {
        listeners.leave = (el, done) => {
          if (leave) {
            leave.call(_parent, el);
          }

          _parent.$nextTick(done);
        };
      }
    }

    let routerView = h('routerView', data);

    if (props.keepAlive) {
      routerView = h('keep-alive', {
        props: props.keepAliveProps
      }, [routerView]);
    }

    return h('transition', {
      props: transitionProps,
      on: listeners
    }, [routerView]);
  }

});
const transitionsKeys = ['name', 'mode', 'appear', 'css', 'type', 'duration', 'enterClass', 'leaveClass', 'appearClass', 'enterActiveClass', 'enterActiveClass', 'leaveActiveClass', 'appearActiveClass', 'enterToClass', 'leaveToClass', 'appearToClass'];
const listenersKeys = ['beforeEnter', 'enter', 'afterEnter', 'enterCancelled', 'beforeLeave', 'leave', 'afterLeave', 'leaveCancelled', 'beforeAppear', 'appear', 'afterAppear', 'appearCancelled'];
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"__nuxt-error-page"},[_vm._ssrNode("<div class=\"error\">","</div>",[_vm._ssrNode("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"90\" height=\"90\" fill=\"#DBE1EC\" viewBox=\"0 0 48 48\"><path d=\"M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z\"></path></svg> <div class=\"title\">"+_vm._ssrEscape(_vm._s(_vm.message))+"</div> "),(_vm.statusCode === 404)?_vm._ssrNode("<p class=\"description\">","</p>",[(typeof _vm.$route === 'undefined')?_vm._ssrNode("<a href=\"/\" class=\"error-link\">","</a>"):_c('NuxtLink',{staticClass:"error-link",attrs:{"to":"/"}},[_vm._v("Back to the home page")])],1):_vm._e(),_vm._ssrNode(" <div class=\"logo\"><a href=\"https://nuxtjs.org\" target=\"_blank\" rel=\"noopener\">Nuxt</a></div>")],2)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=template&id=608a1420&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var nuxt_errorvue_type_script_lang_js_ = ({
  name: 'NuxtError',
  props: {
    error: {
      type: Object,
      default: null
    }
  },
  computed: {
    statusCode() {
      return this.error && this.error.statusCode || 500;
    },

    message() {
      return this.error.message || 'Error';
    }

  },

  head() {
    return {
      title: this.message,
      meta: [{
        name: 'viewport',
        content: 'width=device-width,initial-scale=1.0,minimum-scale=1.0'
      }]
    };
  }

});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_errorvue_type_script_lang_js_ = (nuxt_errorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-error.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(62)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_error_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_errorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  null,
  "5bce1087"
  
)

/* harmony default export */ var nuxt_error = (nuxt_error_component.exports);
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt.js




/* harmony default export */ var components_nuxt = ({
  name: 'Nuxt',
  components: {
    NuxtChild: nuxt_child,
    NuxtError: nuxt_error
  },
  props: {
    nuxtChildKey: {
      type: String,
      default: undefined
    },
    keepAlive: Boolean,
    keepAliveProps: {
      type: Object,
      default: undefined
    },
    name: {
      type: String,
      default: 'default'
    }
  },

  errorCaptured(error) {
    // if we receive and error while showing the NuxtError component
    // capture the error and force an immediate update so we re-render
    // without the NuxtError component
    if (this.displayingNuxtError) {
      this.errorFromNuxtError = error;
      this.$forceUpdate();
    }
  },

  computed: {
    routerViewKey() {
      // If nuxtChildKey prop is given or current route has children
      if (typeof this.nuxtChildKey !== 'undefined' || this.$route.matched.length > 1) {
        return this.nuxtChildKey || compile(this.$route.matched[0].path)(this.$route.params);
      }

      const [matchedRoute] = this.$route.matched;

      if (!matchedRoute) {
        return this.$route.path;
      }

      const Component = matchedRoute.components.default;

      if (Component && Component.options) {
        const {
          options
        } = Component;

        if (options.key) {
          return typeof options.key === 'function' ? options.key(this.$route) : options.key;
        }
      }

      const strict = /\/$/.test(matchedRoute.path);
      return strict ? this.$route.path : this.$route.path.replace(/\/$/, '');
    }

  },

  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$root.$options.nuxt);
  },

  render(h) {
    // if there is no error
    if (!this.nuxt.err) {
      // Directly return nuxt child
      return h('NuxtChild', {
        key: this.routerViewKey,
        props: this.$props
      });
    } // if an error occurred within NuxtError show a simple
    // error message instead to prevent looping


    if (this.errorFromNuxtError) {
      this.$nextTick(() => this.errorFromNuxtError = false);
      return h('div', {}, [h('h2', 'An error occurred while showing the error page'), h('p', 'Unfortunately an error occurred and while showing the error page another error occurred'), h('p', `Error details: ${this.errorFromNuxtError.toString()}`), h('nuxt-link', {
        props: {
          to: '/'
        }
      }, 'Go back to home')]);
    } // track if we are showing the NuxtError component


    this.displayingNuxtError = true;
    this.$nextTick(() => this.displayingNuxtError = false);
    return h(nuxt_error, {
      props: {
        error: this.nuxt.err
      }
    });
  }

});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
/* harmony default export */ var nuxt_loadingvue_type_script_lang_js_ = ({
  name: 'NuxtLoading',

  data() {
    return {
      percent: 0,
      show: false,
      canSucceed: true,
      reversed: false,
      skipTimerCount: 0,
      rtl: false,
      throttle: 200,
      duration: 5000,
      continuous: false
    };
  },

  computed: {
    left() {
      if (!this.continuous && !this.rtl) {
        return false;
      }

      return this.rtl ? this.reversed ? '0px' : 'auto' : !this.reversed ? '0px' : 'auto';
    }

  },

  beforeDestroy() {
    this.clear();
  },

  methods: {
    clear() {
      clearInterval(this._timer);
      clearTimeout(this._throttle);
      this._timer = null;
    },

    start() {
      this.clear();
      this.percent = 0;
      this.reversed = false;
      this.skipTimerCount = 0;
      this.canSucceed = true;

      if (this.throttle) {
        this._throttle = setTimeout(() => this.startTimer(), this.throttle);
      } else {
        this.startTimer();
      }

      return this;
    },

    set(num) {
      this.show = true;
      this.canSucceed = true;
      this.percent = Math.min(100, Math.max(0, Math.floor(num)));
      return this;
    },

    get() {
      return this.percent;
    },

    increase(num) {
      this.percent = Math.min(100, Math.floor(this.percent + num));
      return this;
    },

    decrease(num) {
      this.percent = Math.max(0, Math.floor(this.percent - num));
      return this;
    },

    pause() {
      clearInterval(this._timer);
      return this;
    },

    resume() {
      this.startTimer();
      return this;
    },

    finish() {
      this.percent = this.reversed ? 0 : 100;
      this.hide();
      return this;
    },

    hide() {
      this.clear();
      setTimeout(() => {
        this.show = false;
        this.$nextTick(() => {
          this.percent = 0;
          this.reversed = false;
        });
      }, 500);
      return this;
    },

    fail(error) {
      this.canSucceed = false;
      return this;
    },

    startTimer() {
      if (!this.show) {
        this.show = true;
      }

      if (typeof this._cut === 'undefined') {
        this._cut = 10000 / Math.floor(this.duration);
      }

      this._timer = setInterval(() => {
        /**
         * When reversing direction skip one timers
         * so 0, 100 are displayed for two iterations
         * also disable css width transitioning
         * which otherwise interferes and shows
         * a jojo effect
         */
        if (this.skipTimerCount > 0) {
          this.skipTimerCount--;
          return;
        }

        if (this.reversed) {
          this.decrease(this._cut);
        } else {
          this.increase(this._cut);
        }

        if (this.continuous) {
          if (this.percent >= 100) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          } else if (this.percent <= 0) {
            this.skipTimerCount = 1;
            this.reversed = !this.reversed;
          }
        }
      }, 100);
    }

  },

  render(h) {
    let el = h(false);

    if (this.show) {
      el = h('div', {
        staticClass: 'nuxt-progress',
        class: {
          'nuxt-progress-notransition': this.skipTimerCount > 0,
          'nuxt-progress-failed': !this.canSucceed
        },
        style: {
          width: this.percent + '%',
          left: this.left
        }
      });
    }

    return el;
  }

});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_nuxt_loadingvue_type_script_lang_js_ = (nuxt_loadingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-loading.vue
var nuxt_loading_render, nuxt_loading_staticRenderFns


function nuxt_loading_injectStyles (context) {
  
  var style0 = __webpack_require__(64)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var nuxt_loading_component = Object(componentNormalizer["a" /* default */])(
  components_nuxt_loadingvue_type_script_lang_js_,
  nuxt_loading_render,
  nuxt_loading_staticRenderFns,
  false,
  nuxt_loading_injectStyles,
  null,
  "16e307fb"
  
)

/* harmony default export */ var nuxt_loading = (nuxt_loading_component.exports);
// EXTERNAL MODULE: ./node_modules/@nuxtjs/tailwindcss/lib/files/tailwind.css
var tailwind = __webpack_require__(66);

// EXTERNAL MODULE: ./assets/main.css
var main = __webpack_require__(68);

// EXTERNAL MODULE: ./node_modules/prismjs/themes/prism.css
var prism = __webpack_require__(70);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=template&id=593afc66&
var defaultvue_type_template_id_593afc66_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"max-w-3xl mx-auto"},[_c('transition',{attrs:{"enter-active-class":"transition-opacity ease-linear duration-300","enter-class":"opacity-0","enter-to-class":"opacity-100","leave-active-class":"transition-opacity ease-linear duration-300","leave-class":"opacity-100","leave-to-class":"opacity-0"}},[_c('MobileMenu',{directives:[{name:"show",rawName:"v-show",value:(_vm.showMobileMenu),expression:"showMobileMenu"}],on:{"closeMobileMenu":function($event){_vm.showMobileMenu = false}}})],1),_vm._ssrNode(" "),_c('MainHeader',{directives:[{name:"show",rawName:"v-show",value:(!_vm.showMobileMenu),expression:"!showMobileMenu"}],on:{"showMobileMenu":function($event){_vm.showMobileMenu = true}}}),_vm._ssrNode(" "),_vm._ssrNode("<div class=\" flex\">","</div>",[_c('Nuxt',{staticClass:"px-6"})],1),_vm._ssrNode(" "),_c('MainFooter')],2)}
var defaultvue_type_template_id_593afc66_staticRenderFns = []


// CONCATENATED MODULE: ./layouts/default.vue?vue&type=template&id=593afc66&

// EXTERNAL MODULE: ./components/layout/MainFooter.vue + 2 modules
var MainFooter = __webpack_require__(27);

// EXTERNAL MODULE: ./components/layout/MainHeader.vue + 7 modules
var MainHeader = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./layouts/default.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var defaultvue_type_script_lang_js_ = ({
  components: {
    MainFooter: MainFooter["default"],
    MainHeader: MainHeader["default"]
  },
  transition: {
    name: 'page',
    mode: 'out-in'
  },

  data() {
    return {
      showMobileMenu: false
    };
  },

  watch: {
    '$route'() {
      this.showMobileMenu = false;
    }

  }
});
// CONCATENATED MODULE: ./layouts/default.vue?vue&type=script&lang=js&
 /* harmony default export */ var layouts_defaultvue_type_script_lang_js_ = (defaultvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./layouts/default.vue



function default_injectStyles (context) {
  
  var style0 = __webpack_require__(72)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var default_component = Object(componentNormalizer["a" /* default */])(
  layouts_defaultvue_type_script_lang_js_,
  defaultvue_type_template_id_593afc66_render,
  defaultvue_type_template_id_593afc66_staticRenderFns,
  false,
  default_injectStyles,
  null,
  "14b33ac5"
  
)

/* harmony default export */ var layouts_default = (default_component.exports);

/* nuxt-component-imports */
installComponents(default_component, {MobileMenu: __webpack_require__(80).default,MainHeader: __webpack_require__(26).default,MainFooter: __webpack_require__(27).default})

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/App.js








const layouts = {
  "_default": sanitizeComponent(layouts_default)
};
/* harmony default export */ var App = ({
  render(h, props) {
    const loadingEl = h('NuxtLoading', {
      ref: 'loading'
    });
    const layoutEl = h(this.layout || 'nuxt');
    const templateEl = h('div', {
      domProps: {
        id: '__layout'
      },
      key: this.layoutName
    }, [layoutEl]);
    const transitionEl = h('transition', {
      props: {
        name: 'layout',
        mode: 'out-in'
      },
      on: {
        beforeEnter(el) {
          // Ensure to trigger scroll event after calling scrollBehavior
          window.$nuxt.$nextTick(() => {
            window.$nuxt.$emit('triggerScroll');
          });
        }

      }
    }, [templateEl]);
    return h('div', {
      domProps: {
        id: '__nuxt'
      }
    }, [loadingEl, transitionEl]);
  },

  data: () => ({
    isOnline: true,
    layout: null,
    layoutName: '',
    nbFetching: 0
  }),

  beforeCreate() {
    external_vue_default.a.util.defineReactive(this, 'nuxt', this.$options.nuxt);
  },

  created() {
    // Add this.$nuxt in child instances
    this.$root.$options.$nuxt = this;

    if (false) {} // Add $nuxt.error()


    this.error = this.nuxt.error; // Add $nuxt.context

    this.context = this.$options.context;
  },

  async mounted() {
    this.$loading = this.$refs.loading;

    if (this.isPreview) {
      if (this.$store && this.$store._actions.nuxtServerInit) {
        this.$loading.start();
        await this.$store.dispatch('nuxtServerInit', this.context);
      }

      await this.refresh();
      this.$loading.finish();
    }
  },

  watch: {
    'nuxt.err': 'errorChanged'
  },
  computed: {
    isOffline() {
      return !this.isOnline;
    },

    isFetching() {
      return this.nbFetching > 0;
    },

    isPreview() {
      return Boolean(this.$options.previewData);
    }

  },
  methods: {
    refreshOnlineStatus() {
      if (false) {}
    },

    async refresh() {
      const pages = getMatchedComponentsInstances(this.$route);

      if (!pages.length) {
        return;
      }

      this.$loading.start();
      const promises = pages.map(page => {
        const p = []; // Old fetch

        if (page.$options.fetch && page.$options.fetch.length) {
          p.push(promisify(page.$options.fetch, this.context));
        }

        if (page.$fetch) {
          p.push(page.$fetch());
        } else {
          // Get all component instance to call $fetch
          for (const component of getChildrenComponentInstancesUsingFetch(page.$vnode.componentInstance)) {
            p.push(component.$fetch());
          }
        }

        if (page.$options.asyncData) {
          p.push(promisify(page.$options.asyncData, this.context).then(newData => {
            for (const key in newData) {
              external_vue_default.a.set(page.$data, key, newData[key]);
            }
          }));
        }

        return Promise.all(p);
      });

      try {
        await Promise.all(promises);
      } catch (error) {
        this.$loading.fail(error);
        globalHandleError(error);
        this.error(error);
      }

      this.$loading.finish();
    },

    errorChanged() {
      if (this.nuxt.err) {
        if (this.$loading) {
          if (this.$loading.fail) {
            this.$loading.fail(this.nuxt.err);
          }

          if (this.$loading.finish) {
            this.$loading.finish();
          }
        }

        let errorLayout = (nuxt_error.options || nuxt_error).layout;

        if (typeof errorLayout === 'function') {
          errorLayout = errorLayout(this.context);
        }

        this.setLayout(errorLayout);
      }
    },

    setLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }

      this.layoutName = layout;
      this.layout = layouts['_' + layout];
      return this.layout;
    },

    loadLayout(layout) {
      if (!layout || !layouts['_' + layout]) {
        layout = 'default';
      }

      return Promise.resolve(layouts['_' + layout]);
    },

    getRouterBase() {
      return (this.$router.options.base || '').replace(/\/+$/, '');
    },

    getRoutePath(route = '/') {
      const base = this.getRouterBase();

      if (base && route.startsWith(base)) {
        route = route.substr(base.length);
      }

      return (route.replace(/\/+$/, '') || '/').split('?')[0].split('#')[0];
    },

    getStaticAssetsPath(route = '/') {
      const {
        staticAssetsBase
      } = window.__NUXT__;
      return urlJoin(staticAssetsBase, this.getRoutePath(route));
    },

    async fetchStaticManifest() {
      return window.__NUXT_IMPORT__('manifest.js', encodeURI(urlJoin(this.getStaticAssetsPath(), 'manifest.js')));
    },

    setPagePayload(payload) {
      this._pagePayload = payload;
      this._payloadFetchIndex = 0;
    },

    async fetchPayload(route) {
      const manifest = await this.fetchStaticManifest();
      const path = this.getRoutePath(route);

      if (!manifest.routes.includes(path)) {
        this.setPagePayload(false);
        throw new Error(`Route ${path} is not pre-rendered`);
      }

      const src = urlJoin(this.getStaticAssetsPath(route), 'payload.js');

      try {
        const payload = await window.__NUXT_IMPORT__(decodeURI(route), encodeURI(src));
        this.setPagePayload(payload);
        return payload;
      } catch (err) {
        this.setPagePayload(false);
        throw err;
      }
    }

  },
  components: {
    NuxtLoading: nuxt_loading
  }
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/plugin.js

const globalComponents = {
  CopyCode: () => __webpack_require__.e(/* import() | components/global/CopyCode */ 1).then(__webpack_require__.bind(null, 85)).then(c => c.default || c),
  YouTube: () => __webpack_require__.e(/* import() | components/global/YouTube */ 2).then(__webpack_require__.bind(null, 93)).then(c => c.default || c)
};

for (const name in globalComponents) {
  external_vue_default.a.component(name, globalComponents[name]);
}
// EXTERNAL MODULE: ./node_modules/.cache/nuxt/empty.js
var nuxt_empty = __webpack_require__(74);

// EXTERNAL MODULE: ./node_modules/.cache/nuxt/content/nuxt-content.js
var nuxt_content = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/.cache/nuxt/content/plugin.server.js


external_vue_default.a.component(nuxt_content["a" /* default */].name, nuxt_content["a" /* default */]);
/* harmony default export */ var plugin_server = ((ctx, inject) => {
  const $content = ctx.ssrContext.$content;
  inject('content', $content);
  ctx.$content = $content;
});
// EXTERNAL MODULE: ./node_modules/vue-instantsearch/dist/vue-instantsearch.common.js
var vue_instantsearch_common = __webpack_require__(56);
var vue_instantsearch_common_default = /*#__PURE__*/__webpack_require__.n(vue_instantsearch_common);

// CONCATENATED MODULE: ./plugins/vue-instantsearch.js


external_vue_default.a.use(vue_instantsearch_common_default.a);
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/index.js










/* Plugins */

 // Source: ./components/plugin.js (mode: 'all')

 // Source: ./content/plugin.client.js (mode: 'client')

 // Source: ./content/plugin.server.js (mode: 'server')

 // Source: ../../../plugins/vue-instantsearch (mode: 'all')
// Component: <ClientOnly>

external_vue_default.a.component(external_vue_client_only_default.a.name, external_vue_client_only_default.a); // TODO: Remove in Nuxt 3: <NoSsr>

external_vue_default.a.component(external_vue_no_ssr_default.a.name, { ...external_vue_no_ssr_default.a,

  render(h, ctx) {
    if (false) {}

    return external_vue_no_ssr_default.a.render(h, ctx);
  }

}); // Component: <NuxtChild>

external_vue_default.a.component(nuxt_child.name, nuxt_child);
external_vue_default.a.component('NChild', nuxt_child); // Component NuxtLink is imported in server.js or client.js
// Component: <Nuxt>

external_vue_default.a.component(components_nuxt.name, components_nuxt);
Object.defineProperty(external_vue_default.a.prototype, '$nuxt', {
  get() {
    return this.$root.$options.$nuxt;
  },

  configurable: true
});
external_vue_default.a.use(external_vue_meta_default.a, {
  "keyName": "head",
  "attribute": "data-n-head",
  "ssrAttribute": "data-n-head-ssr",
  "tagIDKeyName": "hid"
});
const defaultTransition = {
  "name": "page",
  "mode": "out-in",
  "appear": false,
  "appearClass": "appear",
  "appearActiveClass": "appear-active",
  "appearToClass": "appear-to"
};

async function createApp(ssrContext, config = {}) {
  const router = await createRouter(ssrContext); // Create Root instance
  // here we inject the router and store to all child components,
  // making them available everywhere as `this.$router` and `this.$store`.

  const app = {
    head: {
      "title": "Documentation Center",
      "meta": [{
        "charset": "utf-8"
      }, {
        "name": "viewport",
        "content": "width=device-width, initial-scale=1"
      }, {
        "hid": "description",
        "name": "description",
        "content": ""
      }],
      "link": [{
        "rel": "icon",
        "type": "image\u002Fx-icon",
        "href": "\u002Ffavicon.png"
      }],
      "style": [],
      "script": []
    },
    router,
    nuxt: {
      defaultTransition,
      transitions: [defaultTransition],

      setTransitions(transitions) {
        if (!Array.isArray(transitions)) {
          transitions = [transitions];
        }

        transitions = transitions.map(transition => {
          if (!transition) {
            transition = defaultTransition;
          } else if (typeof transition === 'string') {
            transition = Object.assign({}, defaultTransition, {
              name: transition
            });
          } else {
            transition = Object.assign({}, defaultTransition, transition);
          }

          return transition;
        });
        this.$options.nuxt.transitions = transitions;
        return transitions;
      },

      err: null,
      dateErr: null,

      error(err) {
        err = err || null;
        app.context._errored = Boolean(err);
        err = err ? normalizeError(err) : null;
        let nuxt = app.nuxt; // to work with @vue/composition-api, see https://github.com/nuxt/nuxt.js/issues/6517#issuecomment-573280207

        if (this) {
          nuxt = this.nuxt || this.$options.nuxt;
        }

        nuxt.dateErr = Date.now();
        nuxt.err = err; // Used in src/server.js

        if (ssrContext) {
          ssrContext.nuxt.error = err;
        }

        return err;
      }

    },
    ...App
  };
  const next = ssrContext ? ssrContext.next : location => app.router.push(location); // Resolve route

  let route;

  if (ssrContext) {
    route = router.resolve(ssrContext.url).route;
  } else {
    const path = getLocation(router.options.base, router.options.mode);
    route = router.resolve(path).route;
  } // Set context to app.context


  await setContext(app, {
    route,
    next,
    error: app.nuxt.error.bind(app),
    payload: ssrContext ? ssrContext.payload : undefined,
    req: ssrContext ? ssrContext.req : undefined,
    res: ssrContext ? ssrContext.res : undefined,
    beforeRenderFns: ssrContext ? ssrContext.beforeRenderFns : undefined,
    ssrContext
  });

  function inject(key, value) {
    if (!key) {
      throw new Error('inject(key, value) has no key provided');
    }

    if (value === undefined) {
      throw new Error(`inject('${key}', value) has no value provided`);
    }

    key = '$' + key; // Add into app

    app[key] = value; // Add into context

    if (!app.context[key]) {
      app.context[key] = value;
    } // Check if plugin not already installed


    const installKey = '__nuxt_' + key + '_installed__';

    if (external_vue_default.a[installKey]) {
      return;
    }

    external_vue_default.a[installKey] = true; // Call Vue.use() to install the plugin into vm

    external_vue_default.a.use(() => {
      if (!Object.prototype.hasOwnProperty.call(external_vue_default.a.prototype, key)) {
        Object.defineProperty(external_vue_default.a.prototype, key, {
          get() {
            return this.$root.$options[key];
          }

        });
      }
    });
  } // Inject runtime config as $config


  inject('config', config); // Add enablePreview(previewData = {}) in context for plugins

  if (false) {} // Plugin execution


  if (typeof /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./node_modules/.cache/nuxt/components/plugin.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  }

  if (false) {}

  if ( true && typeof plugin_server === 'function') {
    await plugin_server(app.context, inject);
  }

  if (typeof /* Cannot get final name for export "default" in "./plugins/vue-instantsearch.js" (known exports: , known reexports: ) */ undefined === 'function') {
    await /* Cannot get final name for export "default" in "./plugins/vue-instantsearch.js" (known exports: , known reexports: ) */ undefined(app.context, inject);
  } // Lock enablePreview in context


  if (false) {} // If server-side, wait for async component to be resolved first


  if ( true && ssrContext && ssrContext.url) {
    await new Promise((resolve, reject) => {
      router.push(ssrContext.url, resolve, err => {
        // https://github.com/vuejs/vue-router/blob/v3.4.3/src/util/errors.js
        if (!err._isRouter) return reject(err);
        if (err.type !== 2
        /* NavigationFailureType.redirected */
        ) return resolve(); // navigated to a different route in router guard

        const unregister = router.afterEach(async (to, from) => {
          ssrContext.url = to.fullPath;
          app.context.route = await getRouteData(to);
          app.context.params = to.params || {};
          app.context.query = to.query || {};
          unregister();
          resolve();
        });
      });
    });
  }

  return {
    app,
    router
  };
}


// CONCATENATED MODULE: ./node_modules/.cache/nuxt/components/nuxt-link.server.js

/* harmony default export */ var nuxt_link_server = ({
  name: 'NuxtLink',
  extends: external_vue_default.a.component('RouterLink'),
  props: {
    prefetch: {
      type: Boolean,
      default: true
    },
    noPrefetch: {
      type: Boolean,
      default: false
    }
  }
});
// CONCATENATED MODULE: ./node_modules/.cache/nuxt/server.js








 // should be included after ./index.js
// Update serverPrefetch strategy

external_vue_default.a.config.optionMergeStrategies.serverPrefetch = external_vue_default.a.config.optionMergeStrategies.created; // Fetch mixin

if (!external_vue_default.a.__nuxt__fetch__mixin__) {
  external_vue_default.a.mixin(fetch_server);
  external_vue_default.a.__nuxt__fetch__mixin__ = true;
} // Component: <NuxtLink>


external_vue_default.a.component(nuxt_link_server.name, nuxt_link_server);
external_vue_default.a.component('NLink', nuxt_link_server);

if (!global.fetch) {
  global.fetch = external_node_fetch_default.a;
}

const noopApp = () => new external_vue_default.a({
  render: h => h('div')
});

function server_urlJoin() {
  return Array.prototype.slice.call(arguments).join('/').replace(/\/+/g, '/');
}

const createNext = ssrContext => opts => {
  // If static target, render on client-side
  ssrContext.redirected = opts;

  if (ssrContext.target === 'static' || !ssrContext.res) {
    ssrContext.nuxt.serverRendered = false;
    return;
  }

  opts.query = Object(external_querystring_["stringify"])(opts.query);
  opts.path = opts.path + (opts.query ? '?' + opts.query : '');
  const routerBase = '/';

  if (!opts.path.startsWith('http') && routerBase !== '/' && !opts.path.startsWith(routerBase)) {
    opts.path = server_urlJoin(routerBase, opts.path);
  } // Avoid loop redirect


  if (decodeURI(opts.path) === decodeURI(ssrContext.url)) {
    ssrContext.redirected = false;
    return;
  }

  ssrContext.res.writeHead(opts.status, {
    Location: Object(ufo_["normalizeURL"])(opts.path)
  });
  ssrContext.res.end();
}; // This exported function will be called by `bundleRenderer`.
// This is where we perform data-prefetching to determine the
// state of our application before actually rendering it.
// Since data fetching is async, this function is expected to
// return a Promise that resolves to the app instance.


/* harmony default export */ var server = __webpack_exports__["default"] = (async ssrContext => {
  // Create ssrContext.next for simulate next() of beforeEach() when wanted to redirect
  ssrContext.redirected = false;
  ssrContext.next = createNext(ssrContext); // Used for beforeNuxtRender({ Components, nuxtState })

  ssrContext.beforeRenderFns = []; // Nuxt object (window.{{globals.context}}, defaults to window.__NUXT__)

  ssrContext.nuxt = {
    layout: 'default',
    data: [],
    fetch: [],
    error: null,
    serverRendered: true,
    routePath: ''
  }; // Remove query from url is static target

  if ( true && ssrContext.url) {
    ssrContext.url = ssrContext.url.split('?')[0];
  } // Public runtime config


  ssrContext.nuxt.config = ssrContext.runtimeConfig.public; // Create the app definition and the instance (created for each request)

  const {
    app,
    router
  } = await createApp(ssrContext, { ...ssrContext.runtimeConfig.public,
    ...ssrContext.runtimeConfig.private
  });

  const _app = new external_vue_default.a(app); // Add ssr route path to nuxt context so we can account for page navigation between ssr and csr


  ssrContext.nuxt.routePath = app.context.route.path; // Add meta infos (used in renderer.js)

  ssrContext.meta = _app.$meta(); // Keep asyncData for each matched component in ssrContext (used in app/utils.js via this.$ssrContext)

  ssrContext.asyncData = {};

  const beforeRender = async () => {
    // Call beforeNuxtRender() methods
    await Promise.all(ssrContext.beforeRenderFns.map(fn => promisify(fn, {
      Components,
      nuxtState: ssrContext.nuxt
    })));
  };

  const renderErrorPage = async () => {
    // Don't server-render the page in static target
    if (ssrContext.target === 'static') {
      ssrContext.nuxt.serverRendered = false;
    } // Load layout for error page


    const layout = (nuxt_error.options || nuxt_error).layout;
    const errLayout = typeof layout === 'function' ? layout.call(nuxt_error, app.context) : layout;
    ssrContext.nuxt.layout = errLayout || 'default';
    await _app.loadLayout(errLayout);

    _app.setLayout(errLayout);

    await beforeRender();
    return _app;
  };

  const render404Page = () => {
    app.context.error({
      statusCode: 404,
      path: ssrContext.url,
      message: 'This page could not be found'
    });
    return renderErrorPage();
  }; // Components are already resolved by setContext -> getRouteData (app/utils.js)


  const Components = getMatchedComponents(router.match(ssrContext.url));
  /*
  ** Call global middleware (nuxt.config.js)
  */

  let midd = [];
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }

    if (typeof nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }

    return nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }
  /*
  ** Set layout
  */


  let layout = Components.length ? Components[0].options.layout : nuxt_error.layout;

  if (typeof layout === 'function') {
    layout = layout(app.context);
  }

  await _app.loadLayout(layout);

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }

  layout = _app.setLayout(layout);
  ssrContext.nuxt.layout = _app.layoutName;
  /*
  ** Call middleware (layout + pages)
  */

  midd = [];
  layout = sanitizeComponent(layout);

  if (layout.options.middleware) {
    midd = midd.concat(layout.options.middleware);
  }

  Components.forEach(Component => {
    if (Component.options.middleware) {
      midd = midd.concat(Component.options.middleware);
    }
  });
  midd = midd.map(name => {
    if (typeof name === 'function') {
      return name;
    }

    if (typeof nuxt_middleware[name] !== 'function') {
      app.context.error({
        statusCode: 500,
        message: 'Unknown middleware ' + name
      });
    }

    return nuxt_middleware[name];
  });
  await middlewareSeries(midd, app.context); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  }
  /*
  ** Call .validate()
  */


  let isValid = true;

  try {
    for (const Component of Components) {
      if (typeof Component.options.validate !== 'function') {
        continue;
      }

      isValid = await Component.options.validate(app.context);

      if (!isValid) {
        break;
      }
    }
  } catch (validationError) {
    // ...If .validate() threw an error
    app.context.error({
      statusCode: validationError.statusCode || '500',
      message: validationError.message
    });
    return renderErrorPage();
  } // ...If .validate() returned false


  if (!isValid) {
    // Render a 404 error page
    return render404Page();
  } // If no Components found, returns 404


  if (!Components.length) {
    return render404Page();
  } // Call asyncData & fetch hooks on components matched by the route.


  const asyncDatas = await Promise.all(Components.map(Component => {
    const promises = []; // Call asyncData(context)

    if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {
      const promise = promisify(Component.options.asyncData, app.context);
      promise.then(asyncDataResult => {
        ssrContext.asyncData[Component.cid] = asyncDataResult;
        applyAsyncData(Component);
        return asyncDataResult;
      });
      promises.push(promise);
    } else {
      promises.push(null);
    } // Call fetch(context)


    if (Component.options.fetch && Component.options.fetch.length) {
      promises.push(Component.options.fetch(app.context));
    } else {
      promises.push(null);
    }

    return Promise.all(promises);
  })); // datas are the first row of each

  ssrContext.nuxt.data = asyncDatas.map(r => r[0] || {}); // ...If there is a redirect or an error, stop the process

  if (ssrContext.redirected) {
    return noopApp();
  }

  if (ssrContext.nuxt.error) {
    return renderErrorPage();
  } // Call beforeNuxtRender methods & add store state


  await beforeRender();
  return _app;
});

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "algoliasearch-helper"
var external_algoliasearch_helper_ = __webpack_require__(4);
var external_algoliasearch_helper_default = /*#__PURE__*/__webpack_require__.n(external_algoliasearch_helper_);

// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(57);
var external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/widgets/index/index.js
var index = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/version.js
/* harmony default export */ var version = ('4.10.0');
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getPropertyByPath.js
var getPropertyByPath = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/escape-highlight.js
var escape_highlight = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/suit.js
var NAMESPACE = 'ais';
var component = function component(componentName) {
  return function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        descendantName = _ref.descendantName,
        modifierName = _ref.modifierName;

    var descendent = descendantName ? "-".concat(descendantName) : '';
    var modifier = modifierName ? "--".concat(modifierName) : '';
    return "".concat(NAMESPACE, "-").concat(componentName).concat(descendent).concat(modifier);
  };
};
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/highlight.js



var suit = component('Highlight');
function highlight_highlight(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = Object(getPropertyByPath["a" /* default */])(hit._highlightResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  return attributeValue.replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/concatHighlightedParts.js
var concatHighlightedParts = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/reverseHighlightedParts.js
var reverseHighlightedParts = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/getHighlightedParts.js
var getHighlightedParts = __webpack_require__(51);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/reverseHighlight.js



var reverseHighlight_suit = component('ReverseHighlight');
function reverseHighlight_reverseHighlight(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = Object(getPropertyByPath["a" /* default */])(hit._highlightResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = reverseHighlight_suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  var reverseHighlightedValue = Object(concatHighlightedParts["a" /* default */])(Object(reverseHighlightedParts["a" /* default */])(Object(getHighlightedParts["a" /* default */])(attributeValue)));
  return reverseHighlightedValue.replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/snippet.js



var snippet_suit = component('Snippet');
function snippet_snippet(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = Object(getPropertyByPath["a" /* default */])(hit._snippetResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = snippet_suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  return attributeValue.replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/reverseSnippet.js



var reverseSnippet_suit = component('ReverseSnippet');
function reverseSnippet_reverseSnippet(_ref) {
  var attribute = _ref.attribute,
      _ref$highlightedTagNa = _ref.highlightedTagName,
      highlightedTagName = _ref$highlightedTagNa === void 0 ? 'mark' : _ref$highlightedTagNa,
      hit = _ref.hit,
      _ref$cssClasses = _ref.cssClasses,
      cssClasses = _ref$cssClasses === void 0 ? {} : _ref$cssClasses;

  var _ref2 = Object(getPropertyByPath["a" /* default */])(hit._snippetResult, attribute) || {},
      _ref2$value = _ref2.value,
      attributeValue = _ref2$value === void 0 ? '' : _ref2$value; // cx is not used, since it would be bundled as a dependency for Vue & Angular


  var className = reverseSnippet_suit({
    descendantName: 'highlighted'
  }) + (cssClasses.highlighted ? " ".concat(cssClasses.highlighted) : '');
  var reverseHighlightedValue = Object(concatHighlightedParts["a" /* default */])(Object(reverseHighlightedParts["a" /* default */])(Object(getHighlightedParts["a" /* default */])(attributeValue)));
  return reverseHighlightedValue.replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPreTag, 'g'), "<".concat(highlightedTagName, " class=\"").concat(className, "\">")).replace(new RegExp(escape_highlight["b" /* TAG_REPLACEMENT */].highlightPostTag, 'g'), "</".concat(highlightedTagName, ">"));
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/insights.js
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}


function readDataAttributes(domElement) {
  var method = domElement.getAttribute('data-insights-method');
  var serializedPayload = domElement.getAttribute('data-insights-payload');

  if (typeof serializedPayload !== 'string') {
    throw new Error('The insights helper expects `data-insights-payload` to be a base64-encoded JSON string.');
  }

  try {
    var payload = JSON.parse(atob(serializedPayload));
    return {
      method: method,
      payload: payload
    };
  } catch (error) {
    throw new Error('The insights helper was unable to parse `data-insights-payload`.');
  }
}
function hasDataAttributes(domElement) {
  return domElement.hasAttribute('data-insights-method');
}
function writeDataAttributes(_ref) {
  var method = _ref.method,
      payload = _ref.payload;

  if (_typeof(payload) !== 'object') {
    throw new Error("The insights helper expects the payload to be an object.");
  }

  var serializedPayload;

  try {
    serializedPayload = btoa(JSON.stringify(payload));
  } catch (error) {
    throw new Error("Could not JSON serialize the payload object.");
  }

  return "data-insights-method=\"".concat(method, "\" data-insights-payload=\"").concat(serializedPayload, "\"");
}
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 */

function insights_insights(method, payload) {
   false ? undefined : void 0;
  return writeDataAttributes({
    method: method,
    payload: payload
  });
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/createHelpers.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}


function hoganHelpers(_ref) {
  var numberLocale = _ref.numberLocale;
  return {
    formatNumber: function formatNumber(value, render) {
      return Number(render(value)).toLocaleString(numberLocale);
    },
    highlight: function highlight(options, render) {
      try {
        var highlightOptions = JSON.parse(options);
        return render(highlight_highlight(_objectSpread({}, highlightOptions, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\nThe highlight helper expects a JSON object of the format:\n{ \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    reverseHighlight: function reverseHighlight(options, render) {
      try {
        var reverseHighlightOptions = JSON.parse(options);
        return render(reverseHighlight_reverseHighlight(_objectSpread({}, reverseHighlightOptions, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\n  The reverseHighlight helper expects a JSON object of the format:\n  { \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    snippet: function snippet(options, render) {
      try {
        var snippetOptions = JSON.parse(options);
        return render(snippet_snippet(_objectSpread({}, snippetOptions, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\nThe snippet helper expects a JSON object of the format:\n{ \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    reverseSnippet: function reverseSnippet(options, render) {
      try {
        var reverseSnippetOptions = JSON.parse(options);
        return render(reverseSnippet_reverseSnippet(_objectSpread({}, reverseSnippetOptions, {
          hit: this
        })));
      } catch (error) {
        throw new Error("\n  The reverseSnippet helper expects a JSON object of the format:\n  { \"attribute\": \"name\", \"highlightedTagName\": \"mark\" }");
      }
    },
    insights: function insights(options, render) {
      try {
        var _JSON$parse = JSON.parse(options),
            method = _JSON$parse.method,
            payload = _JSON$parse.payload;

        return render(insights_insights(method, _objectSpread({
          objectIDs: [this.objectID]
        }, payload)));
      } catch (error) {
        throw new Error("\nThe insights helper expects a JSON object of the format:\n{ \"method\": \"method-name\", \"payload\": { \"eventName\": \"name of the event\" } }");
      }
    }
  };
}
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/documentation.js
var documentation = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/defer.js
var defer = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/noop.js
var noop = __webpack_require__(9);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/stateMappings/simple.js
function simple_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function simple_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      simple_ownKeys(Object(source), true).forEach(function (key) {
        simple_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      simple_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function simple_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function getIndexStateWithoutConfigure(uiState) {
  var configure = uiState.configure,
      trackedUiState = _objectWithoutProperties(uiState, ["configure"]);

  return trackedUiState;
} // technically a URL could contain any key, since users provide it,
// which is why the input to this function is UiState, not something
// which excludes "configure" as this function does.


function simpleStateMapping() {
  return {
    stateToRoute: function stateToRoute(uiState) {
      return Object.keys(uiState).reduce(function (state, indexId) {
        return simple_objectSpread({}, state, simple_defineProperty({}, indexId, getIndexStateWithoutConfigure(uiState[indexId])));
      }, {});
    },
    routeToState: function routeToState() {
      var routeState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return Object.keys(routeState).reduce(function (state, indexId) {
        return simple_objectSpread({}, state, simple_defineProperty({}, indexId, getIndexStateWithoutConfigure(routeState[indexId])));
      }, {});
    }
  };
}
// EXTERNAL MODULE: external "qs"
var external_qs_ = __webpack_require__(31);
var external_qs_default = /*#__PURE__*/__webpack_require__.n(external_qs_);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/routers/history.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function history_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



var defaultCreateURL = function defaultCreateURL(_ref) {
  var qsModule = _ref.qsModule,
      routeState = _ref.routeState,
      location = _ref.location;
  var protocol = location.protocol,
      hostname = location.hostname,
      _location$port = location.port,
      port = _location$port === void 0 ? '' : _location$port,
      pathname = location.pathname,
      hash = location.hash;
  var queryString = qsModule.stringify(routeState);
  var portWithPrefix = port === '' ? '' : ":".concat(port); // IE <= 11 has no proper `location.origin` so we cannot rely on it.

  if (!queryString) {
    return "".concat(protocol, "//").concat(hostname).concat(portWithPrefix).concat(pathname).concat(hash);
  }

  return "".concat(protocol, "//").concat(hostname).concat(portWithPrefix).concat(pathname, "?").concat(queryString).concat(hash);
};

var defaultParseURL = function defaultParseURL(_ref2) {
  var qsModule = _ref2.qsModule,
      location = _ref2.location; // `qs` by default converts arrays with more than 20 items to an object.
  // We want to avoid this because the data structure manipulated can therefore vary.
  // Setting the limit to `100` seems a good number because the engine's default is 100
  // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).
  //
  // Using an `arrayLimit` of `n` allows `n + 1` items.
  //
  // See:
  //   - https://github.com/ljharb/qs#parsing-arrays
  //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/

  return qsModule.parse(location.search.slice(1), {
    arrayLimit: 99
  });
};

var setWindowTitle = function setWindowTitle(title) {
  if (title) {
    window.document.title = title;
  }
};

var history_BrowserHistory = /*#__PURE__*/function () {
  /**
   * Initializes a new storage provider that syncs the search state to the URL
   * using web APIs (`window.location.pushState` and `onpopstate` event).
   */
  function BrowserHistory() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        windowTitle = _ref3.windowTitle,
        _ref3$writeDelay = _ref3.writeDelay,
        writeDelay = _ref3$writeDelay === void 0 ? 400 : _ref3$writeDelay,
        _ref3$createURL = _ref3.createURL,
        createURL = _ref3$createURL === void 0 ? defaultCreateURL : _ref3$createURL,
        _ref3$parseURL = _ref3.parseURL,
        parseURL = _ref3$parseURL === void 0 ? defaultParseURL : _ref3$parseURL;

    _classCallCheck(this, BrowserHistory);

    history_defineProperty(this, "windowTitle", void 0);

    history_defineProperty(this, "writeDelay", void 0);

    history_defineProperty(this, "_createURL", void 0);

    history_defineProperty(this, "parseURL", void 0);

    history_defineProperty(this, "writeTimer", void 0);

    this.windowTitle = windowTitle;
    this.writeTimer = undefined;
    this.writeDelay = writeDelay;
    this._createURL = createURL;
    this.parseURL = parseURL;
    var title = this.windowTitle && this.windowTitle(this.read());
    setWindowTitle(title);
  }
  /**
   * Reads the URL and returns a syncable UI search state.
   */


  _createClass(BrowserHistory, [{
    key: "read",
    value: function read() {
      return this.parseURL({
        qsModule: external_qs_default.a,
        location: window.location
      });
    }
    /**
     * Pushes a search state into the URL.
     */

  }, {
    key: "write",
    value: function write(routeState) {
      var _this = this;

      var url = this.createURL(routeState);
      var title = this.windowTitle && this.windowTitle(routeState);

      if (this.writeTimer) {
        window.clearTimeout(this.writeTimer);
      }

      this.writeTimer = window.setTimeout(function () {
        setWindowTitle(title);
        window.history.pushState(routeState, title || '', url);
        _this.writeTimer = undefined;
      }, this.writeDelay);
    }
    /**
     * Sets a callback on the `onpopstate` event of the history API of the current page.
     * It enables the URL sync to keep track of the changes.
     */

  }, {
    key: "onUpdate",
    value: function onUpdate(callback) {
      var _this2 = this;

      this._onPopState = function (event) {
        if (_this2.writeTimer) {
          window.clearTimeout(_this2.writeTimer);
          _this2.writeTimer = undefined;
        }

        var routeState = event.state; // At initial load, the state is read from the URL without update.
        // Therefore the state object is not available.
        // In this case, we fallback and read the URL.

        if (!routeState) {
          callback(_this2.read());
        } else {
          callback(routeState);
        }
      };

      window.addEventListener('popstate', this._onPopState);
    }
    /**
     * Creates a complete URL from a given syncable UI state.
     *
     * It always generates the full URL, not a relative one.
     * This allows to handle cases like using a <base href>.
     * See: https://github.com/algolia/instantsearch.js/issues/790
     */

  }, {
    key: "createURL",
    value: function createURL(routeState) {
      return this._createURL({
        qsModule: external_qs_default.a,
        routeState: routeState,
        location: window.location
      });
    }
    /**
     * Removes the event listener and cleans up the URL.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._onPopState) {
        window.removeEventListener('popstate', this._onPopState);
      }

      if (this.writeTimer) {
        window.clearTimeout(this.writeTimer);
      }

      this.write({});
    }
  }]);

  return BrowserHistory;
}();

/* harmony default export */ var routers_history = (function (props) {
  return new history_BrowserHistory(props);
});
// EXTERNAL MODULE: ./node_modules/instantsearch.js/es/lib/utils/isEqual.js
var isEqual = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/middlewares/createRouterMiddleware.js
function createRouterMiddleware_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function createRouterMiddleware_objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      createRouterMiddleware_ownKeys(Object(source), true).forEach(function (key) {
        createRouterMiddleware_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      createRouterMiddleware_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function createRouterMiddleware_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}




var createRouterMiddleware_createRouterMiddleware = function createRouterMiddleware() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _props$router = props.router,
      router = _props$router === void 0 ? routers_history() : _props$router,
      _props$stateMapping = props.stateMapping,
      stateMapping = _props$stateMapping === void 0 ? simpleStateMapping() : _props$stateMapping;
  return function (_ref) {
    var instantSearchInstance = _ref.instantSearchInstance;

    function topLevelCreateURL(nextState) {
      var uiState = Object.keys(nextState).reduce(function (acc, indexId) {
        return createRouterMiddleware_objectSpread({}, acc, createRouterMiddleware_defineProperty({}, indexId, nextState[indexId]));
      }, instantSearchInstance.mainIndex.getWidgetUiState({}));
      var route = stateMapping.stateToRoute(uiState);
      return router.createURL(route);
    }

    instantSearchInstance._createURL = topLevelCreateURL;
    instantSearchInstance._initialUiState = createRouterMiddleware_objectSpread({}, instantSearchInstance._initialUiState, {}, stateMapping.routeToState(router.read()));
    var lastRouteState = undefined;
    return {
      onStateChange: function onStateChange(_ref2) {
        var uiState = _ref2.uiState;
        var routeState = stateMapping.stateToRoute(uiState);

        if (lastRouteState === undefined || !Object(isEqual["a" /* default */])(lastRouteState, routeState)) {
          router.write(routeState);
          lastRouteState = routeState;
        }
      },
      subscribe: function subscribe() {
        router.onUpdate(function (route) {
          instantSearchInstance.setUiState(stateMapping.routeToState(route));
        });
      },
      unsubscribe: function unsubscribe() {
        router.dispose();
      }
    };
  };
};
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/InstantSearch.js
function InstantSearch_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    InstantSearch_typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    InstantSearch_typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return InstantSearch_typeof(obj);
}

function InstantSearch_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function InstantSearch_defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function InstantSearch_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) InstantSearch_defineProperties(Constructor.prototype, protoProps);
  if (staticProps) InstantSearch_defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (InstantSearch_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function InstantSearch_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}








var withUsage = Object(documentation["b" /* createDocumentationMessageGenerator */])({
  name: 'instantsearch'
});

function InstantSearch_defaultCreateURL() {
  return '#';
}
/**
 * Global options for an InstantSearch instance.
 */

/**
 * The actual implementation of the InstantSearch. This is
 * created using the `instantsearch` factory function.
 * It emits the 'render' event every time a search is done
 */


var InstantSearch_InstantSearch = /*#__PURE__*/function (_EventEmitter) {
  _inherits(InstantSearch, _EventEmitter);

  function InstantSearch(options) {
    var _this;

    InstantSearch_classCallCheck(this, InstantSearch);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InstantSearch).call(this));

    InstantSearch_defineProperty(_assertThisInitialized(_this), "client", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "indexName", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "insightsClient", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "onStateChange", null);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "helper", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "mainHelper", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "mainIndex", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "started", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "templatesConfig", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "renderState", {});

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_stalledSearchDelay", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_searchStalledTimer", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_isSearchStalled", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_initialUiState", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_createURL", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_searchFunction", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "_mainHelperSearch", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "middleware", []);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "sendEventToInsights", void 0);

    InstantSearch_defineProperty(_assertThisInitialized(_this), "scheduleSearch", Object(defer["a" /* default */])(function () {
      if (_this.started) {
        _this.mainHelper.search();
      }
    }));

    InstantSearch_defineProperty(_assertThisInitialized(_this), "scheduleRender", Object(defer["a" /* default */])(function () {
      if (!_this.mainHelper.hasPendingRequests()) {
        clearTimeout(_this._searchStalledTimer);
        _this._searchStalledTimer = null;
        _this._isSearchStalled = false;
      }

      _this.mainIndex.render({
        instantSearchInstance: _assertThisInitialized(_this)
      });

      _this.emit('render');
    }));

    InstantSearch_defineProperty(_assertThisInitialized(_this), "onInternalStateChange", function () {
      var nextUiState = _this.mainIndex.getWidgetUiState({});

      _this.middleware.forEach(function (m) {
        m.onStateChange({
          uiState: nextUiState
        });
      });
    });

    var _options$indexName = options.indexName,
        indexName = _options$indexName === void 0 ? null : _options$indexName,
        numberLocale = options.numberLocale,
        _options$initialUiSta = options.initialUiState,
        initialUiState = _options$initialUiSta === void 0 ? {} : _options$initialUiSta,
        _options$routing = options.routing,
        routing = _options$routing === void 0 ? null : _options$routing,
        searchFunction = options.searchFunction,
        _options$stalledSearc = options.stalledSearchDelay,
        stalledSearchDelay = _options$stalledSearc === void 0 ? 200 : _options$stalledSearc,
        _options$searchClient = options.searchClient,
        searchClient = _options$searchClient === void 0 ? null : _options$searchClient,
        _options$insightsClie = options.insightsClient,
        insightsClient = _options$insightsClie === void 0 ? null : _options$insightsClie,
        _options$onStateChang = options.onStateChange,
        onStateChange = _options$onStateChang === void 0 ? null : _options$onStateChang;

    if (indexName === null) {
      throw new Error(withUsage('The `indexName` option is required.'));
    }

    if (searchClient === null) {
      throw new Error(withUsage('The `searchClient` option is required.'));
    }

    if (typeof searchClient.search !== 'function') {
      throw new Error("The `searchClient` must implement a `search` method.\n\nSee: https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/backend-instantsearch/js/");
    }

    if (typeof searchClient.addAlgoliaAgent === 'function') {
      searchClient.addAlgoliaAgent("instantsearch.js (".concat(version, ")"));
    }

     false ? undefined : void 0;

    if (insightsClient && typeof insightsClient !== 'function') {
      throw new Error(withUsage('The `insightsClient` option should be a function.'));
    }

     false ? undefined : void 0;
    _this.client = searchClient;
    _this.insightsClient = insightsClient;
    _this.indexName = indexName;
    _this.helper = null;
    _this.mainHelper = null;
    _this.mainIndex = Object(index["default"])({
      indexName: indexName
    });
    _this.onStateChange = onStateChange;
    _this.started = false;
    _this.templatesConfig = {
      helpers: hoganHelpers({
        numberLocale: numberLocale
      }),
      compileOptions: {}
    };
    _this._stalledSearchDelay = stalledSearchDelay;
    _this._searchStalledTimer = null;
    _this._isSearchStalled = false;
    _this._createURL = InstantSearch_defaultCreateURL;
    _this._initialUiState = initialUiState;

    if (searchFunction) {
      _this._searchFunction = searchFunction;
    }

    _this.sendEventToInsights = noop["a" /* default */];

    if (routing) {
      var routerOptions = typeof routing === 'boolean' ? undefined : routing;

      _this.use(createRouterMiddleware_createRouterMiddleware(routerOptions));
    }

    return _this;
  }
  /**
   * Hooks a middleware into the InstantSearch lifecycle.
   *
   * This method is considered as experimental and is subject to change in
   * minor versions.
   */


  InstantSearch_createClass(InstantSearch, [{
    key: "use",
    value: function use() {
      var _this2 = this;

      for (var _len = arguments.length, middleware = new Array(_len), _key = 0; _key < _len; _key++) {
        middleware[_key] = arguments[_key];
      }

      var newMiddlewareList = middleware.map(function (fn) {
        var newMiddleware = fn({
          instantSearchInstance: _this2
        });

        _this2.middleware.push(newMiddleware);

        return newMiddleware;
      }); // If the instance has already started, we directly subscribe the
      // middleware so they're notified of changes.

      if (this.started) {
        newMiddlewareList.forEach(function (m) {
          m.subscribe();
        });
      }

      return this;
    } // @major we shipped with EXPERIMENTAL_use, but have changed that to just `use` now

  }, {
    key: "EXPERIMENTAL_use",
    value: function EXPERIMENTAL_use() {
       false ? undefined : void 0;
      return this.use.apply(this, arguments);
    }
    /**
     * Adds a widget to the search instance.
     * A widget can be added either before or after InstantSearch has started.
     * @param widget The widget to add to InstantSearch.
     *
     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `addWidgets([widget])`.
     */

  }, {
    key: "addWidget",
    value: function addWidget(widget) {
       false ? undefined : void 0;
      return this.addWidgets([widget]);
    }
    /**
     * Adds multiple widgets to the search instance.
     * Widgets can be added either before or after InstantSearch has started.
     * @param widgets The array of widgets to add to InstantSearch.
     */

  }, {
    key: "addWidgets",
    value: function addWidgets(widgets) {
      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `addWidgets` method expects an array of widgets. Please use `addWidget`.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.init !== 'function' && typeof widget.render !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `render` and/or an `init` method.'));
      }

      this.mainIndex.addWidgets(widgets);
      return this;
    }
    /**
     * Removes a widget from the search instance.
     * @deprecated This method will still be supported in 4.x releases, but not further. It is replaced by `removeWidgets([widget])`
     * @param widget The widget instance to remove from InstantSearch.
     *
     * The widget must implement a `dispose()` method to clear its state.
     */

  }, {
    key: "removeWidget",
    value: function removeWidget(widget) {
       false ? undefined : void 0;
      return this.removeWidgets([widget]);
    }
    /**
     * Removes multiple widgets from the search instance.
     * @param widgets Array of widgets instances to remove from InstantSearch.
     *
     * The widgets must implement a `dispose()` method to clear their states.
     */

  }, {
    key: "removeWidgets",
    value: function removeWidgets(widgets) {
      if (!Array.isArray(widgets)) {
        throw new Error(withUsage('The `removeWidgets` method expects an array of widgets. Please use `removeWidget`.'));
      }

      if (widgets.some(function (widget) {
        return typeof widget.dispose !== 'function';
      })) {
        throw new Error(withUsage('The widget definition expects a `dispose` method.'));
      }

      this.mainIndex.removeWidgets(widgets);
      return this;
    }
    /**
     * Ends the initialization of InstantSearch.js and triggers the
     * first search. This method should be called after all widgets have been added
     * to the instance of InstantSearch.js. InstantSearch.js also supports adding and removing
     * widgets after the start as an **EXPERIMENTAL** feature.
     */

  }, {
    key: "start",
    value: function start() {
      var _this3 = this;

      if (this.started) {
        throw new Error(withUsage('The `start` method has already been called once.'));
      } // This Helper is used for the queries, we don't care about its state. The
      // states are managed at the `index` level. We use this Helper to create
      // DerivedHelper scoped into the `index` widgets.


      var mainHelper = external_algoliasearch_helper_default()(this.client, this.indexName);

      mainHelper.search = function () {
        // This solution allows us to keep the exact same API for the users but
        // under the hood, we have a different implementation. It should be
        // completely transparent for the rest of the codebase. Only this module
        // is impacted.
        return mainHelper.searchOnlyWithDerivedHelpers();
      };

      if (this._searchFunction) {
        // this client isn't used to actually search, but required for the helper
        // to not throw errors
        var fakeClient = {
          search: function search() {
            return new Promise(noop["a" /* default */]);
          }
        };
        this._mainHelperSearch = mainHelper.search.bind(mainHelper);

        mainHelper.search = function () {
          var mainIndexHelper = _this3.mainIndex.getHelper();

          var searchFunctionHelper = external_algoliasearch_helper_default()(fakeClient, mainIndexHelper.state.index, mainIndexHelper.state);
          searchFunctionHelper.once('search', function (_ref) {
            var state = _ref.state;
            mainIndexHelper.overrideStateWithoutTriggeringChangeEvent(state);

            _this3._mainHelperSearch();
          }); // Forward state changes from `searchFunctionHelper` to `mainIndexHelper`

          searchFunctionHelper.on('change', function (_ref2) {
            var state = _ref2.state;
            mainIndexHelper.setState(state);
          });

          _this3._searchFunction(searchFunctionHelper);

          return mainHelper;
        };
      } // Only the "main" Helper emits the `error` event vs the one for `search`
      // and `results` that are also emitted on the derived one.


      mainHelper.on('error', function (_ref3) {
        var error = _ref3.error;

        _this3.emit('error', {
          error: error
        });
      });
      this.mainHelper = mainHelper;
      this.mainIndex.init({
        instantSearchInstance: this,
        parent: null,
        uiState: this._initialUiState
      });
      this.middleware.forEach(function (m) {
        m.subscribe();
      });
      mainHelper.search(); // Keep the previous reference for legacy purpose, some pattern use
      // the direct Helper access `search.helper` (e.g multi-index).

      this.helper = this.mainIndex.getHelper(); // track we started the search if we add more widgets,
      // to init them directly after add

      this.started = true;
    }
    /**
     * Removes all widgets without triggering a search afterwards. This is an **EXPERIMENTAL** feature,
     * if you find an issue with it, please
     * [open an issue](https://github.com/algolia/instantsearch.js/issues/new?title=Problem%20with%20dispose).
     * @return {undefined} This method does not return anything
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this.scheduleSearch.cancel();
      this.scheduleRender.cancel();
      clearTimeout(this._searchStalledTimer);
      this.removeWidgets(this.mainIndex.getWidgets());
      this.mainIndex.dispose(); // You can not start an instance two times, therefore a disposed instance
      // needs to set started as false otherwise this can not be restarted at a
      // later point.

      this.started = false; // The helper needs to be reset to perform the next search from a fresh state.
      // If not reset, it would use the state stored before calling `dispose()`.

      this.removeAllListeners();
      this.mainHelper.removeAllListeners();
      this.mainHelper = null;
      this.helper = null;
      this.middleware.forEach(function (m) {
        m.unsubscribe();
      });
    }
  }, {
    key: "scheduleStalledRender",
    value: function scheduleStalledRender() {
      var _this4 = this;

      if (!this._searchStalledTimer) {
        this._searchStalledTimer = setTimeout(function () {
          _this4._isSearchStalled = true;

          _this4.scheduleRender();
        }, this._stalledSearchDelay);
      }
    }
  }, {
    key: "setUiState",
    value: function setUiState(uiState) {
      if (!this.mainHelper) {
        throw new Error(withUsage('The `start` method needs to be called before `setUiState`.'));
      } // We refresh the index UI state to update the local UI state that the
      // main index passes to the function form of `setUiState`.


      this.mainIndex.refreshUiState();
      var nextUiState = typeof uiState === 'function' ? uiState(this.mainIndex.getWidgetUiState({})) : uiState;

      var setIndexHelperState = function setIndexHelperState(indexWidget) {
        if (false) {}

        indexWidget.getHelper().overrideStateWithoutTriggeringChangeEvent(indexWidget.getWidgetSearchParameters(indexWidget.getHelper().state, {
          uiState: nextUiState[indexWidget.getIndexId()]
        }));
        indexWidget.getWidgets().filter(index["isIndexWidget"]).forEach(setIndexHelperState);
      };

      setIndexHelperState(this.mainIndex);
      this.scheduleSearch();
      this.onInternalStateChange();
    }
  }, {
    key: "createURL",
    value: function createURL() {
      var nextState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.started) {
        throw new Error(withUsage('The `start` method needs to be called before `createURL`.'));
      }

      return this._createURL(nextState);
    }
  }, {
    key: "refresh",
    value: function refresh() {
      if (!this.mainHelper) {
        throw new Error(withUsage('The `start` method needs to be called before `refresh`.'));
      }

      this.mainHelper.clearCache().search();
    }
  }]);

  return InstantSearch;
}(external_events_default.a);

/* harmony default export */ var lib_InstantSearch = (InstantSearch_InstantSearch);
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/helpers/get-insights-anonymous-user-token.js

var ANONYMOUS_TOKEN_COOKIE_KEY = '_ALGOLIA';

function getCookie(name) {
  var prefix = "".concat(name, "=");
  var cookies = document.cookie.split(';');

  for (var i = 0; i < cookies.length; i++) {
    var cookie = cookies[i];

    while (cookie.charAt(0) === ' ') {
      cookie = cookie.substring(1);
    }

    if (cookie.indexOf(prefix) === 0) {
      return cookie.substring(prefix.length, cookie.length);
    }
  }

  return undefined;
}

function getInsightsAnonymousUserTokenInternal() {
  return getCookie(ANONYMOUS_TOKEN_COOKIE_KEY);
}
/**
 * @deprecated This function will be still supported in 4.x releases, but not further. It is replaced by the `insights` middleware. For more information, visit https://www.algolia.com/doc/guides/getting-insights-and-analytics/search-analytics/click-through-and-conversions/how-to/send-click-and-conversion-events-with-instantsearch/js/
 */

function getInsightsAnonymousUserToken() {
   false ? undefined : void 0;
  return getInsightsAnonymousUserTokenInternal();
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/lib/infiniteHitsCache/sessionStorage.js
function sessionStorage_objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = sessionStorage_objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function sessionStorage_objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}



function getStateWithoutPage(state) {
  var _ref = state || {},
      page = _ref.page,
      rest = sessionStorage_objectWithoutProperties(_ref, ["page"]);

  return rest;
}

var KEY = 'ais.infiniteHits';

function hasSessionStorage() {
  return typeof window !== 'undefined' && typeof window.sessionStorage !== 'undefined';
}

function createInfiniteHitsSessionStorageCache() {
  return {
    read: function read(_ref2) {
      var state = _ref2.state;

      if (!hasSessionStorage()) {
        return null;
      }

      try {
        var cache = JSON.parse( // @ts-ignore JSON.parse() requires a string, but it actually accepts null, too.
        window.sessionStorage.getItem(KEY));
        return cache && Object(isEqual["a" /* default */])(cache.state, getStateWithoutPage(state)) ? cache.hits : null;
      } catch (error) {
        if (error instanceof SyntaxError) {
          try {
            window.sessionStorage.removeItem(KEY);
          } catch (err) {// do nothing
          }
        }

        return null;
      }
    },
    write: function write(_ref3) {
      var state = _ref3.state,
          hits = _ref3.hits;

      if (!hasSessionStorage()) {
        return;
      }

      try {
        window.sessionStorage.setItem(KEY, JSON.stringify({
          state: getStateWithoutPage(state),
          hits: hits
        }));
      } catch (error) {// do nothing
      }
    }
  };
}
// CONCATENATED MODULE: ./node_modules/instantsearch.js/es/index.js





var es_instantsearch = function instantsearch(options) {
  return new lib_InstantSearch(options);
};

es_instantsearch.version = version;
es_instantsearch.snippet = snippet_snippet;
es_instantsearch.reverseSnippet = reverseSnippet_reverseSnippet;
es_instantsearch.highlight = highlight_highlight;
es_instantsearch.reverseHighlight = reverseHighlight_reverseHighlight;
es_instantsearch.insights = insights_insights;
es_instantsearch.getInsightsAnonymousUserToken = getInsightsAnonymousUserToken;
es_instantsearch.createInfiniteHitsSessionStorageCache = createInfiniteHitsSessionStorageCache;
Object.defineProperty(es_instantsearch, 'widgets', {
  get: function get() {
    throw new ReferenceError("\"instantsearch.widgets\" are not available from the ES build.\n\nTo import the widgets:\n\nimport { searchBox } from 'instantsearch.js/es/widgets'");
  }
});
Object.defineProperty(es_instantsearch, 'connectors', {
  get: function get() {
    throw new ReferenceError("\"instantsearch.connectors\" are not available from the ES build.\n\nTo import the connectors:\n\nimport { connectSearchBox } from 'instantsearch.js/es/connectors'");
  }
});
/* harmony default export */ var es = __webpack_exports__["default"] = (es_instantsearch);

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/MobileMenu.vue?vue&type=template&id=61d1a24a&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._ssrNode("<div class=\"absolute w-full flex bg-blue-100 z-40 inset-0 p-10\">","</div>",[_vm._ssrNode("<div class=\"overflow-y-auto\">","</div>",[_c('DocsContents')],1),_vm._ssrNode(" <div class=\"absolute top-0 right-0 pt-6 pr-10\"><button class=\"ml-1 flex items-center justify-center h-10 w-10 rounded-full hover:text-gray-700\">\n        X\n      </button></div>")],2)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/layout/MobileMenu.vue?vue&type=template&id=61d1a24a&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/MobileMenu.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var MobileMenuvue_type_script_lang_js_ = ({
  components: {},
  methods: {
    closeMobileMenu() {
      this.$emit('closeMobileMenu');
    }

  }
});
// CONCATENATED MODULE: ./components/layout/MobileMenu.vue?vue&type=script&lang=js&
 /* harmony default export */ var layout_MobileMenuvue_type_script_lang_js_ = (MobileMenuvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(3);

// CONCATENATED MODULE: ./components/layout/MobileMenu.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  layout_MobileMenuvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  "11605ef3"
  
)

/* harmony default export */ var MobileMenu = __webpack_exports__["default"] = (component.exports);

/* nuxt-component-imports */
installComponents(component, {DocsContents: __webpack_require__(81).default})


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/DocsContents.vue?vue&type=template&id=81f6c83e&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._ssrNode("<div class=\"text-base\"><h3 class=\"uppercase text-gray-700 font-bold py-3\">\n      Section Header\n    </h3></div>")])}
var staticRenderFns = []


// CONCATENATED MODULE: ./components/layout/DocsContents.vue?vue&type=template&id=81f6c83e&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./components/layout/DocsContents.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var DocsContentsvue_type_script_lang_js_ = ({});
// CONCATENATED MODULE: ./components/layout/DocsContents.vue?vue&type=script&lang=js&
 /* harmony default export */ var layout_DocsContentsvue_type_script_lang_js_ = (DocsContentsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(3);

// CONCATENATED MODULE: ./components/layout/DocsContents.vue





/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  layout_DocsContentsvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  "beefe872"
  
)

/* harmony default export */ var DocsContents = __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = require("clipboard");

/***/ })
/******/ ]);
//# sourceMappingURL=server.js.map